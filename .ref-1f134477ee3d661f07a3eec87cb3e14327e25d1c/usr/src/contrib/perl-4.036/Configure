#! /bin/sh
#
# If these # comments don't work, trim them.  Don't worry about any other
# shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh, I would
# suggest you cut out the prototypical config.h from the end of Configure
# and edit it to reflect your system.  Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# $RCSfile: Configure,v $$Revision: 4.0.1.9 $$Date: 92/06/23 12:28:33 $
#
# Yes, you may rip this off to use in other distribution packages.
# (Note: this Configure script was generated automatically.  Rather than
# working with this copy of Configure, you may wish to get metaconfig.)

cat >/tmp/c1$$ <<EOF
ARGGGHHHH!!!!!

Your csh still thinks true is false.  Write to your vendor today and tell
them that next year Configure ought to "rm /bin/csh" unless they fix their
blasted shell. :-)

[End of diatribe.  We now return you to your regularly scheduled
programming...]

EOF
cat >/tmp/c2$$ <<EOF
OOPS!  You naughty creature!  You didn't run Configure with sh!
I will attempt to remedy the situation by running sh for you...

EOF

true || cat /tmp/c1$$ /tmp/c2$$
true || exec sh $0

export PATH || cat /tmp/c2$$
export PATH || exec sh $0
rm -f /tmp/c1$$ /tmp/c2$$

PATH=".:$PATH:/bin:/usr/bin:/usr/local/bin:/usr/ucb:/usr/local:/usr/lbin:/etc:/usr/new:/usr/new/bin:/usr/nbin"

if test ! -t 0; then
    echo "Say 'sh Configure', not 'sh <Configure'"
    exit 1
fi

(alias) >/dev/null 2>&1 && \
    echo "(I see you are using the Korn shell.  Some ksh's blow up on Configure," && \
    echo "especially on exotic machines.  If yours does, try the Bourne shell instead.)"

unset CDPATH
if test ! -d ../UU; then
    if test ! -d UU; then
	mkdir UU
    fi
    cd UU
fi

case "$1" in
-d) shift; fastread='yes';;
esac

d_eunice=''
define=''
eunicefix=''
loclist=''
expr=''
sed=''
echo=''
cat=''
rm=''
mv=''
cp=''
tail=''
tr=''
mkdir=''
sort=''
uniq=''
grep=''
trylist=''
test=''
inews=''
egrep=''
more=''
pg=''
Mcc=''
vi=''
mailx=''
mail=''
cpp=''
perl=''
emacs=''
ls=''
rmail=''
sendmail=''
shar=''
smail=''
tbl=''
troff=''
nroff=''
uname=''
uuname=''
line=''
chgrp=''
chmod=''
lint=''
sleep=''
pr=''
tar=''
ln=''
lpr=''
lp=''
touch=''
make=''
date=''
csh=''
bash=''
ksh=''
lex=''
flex=''
bison=''
Log=''
Header=''
Id=''
lastuname=''
alignbytes=''
bin=''
installbin=''
byteorder=''
contains=''
cppstdin=''
cppminus=''
d_bcmp=''
d_bcopy=''
d_safebcpy=''
d_bzero=''
d_castneg=''
castflags=''
d_charsprf=''
d_chsize=''
d_crypt=''
cryptlib=''
d_csh=''
d_dosuid=''
d_dup2=''
d_fchmod=''
d_fchown=''
d_fcntl=''
d_flexfnam=''
d_flock=''
d_getgrps=''
d_gethent=''
d_getpgrp=''
d_getpgrp2=''
d_getprior=''
d_htonl=''
d_index=''
d_isascii=''
d_killpg=''
d_lstat=''
d_memcmp=''
d_memcpy=''
d_safemcpy=''
d_memmove=''
d_memset=''
d_mkdir=''
d_msg=''
d_msgctl=''
d_msgget=''
d_msgrcv=''
d_msgsnd=''
d_ndbm=''
d_odbm=''
d_open3=''
d_readdir=''
d_rename=''
d_rewindir=''
d_rmdir=''
d_seekdir=''
d_select=''
d_sem=''
d_semctl=''
d_semget=''
d_semop=''
d_setegid=''
d_seteuid=''
d_setpgrp=''
d_setpgrp2=''
d_setprior=''
d_setregid=''
d_setresgid=''
d_setreuid=''
d_setresuid=''
d_setrgid=''
d_setruid=''
d_shm=''
d_shmat=''
d_voidshmat=''
d_shmctl=''
d_shmdt=''
d_shmget=''
d_socket=''
d_sockpair=''
d_oldsock=''
socketlib=''
d_statblks=''
d_stdstdio=''
d_strctcpy=''
d_strerror=''
d_symlink=''
d_syscall=''
d_telldir=''
d_truncate=''
d_vfork=''
d_voidsig=''
d_tosignal=''
d_volatile=''
d_vprintf=''
d_charvspr=''
d_wait4=''
d_waitpid=''
gidtype=''
groupstype=''
i_fcntl=''
i_gdbm=''
i_grp=''
i_niin=''
i_sysin=''
i_pwd=''
d_pwquota=''
d_pwage=''
d_pwchange=''
d_pwclass=''
d_pwexpire=''
d_pwcomment=''
i_sys_file=''
i_sysioctl=''
i_time=''
i_sys_time=''
i_sys_select=''
d_systimekernel=''
i_utime=''
i_varargs=''
i_vfork=''
intsize=''
libc=''
nm_opts=''
libndir=''
i_my_dir=''
i_ndir=''
i_sys_ndir=''
i_dirent=''
i_sys_dir=''
d_dirnamlen=''
ndirc=''
ndiro=''
mallocsrc=''
mallocobj=''
d_mymalloc=''
mallocptrtype=''
mansrc=''
manext=''
models=''
split=''
small=''
medium=''
large=''
huge=''
optimize=''
ccflags=''
cppflags=''
ldflags=''
cc=''
nativegcc=''
libs=''
n=''
c=''
package=''
randbits=''
scriptdir=''
installscr=''
sig_name=''
spitshell=''
shsharp=''
sharpbang=''
startsh=''
stdchar=''
uidtype=''
usrinclude=''
inclPath=''
void=''
voidhave=''
voidwant=''
w_localtim=''
w_s_timevl=''
w_s_tm=''
yacc=''
lib=''
privlib=''
installprivlib=''
CONFIG=''
: get the name of the package
package=perl
: Here we go...
echo " "
echo "Beginning of configuration questions for $package kit."
: Eunice requires " " instead of "", can you believe it
echo " "

define='define'
undef='undef'
: change the next line if compiling for Xenix/286 on Xenix/386
xlibpth='/usr/lib/386 /lib/386'

: the hints files may add more components to libpth
test -d /usr/cs/lib		&& libpth="$libpth /usr/cs/lib"
test -d /usr/ccs/lib		&& libpth="$libpth /usr/ccs/lib"
test -d /usr/lib		&& libpth="$libpth /usr/lib"
test -d /usr/ucblib		&& libpth="$libpth /usr/ucblib"
test -d /usr/local/lib		&& libpth="$libpth /usr/local/lib"
test -d /usr/lib/large		&& libpth="$libpth /usr/lib/large"
test -d /lib			&& libpth="$libpth /lib"
				   libpth="$libpth $xlibpth"
test -d /lib/large		&& libpth="$libpth /lib/large"
test -d /usr/lib/small		&& libpth="$libpth /usr/lib/small"
test -d /lib/small		&& libpth="$libpth /lib/small"
test -d /usr/lib/cmplrs/cc	&& libpth="$libpth /usr/lib/cmplrs/cc"

smallmach='pdp11 i8086 z8000 i80286 iAPX286'
trap 'echo " "; exit 1' 1 2 3

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
    eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
    eunicefix=/etc/unixtovms.exe
fi

attrlist="DGUX M_I186 M_I286 M_I386 M_I8086 M_XENIX UTS __DGUX__"
attrlist="$attrlist __STDC__ __m88k__ ansi bsd4_2 gcos gimpel"
attrlist="$attrlist hp9000s300 hp9000s500 hp9000s800 hpux"
attrlist="$attrlist i186 i386 i8086 iAPX286 ibm interdata"
attrlist="$attrlist m68k m88k mc300 mc500 mc68000 mc68k mc700 mert"
attrlist="$attrlist ns16000 ns32000 nsc32000 os pdp11 posix pyr sinix"
attrlist="$attrlist sparc sun tower tower32 tower32_600 tower32_800 tss"
attrlist="$attrlist u3b2 u3b20 u3b200 u3b5 ultrix unix vax venix xenix"
attrlist="$attrlist z8000"
boPATH=""
eoPATH="/usr/ucb /bin /usr/bin /usr/local /usr/local/bin /usr/lbin /usr/plx /usr/5bin /vol/local/bin /etc /usr/lib /lib /usr/local/lib /sys5.3/bin /sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/bin /bsd4.3/usr/ucb /bsd43/usr/bin /usr/ccs/lib /opt/SUNWste/bin /usr/opt/SUNWste/bin"
d_newshome="/usr/NeWS"
errnolist=errnolist
h_fcntl=false
h_sys_file=false
serve_shm=""
serve_msg="$undef"
serve_inet_udp=""
serve_inet_tcp=""
serve_unix_udp=""
serve_unix_tcp=""
d_ndir=ndir
voidwant=1
voidwant=7
libswanted="c_s net_s net socket nsl_s nsl nm ndir dir ndbm dbm PW malloc sun m bsd BSD x posix ucb"
inclwanted='/usr/include /usr/netinclude /usr/include/sun /usr/include/bsd /usr/include/lan /usr/ucbinclude'

: Now test for existence of everything in MANIFEST

echo "First let's make sure your kit is complete.  Checking..."
awk '$1 !~ /PACKINGLIST/ {print $1}' ../MANIFEST | split -100
rm -f missing
for filelist in x??; do
    (cd ..; ls `cat UU/$filelist` >/dev/null 2>>UU/missing)
done
if test -s missing; then
    echo "WARNING: the following files are missing:"
    cat missing
    echo "INTERRUPT NOW, OR HIT RETURN TO PROCEED AT YOUR OWN RISK"
    read junk
else
    echo "Looks good..."
fi

: some greps do not return status, grrr.
echo "grimblepritz" >contains.txt
if grep blurfldyick contains.txt >/dev/null 2>&1 ; then
    contains=contains
elif grep grimblepritz contains.txt >/dev/null 2>&1 ; then
    contains=grep
else
    contains=contains
fi
: the following should work in any shell
case "$contains" in
contains*)
    echo " "
    echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
    cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: see if sh knows # comments
echo " "
echo "Checking your sh to see if it knows about # comments..."
if sh -c '#' >/dev/null 2>&1 ; then
    echo "Your sh handles # comments correctly."
    shsharp=true
    spitshell=cat
    echo " "
    echo "Okay, let's see if #! works on this system..."
    if test -f /bsd43/bin/echo; then
	echo "#!/bsd43/bin/echo hi" > spit.sh
    else
	echo "#!/bin/echo hi" > spit.sh
    fi
    $eunicefix spit.sh
    chmod +x spit.sh
    ./spit.sh > today
    if $contains hi today >/dev/null 2>&1; then
	echo "It does."
	sharpbang='#!'
    else
	echo "#! /bin/echo hi" > spit.sh
	$eunicefix spit.sh
	chmod +x spit.sh
	./spit.sh > today
	if test -s today; then
	    echo "It does."
	    sharpbang='#! '
	else
	    echo "It doesn't."
	    sharpbang=': use '
	fi
    fi
else
    echo "Your sh doesn't grok # comments--I will strip them later on."
    shsharp=false
    echo "exec grep -v '^#'" >spitshell
    chmod +x spitshell
    $eunicefix spitshell
    spitshell=`pwd`/spitshell
    echo "I presume that if # doesn't work, #! won't work either!"
    sharpbang=': use '
fi

: figure out how to guarantee sh startup
echo " "
echo "Checking out how to guarantee sh startup..."
startsh=$sharpbang'/bin/sh'
echo "Let's see if '$startsh' works..."
cat >start.sh <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x start.sh
$eunicefix start.sh
if ./start.sh; then
    echo "Yup, it does."
else
    echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
fi

: first determine how to suppress newline on echo command
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >echotmp
if $contains c echotmp >/dev/null 2>&1 ; then
    echo "...using -n."
    n='-n'
    c=''
else
    cat <<'EOM'
...using \c
EOM
    n=''
    c='\c'
fi
echo $n "Type carriage return to continue.  Your cursor should be here-->$c"
read ans

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
case "\$fastread" in
yes) ans=''; echo " " ;;
*) ans='!';;
esac
while expr "X\$ans" : "X!" >/dev/null; do
    read ans
    case "\$ans" in
    \!)
	sh
	echo " "
	echo $n "\$rp $c"
	;;
    \!*)
	set \`expr "X\$ans" : "X!\(.*\)\$"\`
	sh -c "\$*"
	echo " "
	echo $n "\$rp $c"
	;;
    esac
done
rp='Your answer:'
case "\$ans" in
'') ans="\$dflt";;
esac
EOSC

: general instructions
cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the $package package should be installed.  If you get stuck
on a question, you may use a ! shell escape to start a subshell or execute
a command.  Many of the questions will have default answers in square
brackets--typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are
allowed to use the ~name construct to specify the login directory belonging
to "name", even if you don't have a shell which knows about that.  Questions
where this is allowed will be marked "(~name ok)".

EOH
rp="[Type carriage return to continue]"
echo $n "$rp $c"
. myread
cat <<EOH

Much effort has been expended to ensure that this shell script will run on any
Unix system.  If despite that it blows up on you, your best bet is to edit
Configure and run it again. Also, let me (lwall@netlabs.com)
know how I blew it.  If you can't run Configure for some reason, you'll have
to generate a config.sh file by hand.

This installation script affects things in two ways: 1) it may do direct
variable substitutions on some of the files included in this kit, and
2) it builds a config.h file for inclusion in C programs.  You may edit
any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the
SH files.  Configure will offer to let you do this before it runs the SH files.

EOH
rp="[Type carriage return to continue]"
echo $n "$rp $c"
. myread

: find out where common programs are
echo " "
echo "Locating common programs..."
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
    case "\$thing" in
    .)
	if test -d \$dir/\$thing; then
	    echo \$dir
	    exit 0
	fi
	;;
    *)
	if test -f \$dir/\$thing; then
	    echo \$dir/\$thing
	    exit 0
	elif test -f \$dir/\$thing.exe; then
	    : on Eunice apparently
	    echo \$dir/\$thing
	    exit 0
	fi
	;;
    esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
cat
cp
echo
expr
grep
mkdir
mv
rm
sed
sort
tr
uniq
"
trylist="
Mcc
bison
cpp
csh
egrep
line
nroff
perl
test
uname
yacc
"
pth=`echo :$boPATH:$PATH:$eoPATH: | sed -e 's/:/ /g'`
for file in $loclist; do
    xxx=`./loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't know where $file is.  I hope it's in everyone's PATH."
	;;
    esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
ans=offhand
for file in $trylist; do
    xxx=`./loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't see $file out there, $ans."
	ans=either
	;;
    esac
done
case "$egrep" in
egrep)
    echo "Substituting grep for egrep."
    egrep=$grep
    ;;
esac
case "$test" in
test)
    echo "Hopefully test is built into your sh."
    ;;
/bin/test)
    if sh -c "PATH= test true" >/dev/null 2>&1; then
	echo "Using the test built into your sh."
	test=test
    fi
    ;;
*)
    test=test
    ;;
esac
case "$echo" in
echo)
    echo "Hopefully echo is built into your sh."
    ;;
/bin/echo)
    echo " "
    echo "Checking compatibility between /bin/echo and builtin echo (if any)..."
    $echo $n "hi there$c" >Loc1.txt
    echo $n "hi there$c" >Loc2.txt
    if cmp Loc1.txt Loc2.txt >/dev/null 2>&1; then
	echo "They are compatible.  In fact, they may be identical."
    else
	case "$n" in
	'-n') n='' c='\c' ans='\c' ;;
	*) n='-n' c='' ans='-n' ;;
	esac
	cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use /bin/echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use $ans to suppress newlines now.  Life is ridiculous.

FOO
	rp="Your cursor should be here-->"
	$echo $n "$rp$c"
	. myread
    fi
    ;;
*)
    : cross your fingers
    echo=echo
    ;;
esac

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
    echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
    ;;
 ~*)
    if $test -f /bin/csh; then
	/bin/csh -f -c "glob \$1"
	echo ""
    else
	name=\`$expr x\$1 : '..\([^/]*\)'\`
	dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
	if $test ! -d "\$dir"; then
	    me=\`basename \$0\`
	    echo "\$me: can't locate home directory for: \$name" >&2
	    exit 1
	fi
	case "\$1" in
	*/*)
	    echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
	    ;;
	*)
	    echo \$dir
	    ;;
	esac
    fi
    ;;
*)
    echo \$1
    ;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: get old answers, if there is a config file out there
hint=default
if test -f ../config.sh; then
    echo " "
    eval "`grep lastuname ../config.sh`"
    tmp=`(uname -a) 2>&1`
    if test "X$tmp" = "X$lastuname"; then
	dflt=y
    else
	dflt=n
    fi
    lastuname="$tmp"
    rp="I see a config.sh file.  Did Configure make it on THIS system? [$dflt]"
    echo $n "$rp $c"
    . myread
    case "$ans" in
    n*) echo "OK, I'll ignore it."; mv ../config.sh ../config.sh.old;;
    *)  echo "Fetching default answers from your old config.sh file..."
	tmp="$n"
	ans="$c"
        . ../config.sh
	n="$tmp"
	c="$ans"
	hint=previous
	;;
    esac
else
    lastuname=`(uname -a) 2>&1`
fi
if test -d ../hints && test ! -f ../config.sh; then
    echo ' '
    echo "First time through, eh?  I have some defaults handy for the following systems:"
    (cd ../hints; ls -C *.sh | sed 's/\.sh/   /g')
    dflt=''
    : Half the following guesses are probably wrong...
    test -f /irix && dflt="$dflt sgi"
    test -f /xenix && dflt="$dflt sco_xenix"
    test -f /dynix && dflt="$dflt dynix"
    test -f /dnix && dflt="$dflt dnix"
    test -f /bin/mips && /bin/mips && dflt="$dflt mips"
    test -d /NextApps && test -f /usr/adm/software_version && dflt="$dflt next"
    if test -f /bin/uname || test -f /usr/bin/uname; then
	set `uname -a | tr '[A-Z]' '[a-z]'`

	test -f "../hints/$5.sh" && dflt="$dflt $5"

	case "$5" in
	3b2) dflt="$dflt 3b2";;
	fps*) dflt="$dflt fps";;
	mips*) dflt="$dflt mips";;
	[23]100) dflt="$dflt mips";;
	next*) dflt="$dflt next" ;;
	6000) dflt="$dflt mc6000";;
	esac

	test -f "../hints/$1.sh" && dflt="$dflt $1"

	case "$1" in
	aix) dflt="$dflt aix_rs" ;;
	sunos) case "$3" in
	    3.4) dflt="$dflt sunos_3_4" ;;
	    3.5) dflt="$dflt sunos_3_5" ;;
	    4.0.1) dflt="$dflt sunos_4_0_1" ;;
	    4.0.2) dflt="$dflt sunos_4_0_2" ;;
	    esac
	    ;;
	hp*ux) dflt="$dflt hpux"
	    extra_hints="hp"`echo $5 | sed -e s#/#_#g -e s/..$/00/`
	    if test -f ../hints/$extra_hints.sh; then
		dflt="$dflt $extra_hints"
	    fi;;
	irix) dflt="$dflt sgi" ;;
	ultrix) case "$3" in
	    1*) dflt="$dflt ultrix_1" ;;
	    3*) dflt="$dflt ultrix_3" ;;
	    4*) dflt="$dflt ultrix_4" ;;
	    esac
	    ;;
	uts) dflt="$dflt uts" ;;
	$2) if test -f /etc/systemid; then
		set `echo $3 | sed 's/\./ /'` $4
		if test -f ../hints/sco_$1_$2_$3.sh; then
		    dflt="$dflt sco_$1_$2_$3"
		elif test -f ../hints/sco_$1_$2.sh; then
		    dflt="$dflt sco_$1_$2"
		elif test -f ../hints/sco_$1.sh; then
		    dflt="$dflt sco_$1"
		fi
	    fi
	    ;;
	esac
    fi
    set X `echo $dflt | tr ' ' '\012' | sort | uniq`
    shift
    dflt=${1+"$@"}
    case "$dflt" in
    '') dflt=none;;
    esac
    echo '(You may give one or more space-separated answers, or "none" if appropriate.'
    echo 'If your OS version has no hints, do not give a wrong version--say "none".)'
    rp="Which of these apply, if any? [$dflt]"
    echo $n "$rp $c"
    . myread
    for file in $ans; do
	if test -f ../hints/$file.sh; then
	    . ../hints/$file.sh
	    cat ../hints/$file.sh >>../config.sh
	    hint=recommended
	fi
    done
fi

cat >whoa <<'EOF'
eval "was=\$$2"
dflt=y
echo ' '
echo "*** WHOA THERE!!! ***"
echo "    The $hint value for \$$2 on this machine was \"$was\"!"
rp="    Keep the $hint value? [y]"
echo $n "$rp $c"
. myread
case "$ans" in
y) td=$was; tu=$was;;
esac
EOF

setvar='td=$define; tu=$undef; set X $1; eval "was=\$$2";
case "$val$was" in
defineundef) . whoa; eval "$2=\$td";;
undefdefine) . whoa; eval "$2=\$tu";;
*) eval "$2=$val";;
esac'

: determine where manual pages go
$cat <<EOM
  
$package has manual pages available in source form.
EOM
case "$nroff" in
'nroff')
    echo "However, you don't have nroff, so they're probably useless to you."
    case "$mansrc" in
    '')
	mansrc="none"
	;;
    esac
esac
echo "If you don't want the manual sources installed, answer 'none'."
case "$mansrc" in
'')
    dflt=`./loc . none /usr/man/local/man1 /usr/man/man.L /usr/man/manl /usr/man/mann /usr/man/u_man/man1 /usr/man/man1 /usr/local/man/man1`
    ;;
*)  dflt="$mansrc"
    ;;
esac
cont=true
while $test "$cont" ; do
    echo " "
    rp="Where do the manual pages (source) go (~name ok)? [$dflt]"
    $echo $n "$rp $c"
    . myread
    case "$ans" in
    'none')
	mansrc=''
	cont=''
	;;
    *)
        mansrc=`./filexp "$ans"`
        if $test -d "$mansrc"; then
	    cont=''
        else
	    if $test "$fastread" = yes; then
	        dflt=y
	    else
	        dflt=n
	    fi
	    rp="Directory $mansrc doesn't exist.  Use that name anyway? [$dflt]"
	    $echo $n "$rp $c"
	    . myread
	    dflt=''
	    case "$ans" in
	    y*) cont='';;
	    esac
        fi
	;;
    esac
done
case "$mansrc" in
'')
    manext=''
    ;;
*l)
    manext=l
    ;;
*n)
    manext=n
    ;;
*o)
    manext=l
    ;;
*p)
    manext=n
    ;;
*C)
    manext=C
    ;;
*L)
    manext=L
    ;;
*)
    manext=1
    ;;
esac

: Sigh.  Well, at least the box is fast...
echo " "
$echo $n "Hmm...  $c"
case "$usrinclude" in
'') dflt='/usr/include';;
*) dflt=$usrinclude;;
esac
inclPath=''
if $test -f /bin/mips && /bin/mips; then
    echo "Looks like a MIPS system..."
    $cat >usrinclude.c <<'EOCP'
#ifdef SYSTYPE_BSD43
/bsd43
#endif
EOCP
    if cc -E usrinclude.c > usrinclude.out && $contains / usrinclude.out >/dev/null 2>&1 ; then
	echo "and you're compiling with the BSD43 compiler and libraries."
	dflt='/bsd43/usr/include'
	inclPath='/bsd43'
    else
	echo "and you're compiling with the SysV compiler and libraries."
    fi
else
    echo "Doesn't look like a MIPS system."
    echo "exit 1" >mips
    chmod +x mips
    $eunicefix mips
fi

cont=true
while $test "$cont" ; do
    echo " "
    rp="Where are the include files you want to use? [$dflt]"
    $echo $n "$rp $c"
    . myread
    usrinclude="$ans"
    if $test -d $ans; then
	cont=''
    else
	if $test "$fastread" = yes; then
	    dflt=y
	else
	    dflt=n
	fi
	rp="Directory $ans doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

: make some quick guesses about what we are up against
echo " "
echo exit 1 >bsd
echo exit 1 >usg
echo exit 1 >v7
echo exit 1 >osf1
echo exit 1 >eunice
echo exit 1 >xenix
echo exit 1 >venix
cat $usrinclude/signal.h $usrinclude/sys/signal.h >guess.txt 2>/dev/null
if test "$usrinclude" = "/bsd43/usr/include" ; then
    echo "Looks kind of like a SysV MIPS running BSD, but we'll see..."
    echo exit 0 >bsd
elif test -f /osf_boot || $contains "OSF/1" /usr/include/ctype.h; then
    echo "Looks like an OSF/1 system, but we'll see..."
    echo exit 0 >osf1
elif test `echo abc | tr a-z A-Z` = Abc ; then
    echo "Looks kind of like a USG system, but we'll see..."
    echo exit 0 >usg
elif $contains SIGTSTP guess.txt >/dev/null 2>&1 ; then
    echo "Looks kind of like a BSD system, but we'll see..."
    echo exit 0 >bsd
else
    echo "Looks kind of like a version 7 system, but we'll see..."
    echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
    cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
    echo "exit 0" >eunice
    d_eunice="$define"
    ;;
*)
    echo " "
    echo "Congratulations.  You aren't running Eunice."
    d_eunice="$undef"
    ;;
esac
if test -f /xenix; then
    echo "Actually, this looks more like a XENIX system..."
    echo "exit 0" >xenix
else
    echo " "
    echo "It's not Xenix..."
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
    echo "Actually, this looks more like a VENIX system..."
    echo "exit 0" >venix
else
    echo " "
    if xenix; then
	: null
    else
	echo "Nor is it Venix..."
    fi
fi
chmod +x bsd usg v7 osf1 eunice venix
$eunicefix bsd usg v7 eunice venix

: see what memory models we can support
case "$models" in
'')
    : We may not use Cppsym or we get a circular dependency through cc.
    : But this should work regardless of which cc we eventually use.
    cat >pdp11.c <<'EOP'
main() {
#ifdef pdp11
    exit(0);
#else
    exit(1);
#endif
}
EOP
    cc -o pdp11 pdp11.c >/dev/null 2>&1
    if pdp11 2>/dev/null; then
	dflt='unsplit split'
    else
	ans=`./loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
	case "$ans" in
	X) dflt='none';;
	*)  if $test -d /lib/small || $test -d /usr/lib/small; then
		dflt='small'
	    else
		dflt=''
	    fi
	    if $test -d /lib/medium || $test -d /usr/lib/medium; then
		dflt="$dflt medium"
	    fi
	    if $test -d /lib/large || $test -d /usr/lib/large; then
		dflt="$dflt large"
	    fi
	    if $test -d /lib/huge || $test -d /usr/lib/huge; then
		dflt="$dflt huge"
	    fi
	esac
    fi
    ;;
*)  dflt="$models" ;;
esac
$cat <<EOM
 
Some systems have different model sizes.  On most systems they are called
small, medium, large, and huge.  On the PDP11 they are called unsplit and
split.  If your system doesn't support different memory models, say "none".
If you wish to force everything to one memory model, say "none" here and
put the appropriate flags later when it asks you for other cc and ld flags.
Venix systems may wish to put "none" and let the compiler figure things out.
(In the following question multiple model names should be space separated.)

EOM
rp="Which models are supported? [$dflt]"
$echo $n "$rp $c"
. myread
models="$ans"

case "$models" in
none)
    small=''
    medium=''
    large=''
    huge=''
    unsplit=''
    split=''
    ;;
*split)
    case "$split" in
    '') 
	if $contains '\-i' $mansrc/man1/ld.1 >/dev/null 2>&1 || \
	   $contains '\-i' $mansrc/man1/cc.1 >/dev/null 2>&1; then
	    dflt='-i'
	else
	    dflt='none'
	fi
	;;
    *) dflt="$split";;
    esac
    rp="What flag indicates separate I and D space? [$dflt]"
    $echo $n "$rp $c"
    . myread
    case "$ans" in
    none) ans='';;
    esac
    split="$ans"
    unsplit=''
    ;;
*large*|*small*|*medium*|*huge*)
    case "$models" in
    *large*)
	case "$large" in
	'') dflt='-Ml';;
	*) dflt="$large";;
	esac
	rp="What flag indicates large model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	large="$ans"
	;;
    *) large='';;
    esac
    case "$models" in
    *huge*)
	case "$huge" in
	'') dflt='-Mh';;
	*) dflt="$huge";;
	esac
	rp="What flag indicates huge model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	huge="$ans"
	;;
    *) huge="$large";;
    esac
    case "$models" in
    *medium*)
	case "$medium" in
	'') dflt='-Mm';;
	*) dflt="$medium";;
	esac
	rp="What flag indicates medium model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	medium="$ans"
	;;
    *) medium="$large";;
    esac
    case "$models" in
    *small*)
	case "$small" in
	'') dflt='none';;
	*) dflt="$small";;
	esac
	rp="What flag indicates small model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	small="$ans"
	;;
    *) small='';;
    esac
    ;;
*)
    echo "Unrecognized memory models--you may have to edit Makefile.SH"
    ;;
esac

: see if we need a special compiler
echo " "
if usg; then
    case "$cc" in
    '')
	case "$Mcc" in
	/*) dflt='Mcc'
	    ;;
	*)
	    case "$large" in
	    -M*)
		dflt='cc'
		;;
	    *)
		if $contains '\-M' $mansrc/cc.1 >/dev/null 2>&1 ; then
		    dflt='cc -M'
		else
		    dflt='cc'
		fi
		;;
	    esac
	    ;;
	esac
	;;
    *)  dflt="$cc";;
    esac
    $cat <<'EOM'
  
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the
"Mcc" command may be used to force these to be resolved.  On other systems
a "cc -M" command is required.  (Note that the -M flag on other systems
indicates a memory model to use!)  If you have the Gnu C compiler, you
might wish to use that instead.  What command will force resolution on
EOM
    $echo $n "this system? [$dflt] $c"
    rp="Command to resolve multiple refs? [$dflt]"
    . myread
    cc="$ans"
else
    case "$cc" in
    '') dflt=cc;;
    *) dflt="$cc";;
    esac
    rp="Use which C compiler? [$dflt]"
    $echo $n "$rp $c"
    . myread
    cc="$ans"
fi
case "$cc" in
*gcc*) cpp=`./loc gcc-cpp $cpp $pth`
    case "$nativegcc" in
    '') case "$ccflags" in
	*-fpcc-struct-return*) dflt=n;;
	*) dflt=y;;
	esac
	;;
    undef) dflt=n;;
    *) dflt=y;;
    esac
    echo " "
    rp="Are your system (especially dbm) libraries compiled with gcc? [$dflt]"
    $echo $n "$rp $c"
    . myread
    case "$ans" in
    n*) nativegcc="$undef"; gccflags='-fpcc-struct-return';;
    *) nativegcc="$define"; gccflags='';;
    esac
    case "$gccflags" in
    *-ansi*) ;;
    *-traditional*) ;;
    *) gccflags="$gccflags -traditional -Dvolatile=__volatile__" ;;
    esac
    ;;
esac

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' ') dflt="none"
     ;;
'') dflt="-O";
    ;;
*)  dflt="$optimize"
    ;;
esac
cat <<EOH

Some C compilers have problems with their optimizers, by default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might
want to use the symbolic debugger, which uses the -g flag (on traditional
Unix systems).  Either flag can be specified here.  To use neither flag,
specify the word "none".
  
EOH
rp="What optimizer/debugger flag should be used? [$dflt]"
$echo $n "$rp $c"
. myread
optimize="$ans"
case "$optimize" in
'none') optimize=" "
     ;;
esac

case "$ccflags" in
'') case "$cc" in
    *gcc*) dflt="$gccflags";;
    *) dflt='';;
    esac
    ;;
*-fpcc-struct-return*) dflt="$ccflags";;
*) case "$cc" in
    *gcc*) dflt="$ccflags $gccflags";;
    *) dflt="$ccflags";;
    esac
    ;;
esac
for thisincl in $inclwanted; do
    if test -d $thisincl; then
	if test "x$thisincl" != "x$usrinclude"; then
	    case "$dflt" in
	    *$thisincl*);;
	    *) dflt="$dflt -I$thisincl";;
	    esac
	fi
    fi
done
case "$optimize" in
-g*)
    case "$dflt" in
    *DEBUGGING*);;
    *) dflt="$dflt -DDEBUGGING";;
    esac
    ;;
esac
if $contains 'LANGUAGE_C' $usrinclude/signal.h >/dev/null 2>&1; then
    case "$dflt" in
    *LANGUAGE_C*);;
    *) dflt="$dflt -DLANGUAGE_C";;
    *) if osf1; then
          dflt="$dflt -D__LANGUAGE_C__"
       else
          dflt="$dflt -DLANGUAGE_C"
       fi
       ;;
    esac
fi
if $contains '_NO_PROTO' $usrinclude/signal.h >/dev/null 2>&1; then
    case "$dflt" in
    *_NO_PROTO*);;
    *) osf1 || dflt="$dflt -D_NO_PROTO";;
    esac
fi
case "$dflt" in
'') dflt=none;;
esac
cat <<EOH

Your C compiler may want other flags.  For this question you should
include -I/whatever and -DWHATEVER flags and any other flags used by
the C compiler, but you should NOT include libraries or ld flags like
-lwhatever.  For instance, this would be a good place to specify
-DDEBUGGING.  To use no flags, specify the word "none".
  
EOH
rp="Any additional cc flags? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
ccflags="$ans"

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$cc" in
*gcc*) cppflags="$cppflags -D__GNUC__";;
esac
case "$cppflags" in
'');;
*)  set X $cppflags
    cppflags=''
    for flag; do
	case $flag in
	-D*|-U*|-I*|-traditional|-ansi|-nostdinc) cppflags="$cppflags $flag";;
	esac
    done
    case "$cppflags" in
    *-*)  echo "(C preprocessor flags: $cppflags)";;
    esac
    ;;
esac

case "$ldflags" in
'') if venix; then
	dflt='-i -z'
    else
	dflt='none'
    fi
    ;;
*) dflt="$ldflags";;
esac
echo " "
rp="Any additional ld flags (NOT including libraries)? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
ldflags="$ans"

echo " "
echo "Checking for optional libraries..."
case "$libs" in
'') dflt=' ';;
*) dflt="$libs ";;
esac
case "$libswanted" in
'') libswanted='c_s';;
esac
for thislib in $libswanted; do
    case "$thislib" in
    dbm) thatlib=ndbm;;
    *_s) thatlib=NONE;;
    *) thatlib="${thislib}_s";;
    *) thatlib=NONE;;
    esac
    xxx=`./loc lib$thislib.a X /usr/ccs/lib /usr/lib /usr/ucblib /usr/local/lib /lib`
    if test -f $xxx; then
	echo "Found -l$thislib."
	case "$dflt" in
	*-l$thislib\ *|*-l$thatlib\ *);;
	*) dflt="$dflt -l$thislib ";;
	esac
    else
	xxx=`./loc lib$thislib.a X $libpth`
	if test -f $xxx; then
	    echo "Found $xxx."
	    case "$dflt" in
	    *"$xxx "*);;
	    *) dflt="$dflt $xxx ";;
	    esac
	else
	    xxx=`./loc Slib$thislib.a X $xlibpth`
	    if test -f $xxx; then
		echo "Found -l$thislib."
		case "$dflt" in
		*-l$thislib\ *|*-l$thatlib\ *);;
		*) dflt="$dflt -l$thislib ";;
		esac
	    else
		xxx=`./loc lib$thislib.so X /usr/ccs/lib /usr/lib /usr/ucblib /usr/local/lib /lib`
		if test -f $xxx; then
		    echo "Found -l$thislib as a shared object only."
		    case "$dflt" in
		    *-l$thislib\ *|*-l$thatlib\ *);;
		    *) dflt="$dflt -l$thislib ";;
		    esac
		else
		    echo "No -l$thislib."
		fi
	    fi
	fi
    fi
done
set X $dflt
shift
dflt="$*"
case "$dflt" in
'') dflt='none';;
esac

$cat <<EOM
 
Some versions of Unix support shared libraries, which make
executables smaller but make load time slightly longer.

On some systems, mostly newer Unix System V's, the shared library
is included by putting the option "-lc_s" as the last thing on the
cc command line when linking.  Other systems use shared libraries
by default.  There may be other libraries needed to compile $package
on your machine as well.  If your system needs the "-lc_s" option,
include it here.  Include any other special libraries here as well.
Say "none" for none.
EOM

echo " "
rp="Any additional libraries? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
libs="$ans"

: check for size of random number generator
echo " "
case "$alignbytes" in
'')
    echo "Checking alignment constraints..."
    $cat >try.c <<'EOCP'
struct foobar {
    char foo;
    double bar;
} try;
main()
{
    printf("%d\n", (char*)&try.bar - (char*)&try.foo);
}
EOCP
    if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
	dflt=`./try`
    else
	dflt='?'
	echo "(I can't seem to compile the test program...)"
    fi
    ;;
*)
    dflt="$alignbytes"
    ;;
esac
rp="Doubles must be aligned on a how-many-byte boundary? [$dflt]"
$echo $n "$rp $c"
. myread
alignbytes="$ans"
$rm -f try.c try

: determine where public executables go
cat <<EOF
 
The following questions distinguish the directory in which executables
reside from the directory in which they are installed (and from which they
are presumably copied to the former directory by occult means).  This
distinction is often necessary under afs.  On most other systems, however,
the two directories are the same.
 
EOF
case "$bin" in
'')
    dflt=`./loc . /usr/local/bin /usr/local/bin /usr/lbin /usr/local /usr/bin /bin`
    ;;
*)  dflt="$bin"
    ;;
esac
cont=true
while $test "$cont" ; do
    rp="In which directory will public executables reside (~name ok)? [$dflt]"
    $echo "In which directory will public executables reside (~name ok)?"
    $echo $n "[$dflt] $c"
    . myread
    bin="$ans"
    bin=`./filexp $bin`
    if test -d $bin; then
	cont=''
    else
	case "$fastread" in
	yes) dflt=y;;
	*) dflt=n;;
	esac
	rp="Directory $bin doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

case "$bin" in
  ?????????????????????????)
    cat <<EOF

NOTE: you have a fairly long path name there.  Some systems have trouble
executing a script if the #! line ends up longer than 32 characters.  If
you have this trouble you may have to reinstall somewhere else, or make
a symbolic link from someplace with a shorter name.

EOF
    ;;
esac

case "$installbin" in
'')
    dflt=`echo $bin | sed 's#^/afs/#/afs/.#'`
    test -d $dflt || dflt="$bin"
    ;;
*)  dflt="$installbin"
    ;;
esac
cont=true
while $test "$cont" ; do
    rp="In which directory will public executables be installed (~name ok)? [$dflt]"
    $echo "In which directory will public executables be installed (~name ok)?"
    $echo $n "[$dflt] $c"
    . myread
    installbin="$ans"
    installbin=`./filexp $installbin`
    if test -d $installbin; then
	cont=''
    else
	case "$fastread" in
	yes) dflt=y;;
	*) dflt=n;;
	esac
	rp="Directory $installbin doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

: check for ordering of bytes in a long
case "$byteorder" in
'')
cat <<'EOM'
  
In the following, larger digits indicate more significance.  A big-endian
machine like a Pyramid or a Motorola 680?0 chip will come out to 4321.  A
little-endian machine like a Vax or an Intel 80?86 chip would be 1234.  Other
machines may have weird orders like 3412.  A Cray will report 87654321.  If
the test program works the default is probably right.
I'm now running the test program...
EOM
    $cat >byteorder.c <<'EOCP'
#include <stdio.h>
main()
{
    int i;
    union {
	unsigned long l;
	char c[sizeof(long)];
    } u;

    if (sizeof(long) > 4)
	u.l = (0x08070605L << 32) | 0x04030201L;
    else
	u.l = 0x04030201L;
    for (i=0; i < sizeof(long); i++)
	printf("%c",u.c[i]+'0');
    printf("\n");
}
EOCP
    if $cc byteorder.c -o byteorder >/dev/null 2>&1 ; then
	dflt=`./byteorder`
	case "$dflt" in
	????|????????) echo "(The test program ran ok.)";;
	*) echo "(The test program didn't run right for some reason.)";;
	esac
    else
	dflt='4321'
	echo "(I can't seem to compile the test program.  Guessing big-endian...)"
    fi
    ;;
*)
    echo " "
    dflt="$byteorder"
    ;;
esac
rp="What is the order of bytes in a long? [$dflt]"
$echo $n "$rp $c"
. myread
byteorder="$ans"

: check for ability to cast negative floats to unsigned
echo " "
echo 'Checking to see if your C compiler can cast weird floats to unsigned'
$cat >try.c <<'EOCP'
#include <signal.h>

blech() { exit(3); }

main()
{
	double f = -123;
	unsigned long along;
	unsigned int aint;
	unsigned short ashort;
	int result = 0;

	signal(SIGFPE, blech);
	along = (unsigned long)f;
	aint = (unsigned int)f;
	ashort = (unsigned short)f;
	if (along != (unsigned long)-123)
	    result |= 1;
	if (aint != (unsigned int)-123)
	    result |= 1;
	if (ashort != (unsigned short)-123)
	    result |= 1;
	f = (double)0x40000000;
	f = f + f;
	along = 0;
	along = (unsigned long)f;
	if (along != 0x80000000)
	    result |= 2;
	f -= 1;
	along = 0;
	along = (unsigned long)f;
	if (along != 0x7fffffff)
	    result |= 1;
	f += 2;
	along = 0;
	along = (unsigned long)f;
	if (along != 0x80000001)
	    result |= 2;
	exit(result);
}
EOCP
if $cc -o try $ccflags try.c >/dev/null 2>&1; then
    ./try
    castflags=$?
else
    castflags=3
fi
case "$castflags" in
0)  val="$define"
    echo "Yup, it does."
    ;;
*)  val="$undef"
    echo "Nope, it doesn't."
    ;;
esac
set d_castneg
eval $setvar
$rm -f try.*

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..."
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT

cd ..
echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
chmod 755 cppstdin
wrapper=cppstdin

case "$cppstdin" in
/*cppstdin) cppstdin=cppstdin;;
esac
cp cppstdin UU
cd UU

if test "X$cppstdin" != "X" && \
  $cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
  $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "You used to use $cppstdin $cppminus so we'll use that again."
elif test "$cc" = gcc && \
  (echo "Using gcc, eh?  We'll try to force gcc -E using a wrapper..."; \
  $wrapper <testcpp.c >testcpp.out 2>&1; \
  $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1) ; then
    echo "Yup, we can."
    cppstdin="$wrapper"
    cppminus='';
elif echo 'Maybe "'"$cc"' -E" will work...'; \
  $cc -E <testcpp.c >testcpp.out 2>&1; \
  $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "Yup, it does."
    cppstdin="$cc -E"
    cppminus='';
elif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
  $cc -E - <testcpp.c >testcpp.out 2>&1; \
  $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "Yup, it does."
    cppstdin="$cc -E"
    cppminus='-';
elif echo 'No such luck, maybe "'$cpp'" will work...'; \
  $cpp <testcpp.c >testcpp.out 2>&1; \
  $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "It works!"
    cppstdin="$cpp"
    cppminus='';
elif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
  $cpp - <testcpp.c >testcpp.out 2>&1; \
  $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "Hooray, it works!  I was beginning to wonder."
    cppstdin="$cpp"
    cppminus='-';
elif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
  $wrapper <testcpp.c >testcpp.out 2>&1; \
  $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    cppstdin="$wrapper"
    cppminus=''
    echo "Eureka!."
elif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
  $cc -P <testcpp.c >testcpp.out 2>&1; \
  $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "Yipee, that works!"
    cppstdin="$cc -P"
    cppminus='';
elif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
  $cc -P - <testcpp.c >testcpp.out 2>&1; \
  $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "At long last!"
    cppstdin="$cc -P"
    cppminus='-';
else
    dflt=blurfl
    $echo $n "No dice.  I can't find a C preprocessor.  Name one: $c"
    rp='Name a C preprocessor:'
    . myread
    cppstdin="$ans"
    $cppstdin <testcpp.c >testcpp.out 2>&1
    if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "OK, that will do."
    else
	echo "Sorry, I can't get that to work.  Go find one and rerun Configure."
	exit 1
    fi
fi

: get list of predefined functions in a handy place
echo " "
case "$libc" in
'') libc=unknown;;
esac
case "$nm_opts" in
'') if test -f /mach_boot; then
	nm_opts=''
    elif test -d /usr/ccs/lib; then
	nm_opts='-p'
    else
	nm_opts=''
    fi
    ;;
esac
: on mips, we DO NOT want /lib, and we want inclPath/usr/lib
case "$libpth" in
'') if mips; then
	libpth='$inclPath/usr/lib /usr/local/lib'
	nm_opts="-B"
    else
	libpth='/usr/ccs/lib /lib /usr/lib /usr/ucblib /usr/local/lib'
    fi
    ;;
esac
case "$libs" in
*-lc_s*) libc=`./loc libc_s.a $libc $libpth`
esac
libnames='';
case "$libs" in
'') ;;
*)  for thislib in $libs; do
	case "$thislib" in
	-l*) thislib=`expr X$thislib : 'X-l\(.*\)'`
	    try=`./loc lib$thislib.a blurfl/dyick $libpth`
	    if test ! -f $try; then
		try=`./loc lib$thislib blurfl/dyick $libpth`
		if test ! -f $try; then
		    try=`./loc $thislib blurfl/dyick $libpth`
		    if test ! -f $try; then
			try=`./loc Slib$thislib.a blurfl/dyick $xlibpth`
			if test ! -f $try; then
			    try=''
			fi
		    fi
		fi
	    fi
	    libnames="$libnames $try"
	    ;;
	*) libnames="$libnames $thislib" ;;
	esac
    done
    ;;
esac
set /usr/ccs/lib/libc.so
test -f $1 || set /usr/lib/libc.so
test -f $1 || set /usr/shlib/libc.so
test -f $1 || set /usr/lib/libc.so.[0-9]*
test -f $1 || set /lib/libsys_s.a
eval set \$$#
if test -f "$1"; then
    echo "Your (shared) C library seems to be in $1."
    libc="$1"
elif test -f "$libc"; then
    echo "Your C library seems to be in $libc."
elif test -f /lib/libc.a; then
    echo "Your C library seems to be in /lib/libc.a.  You're normal."
    libc=/lib/libc.a
else
    if   ans=`./loc libc.a  blurfl/dyick $libpth`; test -f "$ans"; then
	:
    elif ans=`./loc libc    blurfl/dyick $libpth`; test -f "$ans"; then
	    libnames="$libnames "`./loc clib blurfl/dyick $libpth`
    elif ans=`./loc clib    blurfl/dyick $libpth`; test -f "$ans"; then
	:
    elif ans=`./loc Slibc.a blurfl/dyick $xlibpth`; test -f "$ans"; then
	:
    elif ans=`./loc Mlibc.a blurfl/dyick $xlibpth`; test -f "$ans"; then
	:
    elif ans=`./loc Llibc.a blurfl/dyick $xlibpth`; test -f "$ans"; then
	:
    fi
    if test -f "$ans"; then
	echo "Your C library seems to be in $ans, of all places."
	libc=$ans
    else
	cat <<EOM
 
I can't seem to find your C library.  I've looked in the following places:

	$libpth

None of these seems to contain your C library.  What is the full name
EOM
	dflt=None
	$echo $n "of your C library? $c"
	rp='C library full name?'
	. myread
	libc="$ans"
    fi
fi
echo " "
if test $libc = "/lib/libc"; then
    libc="$libc /lib/clib"
fi
cat <<END
 
If the guess above is wrong (which it might be if you're using a strange
compiler, or your machine supports multiple models), you can override it here.
END
dflt="$libc";
rp="Your C library is where? [$dflt]"
$echo $n "$rp $c"
. myread
libc="$ans"
echo " "
echo $libc $libnames | tr ' ' '\012' | sort | uniq >libnames
$echo "Extracting names from the following files for later perusal:"
sed 's/^/	/' libnames
echo $n "This may take a while...$c"
set X `cat libnames`
shift
nm $nm_opts $* 2>/dev/null >libc.tmp
$sed -n -e 's/^.* [ATDS]  *[_.]*//p' -e 's/^.* [ATDS] //p' <libc.tmp >libc.list
if $contains '^printf$' libc.list >/dev/null 2>&1; then
    echo done
elif $sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p' \
	<libc.tmp >libc.list; \
  $contains '^printf$' libc.list >/dev/null 2>&1; then
    echo done
elif $sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p' <libc.tmp >libc.list; \
  $contains '^printf$' libc.list >/dev/null 2>&1; then
    echo done
elif $sed -n -e 's/^.* D __*//p' -e 's/^.* D //p' <libc.tmp >libc.list; \
  $contains '^printf$' libc.list >/dev/null 2>&1; then
    echo done
elif $sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p' \
		<libc.tmp >libc.list; \
  $contains '^printf$' libc.list >/dev/null 2>&1; then
    echo done
elif $grep '|' <libc.tmp | $sed -n -e '/|COMMON/d' -e '/|DATA/d' -e '/ file/d' \
                                   -e 's/^\([^     ]*\).*/\1/p' >libc.list
  $contains '^printf$' libc.list >/dev/null 2>&1; then
    echo done
elif $sed -n -e 's/^.*|FUNC |GLOB .*|//p' -e 's/^.*|FUNC |WEAK .*|//p' \
	   <libc.tmp >libc.list; \
  $contains '^printf$' libc.list >/dev/null 2>&1; then
    echo done
elif $sed -n -e 's/^[         ]*[0-9][0-9a-f]*[       ]*Def. Text[    ]*//p' \
	   < libc.tmp | $sed -e 's/\[.*\]//' > libc.list; \
  $contains '^printf$' libc.list >/dev/null 2>&1; then
      echo done
else
    nm -p $* 2>/dev/null >libc.tmp
    $sed -n -e 's/^.* [AT]  *_[_.]*//p' -e 's/^.* [AT] //p' <libc.tmp >libc.list
    if $contains '^printf$' libc.list >/dev/null 2>&1; then
	nm_opts='-p'
	echo "done"
    else
	echo " "
	echo "nm didn't seem to work right."
	echo "Trying ar instead..."
	if ar t $libc > libc.tmp; then
	    for thisname in $libnames; do
		ar t $thisname >>libc.tmp
	    done
	    $sed -e 's/\.o$//' < libc.tmp > libc.list
	    echo "Ok."
	else
	    echo "ar didn't seem to work right."
	    echo "Maybe this is a Cray...trying bld instead..."
	    if bld t $libc | $sed -e 's/.*\///' -e 's/\.o:.*$//' > libc.list; then
		for thisname in $libnames; do
		    bld t $libnames | \
			$sed -e 's/.*\///' -e 's/\.o:.*$//' >>libc.list
		    ar t $thisname >>libc.tmp
		done
		echo "Ok."
	    else
		echo "That didn't work either.  Giving up."
		exit 1
	    fi
	fi
    fi
fi
if test -f /lib/syscalls.exp; then
    echo "Also extracting names from /lib/syscalls.exp for good ole AIX..."
    sed -n 's/^\([^ 	]*\)[ 	]*syscall$/\1/p' /lib/syscalls.exp >>libc.list
fi

inlibc='echo " "; td=$define; tu=$undef;
if $contains "^$1\$" libc.list >/dev/null 2>&1;
then echo "$1() found";
  eval "case \"\$$2\" in undef) . whoa; esac"; eval "$2=\$td";
else echo "$1() NOT found";
  eval "case \"\$$2\" in define) . whoa; esac"; eval "$2=\$tu"; fi'

: see if bcmp exists
set bcmp d_bcmp
eval $inlibc

: see if bcopy exists
set bcopy d_bcopy
eval $inlibc

case "$d_safebcpy" in
'')
    : assume the worst
    d_safebcpy=undef
    case "$d_bcopy" in
    define)
	echo "Checking to see if your bcopy() can do overlapping copies..."
	$cat >safebcpy.c <<'EOCP'
main()
{
    char buf[128];
    register char *b;
    register int len;
    register int off;
    register int align;

    for (align = 7; align >= 0; align--) {
	for (len = 36; len; len--) {
	    b = buf+align;
	    bcopy("abcdefghijklmnopqrstuvwxyz0123456789", b, len);
	    for (off = 1; off <= len; off++) {
		bcopy(b, b+off, len);
		bcopy(b+off, b, len);
		if (bcmp(b, "abcdefghijklmnopqrstuvwxyz0123456789", len))
		    exit(1);
	    }
	}
    }
    exit(0);
}
EOCP
	if $cc safebcpy.c -o safebcpy $ccflags $libs >/dev/null 2>&1 ; then
	    if ./safebcpy; then
		echo "It can."
		d_safebcpy=define
	    else
		echo "It can't."
	    fi
	else
	    echo "(I can't compile the test program, so we'll assume not...)"
	fi
	;;
    esac
    ;;
esac

: see if bzero exists
set bzero d_bzero
eval $inlibc

: see if sprintf is declared as int or pointer to char
echo " "
cat >ucbsprf.c <<'EOF'
#include <stdio.h>
main()
{
    int sprintf();
    char buf[10];
    exit((unsigned long)sprintf(buf,"%s","foo") > 10L);
}
EOF
if $cc $ccflags ucbsprf.c -o ucbsprf >/dev/null 2>&1 && ./ucbsprf; then
    echo "Your sprintf() returns (int)."
    val="$undef"
else
    echo "Your sprintf() returns (char*)."
    val="$define"
fi
set d_charsprf
eval $setvar

: see if vprintf exists
echo " "
if $contains '^vprintf$' libc.list >/dev/null 2>&1; then
    echo 'vprintf() found.'
    val="$define"
    cat >vprintf.c <<'EOF'
#include <varargs.h>

main() { xxx("foo"); }

xxx(va_alist)
va_dcl
{
    va_list args;
    char buf[10];

    va_start(args);
    exit((unsigned long)vsprintf(buf,"%s",args) > 10L);
}
EOF
    if $cc $ccflags vprintf.c -o vprintf >/dev/null 2>&1 && ./vprintf; then
	echo "Your vsprintf() returns (int)."
	val2="$undef"
    else
	echo "Your vsprintf() returns (char*)."
	val2="$define"
    fi
else
    echo 'vprintf() NOT found.'
    val="$undef"
    val2="$undef"
fi
set d_vprintf
eval $setvar
val=$val2
set d_charvspr
eval $setvar

: see if chsize exists
set chsize d_chsize
eval $inlibc

: see if crypt exists
echo " "
if $contains '^crypt$' libc.list >/dev/null 2>&1; then
    echo 'crypt() found.'
    val="$define"
    cryptlib=''
else
    cryptlib=`./loc Slibcrypt.a "" $xlibpth`
    if $test -z "$cryptlib"; then
	cryptlib=`./loc Mlibcrypt.a "" $xlibpth`
    else
	cryptlib=-lcrypt
    fi
    if $test -z "$cryptlib"; then
	cryptlib=`./loc Llibcrypt.a "" $xlibpth`
    else
	cryptlib=-lcrypt
    fi
    if $test -z "$cryptlib"; then
	cryptlib=`./loc libcrypt.a "" $libpth`
    else
	cryptlib=-lcrypt
    fi
    if $test -z "$cryptlib"; then
	echo 'crypt() NOT found.'
	val="$undef"
    else
	val="$define"
    fi
fi
set d_crypt
eval $setvar

: get csh whereabouts
case "$csh" in
'csh') val="$undef" ;;
*)     val="$define" ;;
esac
set d_csh
eval $setvar

: see if readdir exists
set readdir d_readdir
eval $inlibc

: see if there are directory access routines out there
echo " "
xxx=`./loc ndir.h x $usrinclude /usr/local/include $inclwanted`
case "$xxx" in
x)
    xxx=`./loc sys/ndir.h x $usrinclude /usr/local/include $inclwanted`
    ;;
esac
D_dirnamlen="$undef"
I_dirent="$undef"
I_sys_dir="$undef"
I_my_dir="$undef"
I_ndir="$undef"
I_sys_ndir="$undef"
libndir=''
ndirc=''
ndiro=''
if $test -r $usrinclude/dirent.h; then
    echo "dirent.h found."
    if $contains 'd_namlen' $usrinclude/dirent.h >/dev/null 2>&1; then
	D_dirnamlen="$define"
    fi
    I_dirent="$define"
elif $test -r $xxx; then
    echo "You seem to use <$xxx>,"
    if $test "$d_readdir" = "$define"; then
	echo "and I can get readdir() from your C library."
    elif $test -r /usr/lib/libndir.a || $test -r /usr/local/lib/libndir.a; then
	echo "and I'll get the routines using -lndir ."
	libndir='-lndir'
    else
	ans=`./loc libndir.a x $libpth`
	case "$ans" in
	x)
	    echo "but I can't find the ndir library!"
	    ;;
	*)
	    echo "and I found the directory library in $ans."
	    libndir="$ans"
	    ;;
	esac
    fi
    if $contains 'd_namlen' $xxx >/dev/null 2>&1; then
	D_dirnamlen="$define"
    fi
    case "$xxx" in
    sys/)
	I_sys_ndir="$define"
	;;
    *)
	I_ndir="$define"
	;;
    esac
else
    : The next line used to require this to be a bsd system.
    if $contains '^readdir$' libc.list >/dev/null 2>&1 ; then
	echo "No ndir library found, but you have readdir() so we'll use that."
	if $contains 'd_namlen' $usrinclude/sys/dir.h >/dev/null 2>&1; then
	    D_dirnamlen="$define"
	fi
	I_sys_dir="$define"
    else
	echo "No ndir library found--using ./$d_ndir.c."
: This will lose since $d_ndir.h is in another directory.
: I doubt we can rely on it being in ../$d_ndir.h . 
: At least it will fail in a conservative manner.
	if $contains 'd_namlen' $d_ndir.h >/dev/null 2>&1; then
	    D_dirnamlen="$define"
	fi
	I_my_dir="$define"
	ndirc="$d_ndir.c"
	ndiro="$d_ndir.o"
    fi
fi
val=$D_dirnamlen;	set d_dirnamlen;	eval $setvar
val=$I_dirent;		set i_dirent;		eval $setvar
val=$I_sys_dir;		set i_sys_dir;		eval $setvar
val=$I_my_dir;		set i_my_dir;		eval $setvar
val=$I_ndir;		set i_ndir;		eval $setvar
val=$I_sys_ndir;	set i_sys_ndir;		eval $setvar

: now see if they want to do setuid emulation
case "$d_dosuid" in
'') dflt=n;;
*undef*) dflt=n;;
*) dflt=y;;
esac
cat <<EOM
 
Some sites have disabled setuid #! scripts because of a bug in the kernel
that prevents them from being secure.  If you are on such a system, the
setuid/setgid bits on scripts are currently useless.  It is possible for
$package to detect those bits and emulate setuid/setgid in a secure fashion
until a better solution is devised for the kernel problem.

EOM
rp="Do you want to do setuid/setgid emulation? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
'') $ans="$dflt";;
esac
case "$ans" in
y*)  d_dosuid="$define";;
*) d_dosuid="$undef";;
esac

: see if dup2 exists
set dup2 d_dup2
eval $inlibc

: see if fchmod exists
set fchmod d_fchmod
eval $inlibc

: see if fchown exists
set fchown d_fchown
eval $inlibc

: see if this is an fcntl system
set fcntl d_fcntl
eval $inlibc

: see if we can have long filenames
echo " "
rm -f 123456789abcde
if (echo hi >123456789abcdef) 2>/dev/null; then
    : not version 8
    if test -f 123456789abcde; then
	echo 'You cannot have filenames longer than 14 characters.  Sigh.'
	val="$undef"
    else
	echo 'You can have filenames longer than 14 characters.'
	val="$define"
    fi
else
    : version 8 probably
    echo "You can't have filenames longer than 14 chars.  You can't even think about them!"
    val="$undef"
fi 
set d_flexfnam
eval $setvar

: see if flock exists
set flock d_flock
eval $inlibc

: see if getgroups exists
set getgroups d_getgrps
eval $inlibc

: see if gethostent exists
set gethostent d_gethent
eval $inlibc

: see if getpgrp exists
set getpgrp d_getpgrp
eval $inlibc

: see if getpgrp2 exists
set getpgrp2 d_getpgrp2
eval $inlibc

: see if getpriority exists
set getpriority d_getprior
eval $inlibc

: see if htonl exists
set htonl d_htonl
eval $inlibc

: index or strcpy
echo " "
case "$d_index" in
undef) dflt=y;;
define) dflt=n;;
*)  if $test -f /unix; then
	dflt=n
    else
	dflt=y
    fi
    ;;
esac
if $contains '^index$' libc.list >/dev/null 2>&1 ; then
    if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
	echo "Your system has both index() and strchr().  Shall I use"
	rp="index() rather than strchr()? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	    n*) d_index="$define" ;;
	    *)  d_index="$undef" ;;
	esac
    else
	d_index="$undef"
	echo "index() found."
    fi
else
    if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
	d_index="$define"
	echo "strchr() found."
    else
	echo "No index() or strchr() found!"
	d_index="$undef"
    fi
fi

: see if isascii exists
set isascii d_isascii
eval $inlibc

: see if killpg exists
set killpg d_killpg
eval $inlibc

: see if lstat exists
set lstat d_lstat
eval $inlibc

: see if memcmp exists
set memcmp d_memcmp
eval $inlibc

: see if memcpy exists
set memcpy d_memcpy
eval $inlibc

case "$d_safemcpy" in
'')
    : assume the worst
    d_safemcpy=undef
    case "$d_memcpy" in
    define)
	echo "Checking to see if your memcpy() can do overlapping copies..."
	$cat >safemcpy.c <<'EOCP'
main()
{
    char buf[128];
    register char *b;
    register int len;
    register int off;
    register int align;

    for (align = 7; align >= 0; align--) {
	for (len = 36; len; len--) {
	    b = buf+align;
	    memcpy(b,"abcdefghijklmnopqrstuvwxyz0123456789", len);
	    for (off = 1; off <= len; off++) {
		memcpy(b+off, b, len);
		memcpy(b, b+off, len);
		if (memcmp(b, "abcdefghijklmnopqrstuvwxyz0123456789", len))
		    exit(1);
	    }
	}
    }
    exit(0);
}
EOCP
	if $cc safemcpy.c -o safemcpy $ccflags $libs >/dev/null 2>&1 ; then
	    if ./safemcpy; then
		echo "It can."
		d_safemcpy=define
	    else
		echo "It can't."
	    fi
	else
	    echo "(I can't compile the test program, so we'll assume not...)"
	fi
	;;
    esac
    ;;
esac

: see if memmove exists
set memmove d_memmove
eval $inlibc

: see if memset exists
set memset d_memset
eval $inlibc

: see if mkdir exists
set mkdir d_mkdir
eval $inlibc

: see if msgctl exists
set msgctl d_msgctl
eval $inlibc

: see if msgget exists
set msgget d_msgget
eval $inlibc

: see if msgsnd exists
set msgsnd d_msgsnd
eval $inlibc

: see if msgrcv exists
set msgrcv d_msgrcv
eval $inlibc

: see how much of the 'msg*(2)' library is present.
h_msg=true
echo " "
case "$d_msgctl$d_msgget$d_msgsnd$d_msgrcv" in
*undef*) h_msg=false;;
esac
: we could also check for sys/ipc.h ...
if $h_msg && $test -r $usrinclude/sys/msg.h; then
    echo "You have the full msg*(2) library."
    val="$define"
else
    echo "You don't have the full msg*(2) library."
    val="$undef"
fi
set d_msg
eval $setvar

: determine which malloc to compile in
echo " "
case "$d_mymalloc" in
'')
    case "$usemymalloc" in
    '')
	if bsd || v7; then
	    dflt='y'
	else
	    dflt='n'
	fi
	;;
    n*) dflt=n;;
    *)  dflt=y;;
    esac
    ;;
define)  dflt="y"
    ;;
*)  dflt="n"
    ;;
esac
rp="Do you wish to attempt to use the malloc that comes with $package? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
'') ans=$dflt;;
esac
case "$ans" in
y*) mallocsrc='malloc.c'; mallocobj='malloc.o'
    libs=`echo $libs | sed 's/-lmalloc//'`
    val="$define"
    case "$mallocptrtype" in
    '')
	cat >usemymalloc.c <<'END'
#ifdef __STDC__
#include <stdlib.h>
#else
#include <malloc.h>
#endif
void *malloc();
END
	if $cc $ccflags -c usemymalloc.c >/dev/null 2>&1; then
	    mallocptrtype=void
	else
	    mallocptrtype=char
	fi
	;;
    esac
    echo " "
    echo "Your system wants malloc to return $mallocptrtype*, it would seem."
    ;;
*)  mallocsrc='';
    mallocobj='';
    mallocptrtype=void
    val="$undef"
    ;;
esac
set d_mymalloc
eval $setvar

: see if ndbm is available
echo " "
xxx=`./loc ndbm.h x $usrinclude /usr/local/include $inclwanted`
if test -f $xxx; then
    val="$define"
    echo "ndbm.h found."
else
    val="$undef"
    echo "ndbm.h NOT found."
fi
set d_ndbm
eval $setvar

: see if we have the old dbm
echo " "
xxx=`./loc dbm.h x $usrinclude /usr/local/include $inclwanted`
if test -f $xxx; then
    val="$define"
    echo "dbm.h found."
else
    val="$undef"
    echo "dbm.h NOT found."
fi
set d_odbm
eval $setvar

: see whether socket exists
echo " "
socketlib=''
if $contains socket libc.list >/dev/null 2>&1; then
    echo "Looks like you have Berkeley networking support."
    val="$define"
    : now check for advanced features
    if $contains setsockopt libc.list >/dev/null 2>&1; then
	val2="$undef"
    else
	echo "...but it uses the old 4.1c interface, rather than 4.2"
	val2="$define"
    fi
else
    : hpux, for one, puts all the socket stuff in socklib.o
    if $contains socklib libc.list >/dev/null 2>&1; then
	echo "Looks like you have Berkeley networking support."
	val="$define"
	: we will have to assume that it supports the 4.2 BSD interface
	val2="$undef"
    else
	echo "Hmmm...you don't have Berkeley networking in libc.a..."
	: look for an optional networking library
	if test -f /usr/lib/libnet.a; then
	    (ar t /usr/lib/libnet.a ||
		nm -g /usr/lib/libnet.a) 2>/dev/null >> libc.list
	    if $contains socket libc.list >/dev/null 2>&1; then
		echo "but the Wollongong group seems to have hacked it in."
		socketlib="-lnet -lnsl_s"
		val="$define"
		: now check for advanced features
		if $contains setsockopt libc.list >/dev/null 2>&1; then
		    val2="$undef"
		else
		    echo "...using the old 4.1c interface, rather than 4.2"
		    val2="$define"
		fi
	    else
		echo "or even in libnet.a, which is peculiar."
		val="$undef"
		val2="$undef"
	    fi
	else
	    echo "or anywhere else I see."
	    val="$undef"
	    val2="$undef"
	fi
    fi
fi
set d_socket
eval $setvar

if $contains socketpair libc.list >/dev/null 2>&1; then
    val="$define"
else
    val="$undef"
fi
set d_sockpair
eval $setvar
val=$val2
set d_oldsock
eval $setvar

: Locate the flags for 'open()'
echo " "
$cat >open3.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
main() {

	if(O_RDONLY);

#ifdef O_TRUNC
	exit(0);
#else
	exit(1);
#endif
}
EOCP
: check sys/file.h first to get FREAD on Sun
if $test -r $usrinclude/sys/file.h && \
   $cc $cppflags "-DI_SYS_FILE" open3.c -o open3 >/dev/null 2>&1 ; then
    h_sys_file=true;
    echo "sys/file.h defines the O_* constants..."
    if ./open3; then
	echo "and you have the 3 argument form of open()."
	val="$define"
    else
	echo "but not the 3 argument form of open().  Oh, well."
	val="$undef"
    fi
elif $test -r $usrinclude/fcntl.h && \
   $cc "-DI_FCNTL" open3.c -o open3 >/dev/null 2>&1 ; then
    h_fcntl=true;
    echo "fcntl.h defines the O_* constants..."
    if ./open3; then
	echo "and you have the 3 argument form of open()."
	val="$define"
    else
	echo "but not the 3 argument form of open().  Oh, well."
	val="$undef"
    fi
else
    val="$undef"
    echo "I can't find the O_* constant definitions!  You got problems."
fi
set d_open3
eval $setvar

: see if how pwd stuff is defined
echo " "
if $test -r $usrinclude/pwd.h ; then
    i_pwd="$define"
    echo "pwd.h found."
    $cppstdin $cppflags $cppminus <$usrinclude/pwd.h | \
	sed -n '/struct[ 	][ 	]*passwd/,/^};/p' >pwd.txt
    if $contains 'pw_quota' pwd.txt >/dev/null 2>&1; then
	d_pwquota="$define"
    else
	d_pwquota="$undef"
    fi
    if $contains 'pw_age' pwd.txt >/dev/null 2>&1; then
	d_pwage="$define"
    else
	d_pwage="$undef"
    fi
    if $contains 'pw_change' pwd.txt >/dev/null 2>&1; then
	d_pwchange="$define"
    else
	d_pwchange="$undef"
    fi
    if $contains 'pw_class' pwd.txt >/dev/null 2>&1; then
	d_pwclass="$define"
    else
	d_pwclass="$undef"
    fi
    if $contains 'pw_expire' pwd.txt >/dev/null 2>&1; then
	d_pwexpire="$define"
    else
	d_pwexpire="$undef"
    fi
    if $contains 'pw_comment' pwd.txt >/dev/null 2>&1; then
	d_pwcomment="$define"
    else
	d_pwcomment="$undef"
    fi
else
    i_pwd="$undef"
    d_pwquota="$undef"
    d_pwage="$undef"
    d_pwchange="$undef"
    d_pwclass="$undef"
    d_pwexpire="$undef"
    d_pwcomment="$undef"
    echo "No pwd.h found."
fi

: see if rename exists
set rename d_rename
eval $inlibc

: see if rewindir exists
set rewinddir d_rewindir
eval $inlibc

: see if rmdir exists
set rmdir d_rmdir
eval $inlibc

: see if seekdir exists
set seekdir d_seekdir
eval $inlibc

: see if select exists
set select d_select
eval $inlibc

: see if semctl exists
set semctl d_semctl
eval $inlibc

: see if semget exists
set semget d_semget
eval $inlibc

: see if semop exists
set semop d_semop
eval $inlibc

: see how much of the 'sem*(2)' library is present.
h_sem=true
echo " "
case "$d_semctl$d_semget$d_semop" in
*undef*) h_sem=false;;
esac
: we could also check for sys/ipc.h ...
if $h_sem && $test -r $usrinclude/sys/sem.h; then
    echo "You have the full sem*(2) library."
    val="$define"
else
    echo "You don't have the full sem*(2) library."
    val="$undef"
fi
set d_sem
eval $setvar

: see if setegid exists
set setegid d_setegid
eval $inlibc

: see if seteuid exists
set seteuid d_seteuid
eval $inlibc

: see if setpgrp exists
set setpgrp d_setpgrp
eval $inlibc

: see if setpgrp2 exists
set setpgrp2 d_setpgrp2
eval $inlibc

: see if setpriority exists
set setpriority d_setprior
eval $inlibc

: see if setregid exists
set setregid d_setregid
eval $inlibc
set setresgid d_setresgid
eval $inlibc

: see if setreuid exists
set setreuid d_setreuid
eval $inlibc
set setresuid d_setresuid
eval $inlibc

: see if setrgid exists
set setrgid d_setrgid
eval $inlibc

: see if setruid exists
set setruid d_setruid
eval $inlibc

: see if shmctl exists
set shmctl d_shmctl
eval $inlibc

: see if shmget exists
set shmget d_shmget
eval $inlibc

: see if shmat exists
set shmat d_shmat
eval $inlibc

d_voidshmat="$undef"
case "$d_shmat" in
define)
    $cppstdin $cppflags $cppminus < $usrinclude/sys/shm.h >voidshmat.txt 2>/dev/null
    if $contains "void.*shmat" voidshmat.txt >/dev/null 2>&1; then
	echo "and shmat returns (void*)"
	d_voidshmat="$define"
    else
	echo "and shmat returns (char*)"
    fi
    ;;
esac

: see if shmdt exists
set shmdt d_shmdt
eval $inlibc

: see how much of the 'shm*(2)' library is present.
h_shm=true
echo " "
case "$d_shmctl$d_shmget$d_shmat$d_shmdt" in
*undef*) h_shm=false;;
esac
: we could also check for sys/ipc.h ...
if $h_shm && $test -r $usrinclude/sys/shm.h; then
    echo "You have the full shm*(2) library."
    val="$define"
else
    echo "You don't have the full shm*(2) library."
    val="$undef"
fi
set d_shm
eval $setvar

: see if stat knows about block sizes
echo " "
if $contains 'st_blocks;' $usrinclude/sys/stat.h >/dev/null 2>&1 ; then
    if $contains 'st_blksize;' $usrinclude/sys/stat.h >/dev/null 2>&1 ; then
	echo "Your stat knows about block sizes."
	val="$define"
    else
	echo "Your stat doesn't know about block sizes."
	val="$undef"
    fi
else
    echo "Your stat doesn't know about block sizes."
    val="$undef"
fi
set d_statblks
eval $setvar

: see if stdio is really std
echo " "
if $contains 'char.*_ptr.*;' $usrinclude/stdio.h >/dev/null 2>&1 ; then
    if $contains '_cnt;' $usrinclude/stdio.h >/dev/null 2>&1 ; then
	echo "Your stdio is pretty std."
	val="$define"
    else
	echo "Your stdio isn't very std."
	val="$undef"
    fi
else
    echo "Your stdio isn't very std."
    val="$undef"
fi
set d_stdstdio
eval $setvar

: check for structure copying
echo " "
echo "Checking to see if your C compiler can copy structs..."
$cat >strctcpy.c <<'EOCP'
main()
{
	struct blurfl {
	    int dyick;
	} foo, bar;

	foo = bar;
}
EOCP
if $cc -c strctcpy.c >/dev/null 2>&1 ; then
    val="$define"
    echo "Yup, it can."
else
    val="$undef"
    echo "Nope, it can't."
fi
set d_strctcpy
eval $setvar

: see if strerror exists
set strerror d_strerror
eval $inlibc

: see if symlink exists
set symlink d_symlink
eval $inlibc

: see if syscall exists
set syscall d_syscall
eval $inlibc

: set if package uses struct tm
w_s_tm=1

: set if package uses struct timeval
case "$d_select" in
define) w_s_timevl=1 ;;
esac

: set if package uses localtime function
w_localtim=1

: see which of time.h, sys/time.h, and sys/select should be included.
idefs=''
cat <<'EOM'
  
Testing to see which of <time.h>, <sys/time.h>, and <sys/select.h>
should be included, because this application wants:

EOM
case "$w_s_itimer" in
1)
    echo "	struct itimerval"
    idefs="-DS_ITIMERVAL $idefs"
    ;;
esac
case "$w_s_timevl" in
1)
    echo "	struct timeval"
    idefs="-DS_TIMEVAL $idefs"
    ;;
esac
case "$w_s_tm" in
1)
    echo "	struct tm"
    idefs="-DS_TM $idefs"
    ;;
esac
case "$w_localtim" in
1)
    echo "	ctime(3) declarations"
    idefs="-DD_CTIME $idefs"
    ;;
esac
case "$idefs" in
'')
    echo "	(something I don't know about)"
    ;;
esac
echo " "
echo "I'm now running the test program..."
$cat >i_time.c <<'EOCP'
#include <sys/types.h>
#ifdef I_TIME
#include <time.h>
#endif
#ifdef I_SYS_TIME
#ifdef SYSTIMEKERNEL
#define KERNEL
#endif
#include <sys/time.h>
#endif
#ifdef I_SYS_SELECT
#include <sys/select.h>
#endif
main()
{
    struct tm foo;
    struct tm *tmp;
#ifdef S_TIMEVAL
    struct timeval bar;
#endif
#ifdef S_ITIMERVAL
    struct itimerval baz;
#endif

    if (foo.tm_sec == foo.tm_sec)
	exit(0);
#ifdef S_TIMEVAL
    if (bar.tv_sec == bar.tv_sec)
	exit(0);
#endif
#ifdef S_ITIMERVAL
    if (baz.it_interval == baz.it_interval)
	exit(0);
#endif
#ifdef S_TIMEVAL
    if (bar.tv_sec == bar.tv_sec)
	exit(0);
#endif
#ifdef D_CTIME
    /* this might not do anything for us... */
    tmp = localtime((time_t *)0);
#endif
    exit(1);
}
EOCP
flags=''
for i_sys_select in '' '-DI_SYS_SELECT'; do
    for d_systimekernel in '' '-DSYSTIMEKERNEL'; do
	for i_time in '' '-DI_TIME'; do
	    for i_systime in '-DI_SYS_TIME' ''; do
		case "$flags" in
		'') echo Trying $i_time $i_systime $d_systimekernel $i_sys_select
		    if $cc $ccflags $idefs \
			    $i_time $i_systime $d_systimekernel $i_sys_select \
			    i_time.c -o i_time >/dev/null 2>&1 ; then
			set X $i_time $i_systime $d_systimekernel $i_sys_select
			shift
			flags="$*"
			echo Succeeded with $flags
		    fi
		    ;;
		esac
	    done
	done
    done
done
case "$flags" in
*SYSTIMEKERNEL*) val="$define";;
*) val="$undef";;
esac
set d_systimekernel
eval $setvar
case "$flags" in
*I_TIME*) val="$define";;
*) val="$undef";;
esac
set i_time
eval $setvar
case "$flags" in
*I_SYS_SELECT*) val="$define";;
*) val="$undef";;
esac
set i_sys_select
eval $setvar
case "$flags" in
*I_SYS_TIME*) val="$define";;
*) val="$undef";;
esac
set i_sys_time
eval $setvar
case "$flags$i_sys_time$i_time" in
undefundef) i_sys_time="$define"; i_time="$define";
    echo "ICK, NOTHING WORKED!!!  You may have to diddle the includes.";;
esac

: see if telldir exists
set telldir d_telldir
eval $inlibc

: see if signal is declared as pointer to function returning int or void
echo " "
$cppstdin $cppflags $cppminus < $usrinclude/signal.h >d_voidsig.txt
if $contains 'int[^A-Za-z]*signal' d_voidsig.txt >/dev/null 2>&1 ; then
    echo "You have int (*signal())() instead of void."
    val="$undef"
else
    echo "You have void (*signal())() instead of int."
    val="$define"
fi
set d_voidsig
eval $setvar
case $voidsig in
define) d_tosignal=void;;
*) d_tosignal=int;;
esac

: see if truncate exists
set truncate d_truncate
eval $inlibc

: see if there is a vfork
set vfork d_vfork
eval $inlibc

: check for volatile keyword
echo " "
echo 'Checking to see if your C compiler knows about "volatile"...'
$cat >try.c <<'EOCP'
main()
{
	typedef unsigned short foo_t;
	char *volatile foo;
	volatile int bar;
	volatile foo_t blech;
	foo = foo;
}
EOCP
if $cc -c $ccflags try.c >/dev/null 2>&1 ; then
    val="$define"
    echo "Yup, it does."
else
    val="$undef"
    echo "Nope, it doesn't."
fi
set d_volatile
eval $setvar
$rm -f try.*

: see if there is a wait4
set wait4 d_wait4
eval $inlibc

: see if there is a waitpid
set waitpid d_waitpid
eval $inlibc

: see what type gids are declared as in the kernel
case "$gidtype" in
'')
    if $contains 'gid_t;' $usrinclude/sys/types.h >/dev/null 2>&1 ; then
	dflt='gid_t';
    else
	set `grep '_rgid;' $usrinclude/sys/user.h 2>/dev/null` unsigned short
	case $1 in
	unsigned) dflt="$1 $2" ;;
	*) dflt="$1" ;;
	esac
    fi
    ;;
*)  dflt="$gidtype"
    ;;
esac
cont=true
echo " "
rp="What type are groups ids returned by getgid(), etc.? [$dflt]"
$echo $n "$rp $c"
. myread
gidtype="$ans"

: see what type gids are returned by getgroups
echo " "
case "$groupstype" in
'')
    if $contains 'getgroups.*short' /usr/lib/lint/llib-lc >/dev/null 2>&1; then
	dflt='short'
    elif $contains 'getgroups.*int' /usr/lib/lint/llib-lc >/dev/null 2>&1; then
	dflt='int'
    elif $contains 'getgroups.*short' /usr/include/libc.h >/dev/null 2>&1; then
	dflt='short'
    elif $contains 'getgroups.*int' /usr/include/libc.h >/dev/null 2>&1; then
	dflt='int'
    elif $contains 'getgroups.*short' /usr/lib/lint/llib-lbsd >/dev/null 2>&1; then
	dflt='short'
    elif $contains 'getgroups.*int' /usr/lib/lint/llib-lbsd >/dev/null 2>&1; then
	dflt='int'
    elif $contains 'int.*gidset' /usr/man/man2/getgroups.2 >/dev/null 2>&1; then
	dflt='int'
    elif $contains 'gid_t;' $usrinclude/sys/types.h >/dev/null 2>&1 ; then
	dflt='gid_t'
    else
	set `grep 'groups\[NGROUPS\];' $usrinclude/sys/user.h 2>/dev/null` unsigned short
	case $1 in
	unsigned) dflt="$1 $2" ;;
	*) dflt="$1" ;;
	esac
    fi
    ;;
*)  dflt="$groupstype"
    ;;
esac
cont=true
echo "(The following only matters if you have getgroups().)"
rp="What type are the group ids returned by getgroups()? [$dflt]"
$echo $n "$rp $c"
. myread
groupstype="$ans"

: check for length of integer
echo " "
case "$intsize" in
'')
    echo "Checking to see how big your integers are..."
    $cat >intsize.c <<'EOCP'
#include <stdio.h>
main()
{
    printf("%d\n", sizeof(int));
}
EOCP
    if $cc intsize.c -o intsize >/dev/null 2>&1 ; then
	dflt=`./intsize`
    else
	dflt='4'
	echo "(I can't seem to compile the test program.  Guessing...)"
    fi
    ;;
*)
    dflt="$intsize"
    ;;
esac
rp="What is the size of an integer (in bytes)? [$dflt]"
$echo $n "$rp $c"
. myread
intsize="$ans"

: determine where private executables go
case "$privlib" in
'')
    dflt=/usr/lib/$package
    test -d /usr/local/lib && dflt=/usr/local/lib/$package
    ;;
*)  dflt="$privlib"
    ;;
esac
$cat <<EOM

The $package package has some auxiliary files that should be reside in a library
that is accessible by everyone.  Where should these "private" but accessible
EOM
$echo $n "files reside? (~name ok) [$dflt] $c"
rp="Private files will reside where? [$dflt]"
. myread
privlib=`./filexp "$ans"`

case "$installprivlib" in
'')
    dflt=`echo $privlib | sed 's#^/afs/#/afs/.#'`
    test -d $dflt || dflt="$privlib"
    ;;
*)  dflt="$installprivlib"
    ;;
esac
$cat <<EOM

On some systems (such as afs) you have to install the library files in a
different directory to get them to go to the right place.  Where should the
EOM
$echo $n "library files be installed? (~name ok) [$dflt] $c"
rp="Install private files where? [$dflt]"
. myread
installprivlib=`./filexp "$ans"`

: check for size of random number generator
echo " "
case "$randbits" in
'')
    echo "Checking to see how many bits your rand function produces..."
    $cat >randbits.c <<'EOCP'
#include <stdio.h>
main()
{
    register int i;
    register unsigned long tmp;
    register unsigned long max = 0L;

    for (i=1000; i; i--) {
	tmp = (unsigned long)rand();
	if (tmp > max) max = tmp;
    }
    for (i=0; max; i++)
	max /= 2;
    printf("%d\n",i);
}
EOCP
    if $cc randbits.c -o randbits >/dev/null 2>&1 ; then
	dflt=`./randbits`
    else
	dflt='?'
	echo "(I can't seem to compile the test program...)"
    fi
    ;;
*)
    dflt="$randbits"
    ;;
esac
rp="How many bits does your rand() function produce? [$dflt]"
$echo $n "$rp $c"
. myread
randbits="$ans"

: determine where publicly executable scripts go
case "$scriptdir" in
'')
    dflt="$bin"
    : guess some guesses
    test -d /usr/share/scripts && dflt=/usr/share/scripts
    test -d /usr/share/bin && dflt=/usr/share/bin
    ;;
*)  dflt="$scriptdir"
    ;;
esac
cont=true
$cat <<EOM
 
Some installations have a separate directory just for executable scripts so
that they can mount it across multiple architectures but keep the scripts in
one spot.  You might, for example, have a subdirectory of /usr/share for this.
Or you might just lump your scripts in with all your other executables.
 
EOM
while $test "$cont" ; do
    rp="Where will publicly executable scripts reside (~name ok)? [$dflt]"
    $echo $n "$rp $c"
    . myread
    scriptdir="$ans"
    scriptdir=`./filexp "$scriptdir"`
    if test -d $scriptdir; then
	cont=''
    else
	case "$fastread" in
	yes) dflt=y;;
	*) dflt=n;;
	esac
	rp="Directory $scriptdir doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

case "$installscr" in
'')
    dflt=`echo $scriptdir | sed 's#^/afs/#/afs/.#'`
    test -d $dflt || dflt="$scriptdir"
    ;;
*)  dflt="$scriptdir"
    ;;
esac
cont=true
$cat <<EOM
 
Some installations must install scripts in a different directory than where
they will eventually reside.  On most systems they're the same directory.
EOM
while $test "$cont" ; do
    rp="Where do you install publicly executable scripts (~name ok)? [$dflt]"
    $echo $n "$rp $c"
    . myread
    installscr="$ans"
    installscr=`./filexp "$installscr"`
    if test -d $installscr; then
	cont=''
    else
	case "$fastread" in
	yes) dflt=y;;
	*) dflt=n;;
	esac
	rp="Directory $installscr doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

: generate list of signal names
echo " "
case "$sig_name" in
'')
    echo "Generating a list of signal names..."
    set X `cat $usrinclude/signal.h $usrinclude/sys/signal.h 2>&1 | awk '
$1 ~ /^#define$/ && $2 ~ /^SIG[A-Z0-9]*$/ && $3 ~ /^[1-9][0-9]*$/ {
    sig[$3] = substr($2,4,20)
    if (max < $3 && $3 < 60) {
	max = $3
    }
}

END {
    for (i=1; i<=max; i++) {
	if (sig[i] == "")
	    printf "%d", i
	else
	    printf "%s", sig[i]
	if (i < max)
	    printf " "
    }
    printf "\n"
}
'`
    shift
    case $# in
    0)  echo 'kill -l' >/tmp/foo$$
	set X `$csh -f </tmp/foo$$`
	shift
	case $# in
	0)set HUP INT QUIT ILL TRAP IOT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM
	    ;;
	esac
	;;
    esac
    sig_name="ZERO $*"
    ;;
esac
echo "Signals are: $sig_name"

: see what type of char stdio uses.
echo " "
if $contains 'unsigned.*char.*\*.*_ptr.*;' $usrinclude/stdio.h >/dev/null 2>&1 ; then
    echo "Your stdio uses unsigned chars."
    stdchar="unsigned char"
else
    echo "Your stdio uses signed chars."
    stdchar="char"
fi

: see what type uids are declared as in the kernel
case "$uidtype" in
'')
    if $contains 'uid_t;' $usrinclude/sys/types.h >/dev/null 2>&1 ; then
	dflt='uid_t';
    else
	set `grep '_ruid;' $usrinclude/sys/user.h 2>/dev/null` unsigned short
	case $1 in
	unsigned) dflt="$1 $2" ;;
	*) dflt="$1" ;;
	esac
    fi
    ;;
*)  dflt="$uidtype"
    ;;
esac
cont=true
echo " "
rp="What type are user ids returned by getuid(), etc.? [$dflt]"
$echo $n "$rp $c"
. myread
uidtype="$ans"

: check for void type
echo " "
$cat <<EOM
Checking to see how well your C compiler groks the void type...

  Support flag bits are:
    1: basic void declarations.
    2: arrays of pointers to functions returning void.
    4: operations between pointers to and addresses of void functions.

EOM
case "$voidhave" in
'')
    $cat >void.c <<'EOCP'
#if TRY & 1
void main() {
#else
main() {
#endif
	extern void moo();	/* function returning void */
	void (*goo)();		/* ptr to func returning void */
#if TRY & 2
	void (*foo[10])();
#endif

#if TRY & 4
	if(goo == moo) {
		exit(0);
	}
#endif
	exit(0);
}
EOCP
    if $cc -c -DTRY=$voidwant void.c >void.out 2>&1 ; then
	voidhave=$voidwant
	echo "It appears to support void to the level $package wants ($voidwant)."
	if $contains warning void.out >/dev/null 2>&1; then
	    echo "However, you might get some warnings that look like this:"
	    $cat void.out
	fi
    else
	echo "Hmm, your compiler has some difficulty with void.  Checking further..."
	if $cc -c -DTRY=1 void.c >/dev/null 2>&1 ; then
	    echo "It supports 1..."
	    if $cc -c -DTRY=3 void.c >/dev/null 2>&1 ; then
		voidhave=3
		echo "And it supports 2 but not 4."
	    else
		echo "It doesn't support 2..."
		if $cc -c -DTRY=5 void.c >/dev/null 2>&1 ; then
		    voidhave=5
		    echo "But it supports 4."
		else
		    voidhave=1
		    echo "And it doesn't support 4."
		fi
	    fi
	else
	    echo "There is no support at all for void."
	    voidhave=0
	fi
    fi
esac
dflt="$voidhave";
rp="Your void support flags add up to what? [$dflt]"
$echo $n "$rp $c"
. myread
voidhave="$ans"

: preserve RCS keywords in files with variable substitution, grrr
Log='$Log'
Header='$Header'
Id='$Id'
Author='$Author'
Date='$Date'
Locker='$Locker'
RCSfile='$RCSfile'
Revision='$Revision'
Source='$Source'
State='$State'


: determine compiler compiler
case "$yacc" in
'') if xenix; then
	dflt=yacc
    else
	dflt='yacc -Sm25000'
    fi
    ;;
*)  dflt="$yacc";;
esac
cont=true
    echo " "
rp="Which compiler compiler (yacc or bison -y) will you use? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
'') ans="$dflt";;
esac
yacc="$ans"

: see if we can include fcntl.h
echo " "
if $h_fcntl; then
    val="$define"
    echo "We'll be including <fcntl.h>."
else
    val="$undef"
    if $h_sys_file; then
	echo "We don't need to <fcntl.h> if we include <sys/file.h>."
    else
	echo "We won't be including <fcntl.h>."
    fi
fi
set i_fcntl
eval $setvar

: see if gdbm is available
echo " "
xxx=`./loc gdbm.h x $usrinclude /usr/local/include $inclwanted`
if test -f $xxx; then
    val="$define"
    echo "gdbm.h found."
else
    val="$undef"
    echo "gdbm.h NOT found."
fi
set i_gdbm
eval $setvar

: see if this is an grp system
echo " "
if $test -r $usrinclude/grp.h ; then
    val="$define"
    echo "grp.h found."
else
    val="$undef"
    echo "No grp.h found."
fi
set i_grp
eval $setvar

: see if this is a netinet/in.h or sys/in.h system
echo " "
xxx=`./loc netinet/in.h x $usrinclude /usr/local/include $inclwanted`
if test -f $xxx; then
    val="$define"
    val2="$undef"
    echo "netinet/in.h found."
else
    val="$undef"
    echo "No netinet/in.h found, ..."
    xxx=`./loc sys/in.h x $usrinclude /usr/local/include $inclwanted`
    if test -f $xxx; then
	val2="$define"
	echo "but I found sys/in.h instead."
    else
	val2="$undef"
	echo "and I didn't find sys/in.h either."
    fi
fi
set i_niin
eval $setvar
val=$val2
set i_sysin
eval $setvar

: Do we need to #include <sys/file.h> ?
echo " "
if $h_sys_file; then
    val="$define"
    echo "We'll be including <sys/file.h>."
else
    val="$undef"
    echo "We won't be including <sys/file.h>."
fi
set i_sys_file
eval $setvar

: see if ioctl defs are in sgtty/termio or sys/ioctl
echo " "
if $test -r $usrinclude/sys/ioctl.h ; then
    val="$define"
    echo "sys/ioctl.h found."
else
    val="$undef"
    echo "sys/ioctl.h NOT found, assuming ioctl args are defined in sgtty.h."
fi
set i_sysioctl
eval $setvar

: see if we should include utime.h
echo " "
if $test -r $usrinclude/utime.h ; then
    val="$define"
    echo "utime.h found."
else
    val="$undef"
    echo "No utime.h found, but that's ok."
fi
set i_utime
eval $setvar

: see if this is a varargs system
echo " "
if $test -r $usrinclude/varargs.h ; then
    val="$define"
    echo "varargs.h found."
else
    val="$undef"
    echo "No varargs.h found, but that's ok (I hope)."
fi
set i_varargs
eval $setvar

: see if this is a vfork system
echo " "
if $test -r $usrinclude/vfork.h ; then
    val="$define"
    echo "vfork.h found."
else
    val="$undef"
    echo "No vfork.h found."
fi
set i_vfork
eval $setvar

: end of configuration questions
echo " "
echo "End of configuration questions."
echo " "

: create config.sh file
echo " "
if test -d ../UU; then
    cd ..
fi
echo "Creating config.sh..."
test -f config.sh && cp config.sh UU/oldconfig.sh
$spitshell <<EOT >config.sh
$startsh
# config.sh
# This file was produced by running the Configure script.
d_eunice='$d_eunice'
define='$define'
eunicefix='$eunicefix'
loclist='$loclist'
expr='$expr'
sed='$sed'
echo='$echo'
cat='$cat'
rm='$rm'
mv='$mv'
cp='$cp'
tail='$tail'
tr='$tr'
mkdir='$mkdir'
sort='$sort'
uniq='$uniq'
grep='$grep'
trylist='$trylist'
test='$test'
inews='$inews'
egrep='$egrep'
more='$more'
pg='$pg'
Mcc='$Mcc'
vi='$vi'
mailx='$mailx'
mail='$mail'
cpp='$cpp'
perl='$perl'
emacs='$emacs'
ls='$ls'
rmail='$rmail'
sendmail='$sendmail'
shar='$shar'
smail='$smail'
tbl='$tbl'
troff='$troff'
nroff='$nroff'
uname='$uname'
uuname='$uuname'
line='$line'
chgrp='$chgrp'
chmod='$chmod'
lint='$lint'
sleep='$sleep'
pr='$pr'
tar='$tar'
ln='$ln'
lpr='$lpr'
lp='$lp'
touch='$touch'
make='$make'
date='$date'
csh='$csh'
bash='$bash'
ksh='$ksh'
lex='$lex'
flex='$flex'
bison='$bison'
Log='$Log'
Header='$Header'
Id='$Id'
lastuname='$lastuname'
alignbytes='$alignbytes'
bin='$bin'
installbin='$installbin'
byteorder='$byteorder'
contains='$contains'
cppstdin='$cppstdin'
cppminus='$cppminus'
d_bcmp='$d_bcmp'
d_bcopy='$d_bcopy'
d_safebcpy='$d_safebcpy'
d_bzero='$d_bzero'
d_castneg='$d_castneg'
castflags='$castflags'
d_charsprf='$d_charsprf'
d_chsize='$d_chsize'
d_crypt='$d_crypt'
cryptlib='$cryptlib'
d_csh='$d_csh'
d_dosuid='$d_dosuid'
d_dup2='$d_dup2'
d_fchmod='$d_fchmod'
d_fchown='$d_fchown'
d_fcntl='$d_fcntl'
d_flexfnam='$d_flexfnam'
d_flock='$d_flock'
d_getgrps='$d_getgrps'
d_gethent='$d_gethent'
d_getpgrp='$d_getpgrp'
d_getpgrp2='$d_getpgrp2'
d_getprior='$d_getprior'
d_htonl='$d_htonl'
d_index='$d_index'
d_isascii='$d_isascii'
d_killpg='$d_killpg'
d_lstat='$d_lstat'
d_memcmp='$d_memcmp'
d_memcpy='$d_memcpy'
d_safemcpy='$d_safemcpy'
d_memmove='$d_memmove'
d_memset='$d_memset'
d_mkdir='$d_mkdir'
d_msg='$d_msg'
d_msgctl='$d_msgctl'
d_msgget='$d_msgget'
d_msgrcv='$d_msgrcv'
d_msgsnd='$d_msgsnd'
d_ndbm='$d_ndbm'
d_odbm='$d_odbm'
d_open3='$d_open3'
d_readdir='$d_readdir'
d_rename='$d_rename'
d_rewindir='$d_rewindir'
d_rmdir='$d_rmdir'
d_seekdir='$d_seekdir'
d_select='$d_select'
d_sem='$d_sem'
d_semctl='$d_semctl'
d_semget='$d_semget'
d_semop='$d_semop'
d_setegid='$d_setegid'
d_seteuid='$d_seteuid'
d_setpgrp='$d_setpgrp'
d_setpgrp2='$d_setpgrp2'
d_setprior='$d_setprior'
d_setregid='$d_setregid'
d_setresgid='$d_setresgid'
d_setreuid='$d_setreuid'
d_setresuid='$d_setresuid'
d_setrgid='$d_setrgid'
d_setruid='$d_setruid'
d_shm='$d_shm'
d_shmat='$d_shmat'
d_voidshmat='$d_voidshmat'
d_shmctl='$d_shmctl'
d_shmdt='$d_shmdt'
d_shmget='$d_shmget'
d_socket='$d_socket'
d_sockpair='$d_sockpair'
d_oldsock='$d_oldsock'
socketlib='$socketlib'
d_statblks='$d_statblks'
d_stdstdio='$d_stdstdio'
d_strctcpy='$d_strctcpy'
d_strerror='$d_strerror'
d_symlink='$d_symlink'
d_syscall='$d_syscall'
d_telldir='$d_telldir'
d_truncate='$d_truncate'
d_vfork='$d_vfork'
d_voidsig='$d_voidsig'
d_tosignal='$d_tosignal'
d_volatile='$d_volatile'
d_vprintf='$d_vprintf'
d_charvspr='$d_charvspr'
d_wait4='$d_wait4'
d_waitpid='$d_waitpid'
gidtype='$gidtype'
groupstype='$groupstype'
i_fcntl='$i_fcntl'
i_gdbm='$i_gdbm'
i_grp='$i_grp'
i_niin='$i_niin'
i_sysin='$i_sysin'
i_pwd='$i_pwd'
d_pwquota='$d_pwquota'
d_pwage='$d_pwage'
d_pwchange='$d_pwchange'
d_pwclass='$d_pwclass'
d_pwexpire='$d_pwexpire'
d_pwcomment='$d_pwcomment'
i_sys_file='$i_sys_file'
i_sysioctl='$i_sysioctl'
i_time='$i_time'
i_sys_time='$i_sys_time'
i_sys_select='$i_sys_select'
d_systimekernel='$d_systimekernel'
i_utime='$i_utime'
i_varargs='$i_varargs'
i_vfork='$i_vfork'
intsize='$intsize'
libc='$libc'
nm_opts='$nm_opts'
libndir='$libndir'
i_my_dir='$i_my_dir'
i_ndir='$i_ndir'
i_sys_ndir='$i_sys_ndir'
i_dirent='$i_dirent'
i_sys_dir='$i_sys_dir'
d_dirnamlen='$d_dirnamlen'
ndirc='$ndirc'
ndiro='$ndiro'
mallocsrc='$mallocsrc'
mallocobj='$mallocobj'
d_mymalloc='$d_mymalloc'
mallocptrtype='$mallocptrtype'
mansrc='$mansrc'
manext='$manext'
models='$models'
split='$split'
small='$small'
medium='$medium'
large='$large'
huge='$huge'
optimize='$optimize'
ccflags='$ccflags'
cppflags='$cppflags'
ldflags='$ldflags'
cc='$cc'
nativegcc='$nativegcc'
libs='$libs'
n='$n'
c='$c'
package='$package'
randbits='$randbits'
scriptdir='$scriptdir'
installscr='$installscr'
sig_name='$sig_name'
spitshell='$spitshell'
shsharp='$shsharp'
sharpbang='$sharpbang'
startsh='$startsh'
stdchar='$stdchar'
uidtype='$uidtype'
usrinclude='$usrinclude'
inclPath='$inclPath'
void='$void'
voidhave='$voidhave'
voidwant='$voidwant'
w_localtim='$w_localtim'
w_s_timevl='$w_s_timevl'
w_s_tm='$w_s_tm'
yacc='$yacc'
lib='$lib'
privlib='$privlib'
installprivlib='$installprivlib'
EOT

test -f patchlevel.h && awk '{printf "%s=%s\n",$2,$3}' patchlevel.h >>config.sh
echo "CONFIG=true" >>config.sh

if test -f UU/oldconfig.sh; then
    sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' config.sh config.sh UU/oldconfig.sh |\
      sort | uniq -u >UU/oldsyms
    set X `cat UU/oldsyms`
    shift
    case $# in
    0) ;;
    *)  echo "Hmm...You had some extra variables I don't know about...I'll try to keep 'em..."
	for sym in `cat UU/oldsyms`; do
	    echo "    Propagating $hint variable "'$'"$sym..."
	    eval 'tmp="$'"${sym}"'"'
	    echo "$tmp" | \
	      sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
	done
	;;
    esac
fi

: Finish up
CONFIG=true

echo " "
dflt=''
fastread=''
echo "If you didn't make any mistakes, then just type a carriage return here."
rp="If you need to edit config.sh, do it as a shell escape here:"
$echo $n "$rp $c"
. UU/myread
case "$ans" in
'') ;;
*) : in case they cannot read
    eval $ans;;
esac
chmod +x doSH
./doSH

if $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
    dflt=n
    $cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
    rp="Run make depend now? [$dflt]"
    $echo $n "$rp $c"
    . UU/myread
    case "$ans" in
    y*) make depend && echo "Now you must run a make."
	;;
    *)  echo "You must run 'make depend' then 'make'."
	;;
    esac
elif test -f [Mm]akefile; then
    echo " "
    echo "Now you must run a make."
else
    echo "Done."
fi

$rm -f kit*isdone
$rm -rf UU
: end of Configure
