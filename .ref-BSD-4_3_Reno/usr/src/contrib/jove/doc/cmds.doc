Alphabetical List of Commands and Variables

:entry "abort-char" "Variable"
This variable defines JOVE'S abort characer.  When the abort character
is  typed,  the current JOVE command is aborted.  The default value is
C-G.

:entry "add-lisp-special" "Command"
This command is to tell JOVE what identifiers require special indenta-
tion  in  lisp mode.  Lisp functions like defun and let are two of the
default functions that get treated specially.  This is just  a  kludge
to define some of your own.  It prompts for the function name.

:entry "allow-^S-and-^Q" "Variable"
This variable, when set, tells JOVE that your terminal does  not  need
to  use  the  characters  C-S and C-Q for flow control, and that it is
okay to bind things to them.  This variable should  be  set  depending
upon what kind of terminal you have.

:entry "allow-bad-filenames" "Variable"
If set, this variable permits filenames to  contain  "bad"  characters
such as those from the set *&%!"`[]{}.  These files are harder to deal
with, because the characters mean something to the shell.  The default
value is "off".

:entry "append-region" "Command"
This appends the region to a specified file.  If the file does not al-
ready exist it is created.

:entry "apropos" "Command"
This types out all the commands, variables and macros with the specif-
ic  keyword  in their names.  For each command and macro that contains
the string, the key sequence that can be used to execute  the  command
or  macro  is  printed;  with variables, the current value is printed.
So, to find all the commands that are related to windows, you type

     ESC X apropos window<Return>


:entry "auto-case-abbrev" "Variable"
When this variable is on (the default), word abbreviations are adjust-
ed  for case automatically.  For example, if "jove" were the abbrevia-
tion for "jonathan's own version of emacs", then typing  "jove"  would
give  you  "jonathan's own version of emacs", typing "Jove" would give
you "Jonathan's own version of emacs", and typing  "JOVE"  would  give
you  "Jonathan's  Own Version of Emacs".  When this variable is "off",
upper and lower case are distinguished when looking for the  abbrevia-
tion,  i.e.,  in the example above, "JOVE" and "Jove" would not be ex-
panded unless they were defined separately.

:entry "auto-execute-command" "Command"
This tells JOVE to execute a command automatically when a  file  whose
name  matches  a  specified pattern is visited.  The first argument is
the command you want executed and the second is a  regular  expression
pattern that specifies the files that apply.  For example, if you want
to be in show-match-mode when you edit C source files (that is,  files
that end with ".c" or ".h") you can type

     ESC X auto-execute-command show-match-mode .*.[ch]$


:entry "auto-execute-macro" "Command"
This is like "auto-execute-command" except you use it to execute  mac-
ros automatically instead of built-in commands.

:entry "auto-fill-mode" "Command"
This turns on Auto Fill mode (or off if  it's  currently  on)  in  the
selected  buffer.   When  JOVE  is  in Auto Fill mode it automatically
breaks lines for you when you reach the right margin so you don't have
to  remember  to hit Return.  JOVE uses 78 as the right margin but you
can change that by setting  the  variable  "right-margin"  to  another
value.  See the "set" command to learn how to do this.

:entry "auto-indent-mode" "Command"
This turns on Auto Indent mode (or off if it's currently  on)  in  the
selected buffer.  When JOVE is in Auto Indent mode, Return indents the
new line to the same position as the line you were just on.   This  is
useful  for  lining up C code (or any other language (but what else is
there besides C?)).  This is out of date because of  the  new  command
called  "newline-and-indent"  but  it  remains because of several "re-
quests" on the part of, uh, enthusiastic and excitable users, that  it
be left as it is.

:entry "background-color" "Variable"
This specifies the background color of the screen (PC  version  only).
The default value is 0, which stands for black.

:entry "backward-character" "Command"
This moves point backward over a single character.  If point is at the
beginning of the line it moves to the end of the previous line.

:entry "backward-list" "Command"
This moves backward over a list as opposed to  an  s-expression.   The
difference between this and "backward-s-expression" is that this first
searchs for a ")" and then moves to the matching "(".  This is  useful
when you're trying to find unmatched parens in a program.

:entry "backward-paragraph" "Command"
This moves point backward to the beginning of the current or  previous
paragraph.   Paragraphs  are bounded by lines that begin with a Period
or Tab, or by blank lines; a change in indentation may also  signal  a
break  between paragraphs, except that JOVE allows the first line of a
paragraph to be indented differently from the other lines.

:entry "backward-s-expression" "Command"
This moves point backward  over  a  s-expression.   It  is  just  like
"forward-s-expression" with a negative argument.

:entry "backward-sentence" "Command"
This moves point backward to the beginning of the current or  previous
sentence.   JOVE  considers the end of a sentence to be the characters
".", "!" or "?" followed by a Return or by one or more spaces.

:entry "backward-up-list" "Command"
This is similar to "backward-s-expression" except it backs up and  OUT
of  the  enclosing s-expression.  In other words, it moves backward to
the "(" that would match a ")" if you were to type it right then.

:entry "backward-word" "Command"
This moves point backward to the beginning of the current or  previous
word.

:entry "bad-filename-extensions" "Variable"
This contains a list of words separated by spaces which are to be con-
sidered  bad  filename  extensions,  and  so  will  not  be counted in
filename completion.  The default is ".o" so if you  have  jove.c  and
jove.o  in  the  same directory, the filename completion will not com-
plain of an ambiguity because it will ignore jove.o.

:entry "begin-kbd-macro" "Command"
This starts defining the keyboard macro by remembering  all  your  key
strokes until you execute "end-kbd-macro," by typing "C-X )".  Because
of a bug in JOVE you shouldn't terminate the macro by  typing  "ESC  X
end-kbd-macro";  "end-kbd-macro"  must be bound to "C-X )" in order to
make things work correctly.  To execute the remembered key strokes you
type  "C-X  E"  which runs the "execute-kbd-macro" command.  Sometimes
you may want a macro to accept different input each time it runs.   To
see how to do this, see the "make-macro-interactive" command.

:entry "beginning-of-file" "Command"
This moves point backward to the beginning of the buffer.  This  some-
times  prints  the  "Point  Pushed" message.  If the top of the buffer
isn't on the screen JOVE will set the mark so you can go back to where
you were if you want.

:entry "beginning-of-line" "Command"
This moves point to the beginning of the current line.

:entry "beginning-of-window" "Command"
This moves point to the beginning of the current window.  The sequence
"ESC  ," is the same as "ESC <" (beginning of file) except without the
shift key on the "<", and can thus can easily be remembered.

:entry "bind-keymap-to-key" "Command"
This is the way to build  nested  keymaps.   For  example,  when  JOVE
starts up, internally it does a

     bind-keymap-to-key ESC-map ^[

To make the arrow keys on vt100's work, you would do the following.

     make-keymap vt100-map
     bind-keymap-to-key vt100-map ^[[
     bind-to-key next-line ^[[A
     bind-to-key previous-line ^[[B
     bind-to-key forward-character ^[[C
     bind-to-key backward-character ^[[D

I may have gotten the escape sequences wrong, but you get the  general
idea.   Theoretically  you  can  use these keymaps to bind arbitrarily
long key sequences, like those generated by  the  SUN  keyboards,  but
that  is  a bit of a pain because you will have to generate a bunch of
keymaps by hand, almost one per key, because of the way  the  key  se-
quences are organized.  Eventually there will be a more general way to
have these keymaps built for you.

:entry "bind-macro-to-key" "Command"
This is like "bind-to-key" except you use it to attach keys  to  named
macros.

:entry "bind-macro-to-word-abbrev" "Command"
This command allows you to bind a macro to a previously  defined  word
abbreviation.   Whenever  you  type the abbreviation, it will first be
expanded as an abbreviation, and then  the  macro  will  be  executed.
Note  that  if  the  macro moves around, you should set the mark first
(C-@) and then exchange the point and mark last (C-X C-X).

:entry "bind-to-key" "Command"
This attaches a key to an internal JOVE command so that future hits on
that  key  invoke  that command.  For example, to make "C-W" erase the
previous word, you type "ESC X bind-to-key kill-previous-word C-W".

:entry "buffer-position" "Command"
This displays the current file name, current line number, total number
of  lines, percentage of the way through the file, and the position of
the cursor in the current line.

:entry "c-argument-indentation" "Variable"
This variable describes how to indent lines which are part  of  nested
expressions  in C.  The default is -1, which means to indent a contin-
ued line by lining it up with the first argument of  the  current  ex-
pression.   Otherwise,  the  line  will  be  indented  by  c-argument-
indentation characters past the indent of the first line  of  the  ex-
pression.  For example, the default value produces:
                Typeout(fmt, itoa(bcount++), line_cnt(b, nbuf),
                        TypeNames[b->b_type],
                        IsModified(b) ? "*" : b->b_ntbf ? "+" : NullStr,
                        buf_width, b->b_name, filename(b));

:entry "c-indentation-increment" "Variable"
This defines a set of tabstops independent of the value  of  internal-
tabstops  and  physical-tabstops.   This value will be used in C mode,
and JOVE will insert the correct number of spaces and Tabs to get  the
right  behavior.   For  programmers that like to indent with 4 spaces,
set this value to 4.  Don't set internal-tabstops to  4  because  that
will  not  work anymore.  Setting internal-tabstops to 4 tells JOVE to
display Tabs as every 4 spaces.  This will cause your programs to look
terrible  with  anyone else who displays the file with normal tabstops
at every 8 characters.  Not to mention  printing  your  program  won't
look right.  But all that aside, if you set c-indentation-increment to
8 (the default), and then set internal-tabstops to  4  as  well,  JOVE
will insert TWO Tabs to get the indentation to 8, which is clearly not
what you want.

:entry "c-mode" "Command"
This turns on C mode in the currently selected buffer.  This is one of
currently  four  possible  major  modes:   Fundamental, Text, C, Lisp.
When in C or Lisp mode, Tab, "}", and ")" behave a little  differently
from  usual:  They  are  indented to the "right" place for C (or Lisp)
programs.  In JOVE, the "right" place is simply  the  way  the  author
likes it (but I've got good taste).

:entry "case-character-capitalize" "Command"
This capitalizes the character after point, i.e., the character  under
the  cursor.   If a negative argument is supplied that many characters
"before" point are upper cased.

:entry "case-ignore-search" "Variable"
This variable, when set, tells JOVE to treat upper and lower  case  as
the  same  when  searching.   Thus  "jove" and "JOVE" would match, and
"JoVe" would match either.  The default  value  of  this  variable  is
"off".

:entry "case-region-lower" "Command"
This changes all the upper case letters in the region to  their  lower
case equivalent.

:entry "case-region-upper" "Command"
This changes all the lower case letters in the region to  their  upper
case equivalent.

:entry "case-word-capitalize" "Command"
This capitalizes the current word by making the current  letter  upper
case  and  making  the rest of the word lower case.  Point is moved to
the end of the word.  If point is not positioned on a word it is first
moved  forward to the beginning of the next word.  If a negative argu-
ment is supplied that many words "before" point are capitalized.  This
is  useful  for  correcting the word just typed without having to move
point to the beginning of the word yourself.

:entry "case-word-lower" "Command"
This lower-cases the current word and leaves point at the end  of  it.
If point is in the middle of a word the rest of the word is converted.
If point is not in a word it is first moved forward to  the  beginning
of  the next word.  If a negative argument is supplied that many words
"before" point are converted  to  lower  case.   This  is  useful  for
correcting the word just typed without having to move point to the be-
ginning of the word yourself.

:entry "case-word-upper" "Command"
This upper-cases the current word and leaves point at the end  of  it.
If point is in the middle of a word the rest of the word is converted.
If point is not in a word it is first moved forward to  the  beginning
of  the next word.  If a negative argument is supplied that many words
"before" point are converted  to  upper  case.   This  is  useful  for
correcting the word just typed without having to move point to the be-
ginning of the word yourself.

:entry "cd" "Command"
This changes the current directory.

:entry "character-to-octal-insert" "Command"
This inserts a Back-slash followed by the  ascii  value  of  the  next
character typed.  For example, "C-G" inserts the string "\007".

:entry "clear-and-redraw" "Command"
This clears the entire screen and redraws all the windows.   Use  this
when JOVE gets confused about what's on the screen, or when the screen
gets filled with garbage characters or output from another program.

:entry "comment-format" "Variable"
This variable tells JOVE how to format your comments when you run  the
command "fill-comment." Its format is this:

     <open pattern>%!<line header>%c<line trailer>%!<close pattern>

The %!, %c, and %! must appear in the format; everything else  is  op-
tional.  A newline (represented by %n) may appear in the open or close
patterns.  %% is the representation for %.  The default comment format
is for C comments.  See "fill-comment" for more.

:entry "compile-it" "Command"
This compiles your program by running the UNIX command "make"  into  a
buffer,  and automatically parsing the error messages that are created
(if any).  See the "parse-errors" command.  To  compile  a  C  program
without  "make",  use "C-U C-X C-E" and JOVE will prompt for a command
to run instead of make.  (And then the command you  type  will  become
the default command.)  You can use this to parse the output from the C
compiler or the "grep" or "lint" programs.   See  also  "error-format-
string" to make it possible to parse errors of a different format.

:entry "continue-process" "Command"
This sends SIGCONT to the current interactive process, "if"  the  pro-
cess is currently stopped.

:entry "copy-region" "Command"
This takes all the text in the region and copies it onto the kill ring
buffer.   This  is  just  like  running  "kill-region" followed by the
"yank" command.  See the "kill-region" and "yank" commands.

:entry "current-error" "Command"
This moves to the current error in the list of parsed errors.  See the
"next-error"  and "previous-error" commands for more detailed informa-
tion.

:entry "date" "Command"
This prints the date on the message line.

:entry "dbx-format-string" "Variable"
This is the default regular-expression search string used by  JOVE  to
parse  output from dbx running in a shell process.  The default format
string works when you type "where" or while you're stepping through  a
program, or when you reach a breakpoint.  You shouldn't have to change
this unless you are using gdb or some other symbolic debugger.

:entry "define-global-word-abbrev" "Command"
This defines a global abbreviation.

:entry "define-macro" "Command"
This provides a different mechanism for defining keyboard macros.  In-
stead  of  gathering  keystrokes  and storing them into the "keyboard-
macro" (which is how "start-kbd-macro" works), "define-macro"  prompts
for  a macro name (terminated with Space, or Newline) and then for the
actual macro body.  If you wish to specify control characters  in  the
macro,  you may simply insert them (using the "quoted-insert" command)
or by inserting the character '^' followed by the  appropriate  letter
for  that character (e.g., ^A would be the two characters '^' followed
by 'A').  You may use Back-slash to prevent the '^' from being  inter-
preted  as  part of a control character when you really wish to insert
one (e.g., a macro body "\^foo" would insert the  string  "^foo"  into
the buffer, whereas the body "^foo" would be the same as typing ^F and
then inserting the string "oo").  See  "write-macros-to-file"  to  see
how to save macros.

:entry "define-mode-word-abbrev" "Command"
This defines a mode-specific abbreviation.

:entry "delete-blank-lines" "Command"
This deletes all the blank lines around point.  This  is  useful  when
you previously opened many lines with "C-O" and now wish to delete the
unused ones.

:entry "delete-buffer" "Command"
This deletes a buffer and frees up all the memory associated with  it.
Be  careful(!)  -  once  a buffer has been deleted it is gone forever.
JOVE will ask you to confirm if you try to delete a buffer that  needs
saving.   This  command  is  useful for when JOVE runs out of space to
store new buffers.

:entry "delete-current-window" "Command"
This deletes the current window  and  moves  point  into  one  of  the
remaining  ones.   It  is an error to try to delete the only remaining
window.

:entry "delete-macro" "Command"
This deletes a macro from the list of named macros.  It is an error to
delete  the keyboard-macro.  Once the macro is deleted it is gone for-
ever.  If you are about to save macros to a file and decide you  don't
want to save a particular one, delete it.

:entry "delete-next-character" "Command"
This deletes the character that's just after point (that is, the char-
acter  under  the cursor).  If point is at the end of a line, the line
separator is deleted and the next line is joined with the current one.

:entry "delete-other-windows" "Command"
This deletes all the other windows except the current one.   This  can
be thought of as going back into One Window mode.

:entry "delete-previous-character" "Command"
This deletes the character that's just  before  point  (that  is,  the
character  before  the  cursor).   If point is at the beginning of the
line, the line separator is deleted and that line is joined  with  the
previous one.

:entry "delete-white-space" "Command"
This deletes all the Tabs and Spaces around point.

:entry "describe-bindings" "Command"
This types out a list containing each bound key and the  command  that
gets  invoked  every  time that key is typed.  To make a wall chart of
JOVE commands, set "send-typeout-to-buffer"  to  "on"  and  JOVE  will
store  the  key  bindings in a buffer which you can save to a file and
then print.

:entry "describe-command" "Command"
This prints some info on a specified command.

:entry "describe-key" "Command"
This waits for you to type a key and then tells the name of  the  com-
mand  that gets invoked every time that key is hit.  Once you have the
name of the command you can use the "describe-command" command to find
out exactly what it does.

:entry "describe-variable" "Command"
This prints some info on a specified variable.

:entry "digit" "Command"
This reads a numeric argument.  When you  type  "ESC"  followed  by  a
number,  "digit"  keeps reading numbers until you type some other com-
mand.  Then that command is executes with  the  numeric  argument  you
specified.

:entry "digit-1" "Command"
This pretends you typed "ESC 1".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-2" "Command"
This pretends you typed "ESC 2".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-3" "Command"
This pretends you typed "ESC 3".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-4" "Command"
This pretends you typed "ESC 4".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-5" "Command"
This pretends you typed "ESC 5".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-6" "Command"
This pretends you typed "ESC 6".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-7" "Command"
This pretends you typed "ESC 7".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-8" "Command"
This pretends you typed "ESC 8".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-9" "Command"
This pretends you typed "ESC 9".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-0" "Command"
This pretends you typed "ESC 0".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "dirs" "Command"
This prints out the directory stack.  See the  "cd",  "pushd",  "popd"
commands for more info.

:entry "disable-biff" "Variable"
When this is set, JOVE disables biff when you're editing  and  enables
it  again  when  you  get out of JOVE, or when you pause to the parent
shell or push to a new shell. (This means arrival of new mail will not
be  immediately  apparent but will not cause indiscriminate writing on
the display). The default is "off".

:entry "display-bad-filenames" "Variable"
This variable affects only filename completion,  in  particular,  what
happens when "?" is typed while prompting for a file.  When this vari-
able is ON, any files that end with one of the extensions  defined  by
the  variable  "bad-filename-extensions" will be displayed with an "!"
in front of their names.   When  "display-bad-filenames"  is  OFF  the
files will not be displayed at all.  The default value is on.

:entry "down-list" "Command"
This is the opposite of "backward-up-list." It's not clear to me  that
this  command  serves any useful purpose in life.  Try it out, and let
me know what you think.

:entry "dstop-process" "Command"
Send the "dsusp" character to the current process.  This is the  char-
acter  that  suspends  a  process  on the next read from the terminal.
Most people have it set to C-Y.  This only works if you have  the  in-
teractive  process feature, and if you are in a buffer bound to a pro-
cess.

:entry "edit-word-abbrevs" "Command"
This creates a buffer with a list of each abbreviation and the  phrase
it expands into, and enters a recursive edit to let you change the ab-
breviations  or  add  some  more.   The  format  of   this   list   is
"abbreviation:phrase"  so  if you add some more you should follow that
format.  It's probably simplest just to copy some already existing ab-
breviations  and  edit  them.  When you are done you type "C-X C-C" to
exit the recursive edit.

:entry "end-kbd-macro" "Command"
This stops the definition of the keyboard macro.  Because of a bug  in
JOVE, this must be bound to "C-X )", or some key sequence which is one
or two characters long.  Anything else will not work properly.

:entry "end-of-file" "Command"
This moves point forward to the end of  the  buffer.   This  sometimes
prints  the "Point Pushed" message.  If the end of the buffer isn't on
the screen JOVE will set the mark so you can go back to where you were
if you want.

:entry "end-of-line" "Command"
This moves point to the end of the current line.  If the line  is  too
long  to  fit  on  the screen JOVE will scroll the line to the left to
make the end of the line visible.  The line will  slide  back  to  its
normal position when you move backward past the leftmost visible char-
acter or when you move off the line altogether.

:entry "end-of-window" "Command"
This moves point to the last character in the window.

:entry "eof-process" "Command"
Sends EOF to the current interactive process.  This only works on ver-
sions of JOVE running under versions of UNIX with pty's.

:entry "erase-buffer" "Command"
This erases the contents  of  the  specified  buffer.   This  is  like
"delete-buffer"  except it only erases the contents of the buffer, not
the buffer itself.  If you try to erase a buffer that needs saving you
will be asked to confirm it.

:entry "error-format-string" "Variable"
This is the error format string that is used by "parse-errors" to find
the  error  messages  in  a buffer.  The way it works is by using this
string as a JOVE regular expression search string, where the \('s  and
\)'s  regular  expression operators are used to pick out the file name
and line number from the line containing an error  message.   For  in-
stance, a typical error message might look like this:

        "file.c", line 540: missing semi-colon

For strings of this format, an appropriate  value  for  "error-format-
string" would be something like this:

        ^"\([^"]*\)", line \([0-9]*\):

What this means is, to find an error message, search for a line begin-
ning with a double-quote.  Then it says that all the following charac-
ters up to another double-quote should  be  remembered  as  one  unit,
namely  the filename that the error is in (that's why the first set of
parens are surrounding it).  Then it  says  that  after  the  filename
there  will  be  the string ", line " followed by a line number, which
should be remembered as a single unit (which is why the second set  of
parens is around that).  The only constraints on the error messages is
that the file name and line number appear on the same line,  and  that
the  file name appears before the line number.  Most compilers seem to
do this anyway, so this is not an unreasonable restriction.

If you do not know how to use regular expressions then  this  variable
will  be  hard for you to use.  Also note that you can look at the de-
fault value of this variable by printing it out, but it  is  a  really
complicated  string because it is trying to accommodate the outputs of
more than one compiler at a time.

:entry "error-window-size" "Variable"
This is the percentage of the screen to use for  the  error-window  on
the  screen.   When you execute "compile-it," "error-window-size" per-
cent of the screen will go to the error window.  If the window already
exists  and  is a different size, it is made to be this size.  The de-
fault value is 20%.

:entry "exchange-point-and-mark" "Command"
This moves point to mark and makes mark the old point.   This  is  for
quickly moving from one end of the region to another.

:entry "execute-kbd-macro" "Command"
This executes the keyboard macro.  If you supply  a  numeric  argument
the macro is executed that many times.

:entry "execute-macro" "Command"
This executes a specified macro.  If you supply a numeric argument the
macro is executed that many times.

:entry "execute-named-command" "Command"
This is the way to execute a command that  isn't  bound  to  any  key.
When  you are prompted with ": " you can type the name of the command.
You don't have to type the entire name.  Once the command is unambigu-
ous you can type Space and JOVE will fill in the rest for you.  If you
are not sure of the name of the command, type "?" and JOVE will  print
a  list  of  all the commands that you could possibly match given what
you've already typed.  If you don't have any idea what  the  command's
name  is  but  you know it has something to do with windows (for exam-
ple), you can do "ESC X apropos window" and JOVE will print a list  of
all  the  commands  that are related to windows.  If you find yourself
constantly executing the same commands this way you probably  want  to
bind  them to keys so that you can execute them more quickly.  See the
"bind-to-key" command.

:entry "exit-jove" "Command"
This exits JOVE.  If any buffers need saving JOVE will print a warning
message  and  ask  for confirmation.  If you leave without saving your
buffers all your work will be lost.  If you made a mistake and  really
do want to exit then you can.  If you are in a recursive editing level
"exit-jove" will return you from that.

:entry "expand-environment-variables" "Command"
When this variable is on JOVE will try to expand any  strings  of  the
form  "$var"  into the value of the environment variable "var" when in
the minibuffer.  For example, if you type $HOME/.joverc, "$HOME"  will
be replaced with you home directory.  The default value is off.

:entry "file-creation-mode" "Variable"
This  variable  has  an  octal  value.   It  contains  the  mode  (see
"chmod(1)" ) with which files should be created.  This mode gets modi-
fied by your current umask setting (see  "umask(1)"  ).   The  default
value is usually "0666" or "0644."

:entry "files-should-end-with-newline" "Variable"
This variable indicates that all files should always have a newline at
the  end.   This  is  often  necessary for line printers and the like.
When set, if JOVE is writing a file whose last character is not a new-
line, it will add one automatically.

:entry "fill-comment" "Command"
This command fills in your C comments to make them  pretty  and  read-
able.  This filling is done according the variable "comment-format."

     /*
      * the default format makes comments like this.
      */

This can be changed by changing the format variable.  Other  languages
may  be  supported by changing the format variable appropriately.  The
formatter looks backwards from dot for an  open  comment  symbol.   If
found,  all  indentation  is  done  relative the position of the first
character of the open symbol.  If there is a  matching  close  symbol,
the  entire  comment is formatted.  If not, the region between dot and
the open symbol is reformatted.

:entry "fill-paragraph" "Command"
This rearranges words between lines so  that  all  the  lines  in  the
current paragraph extend as close to the right margin as possible, en-
suring that none of the lines will be greater than the  right  margin.
The  default  value  for "right-margin" is 78, but can be changed with
the "set" and "right-margin-here" commands.  JOVE  has  a  complicated
algorithm  for determining the beginning and end of the paragraph.  In
the normal case JOVE will give all the lines the same indent  as  they
currently have, but if you wish to force a new indent you can supply a
numeric argument to "fill-paragraph" (e.g., by typing C-U ESC  J)  and
JOVE  will  indent  each  line  to  the column specified by the "left-
margin" variable.  See also  the  "left-margin"  variable  and  "left-
margin-here" command.

:entry "fill-region" "Command"
This is like "fill-paragraph," except it operates on a region  instead
of just a paragraph.

:entry "filter-region" "Command"
This sends the text in the region to a UNIX command, and replaces  the
region  with  the  output  from that command.  For example, if you are
lazy and don't like to take the time  to  write  properly  indented  C
code, you can put the region around your C file and "filter-region" it
through "cb," the UNIX C beautifier.  If you have a file that contains
a  bunch  of  lines that need to be sorted you can do that from inside
JOVE too, by filtering the region through  the  "sort"  UNIX  command.
Before output from the command replaces the region JOVE stores the old
text in the kill ring, so if you are unhappy with the results you  can
easily get back the old text with "C-Y".

:entry "find-file" "Command"
This visits a file into its own buffer and then selects  that  buffer.
If  you've already visited this file in another buffer, that buffer is
selected.  If the file doesn't yet exist, JOVE will print "(New file)"
so that you know.

:entry "find-tag" "Command"
This finds the file that contains the specified tag.   JOVE  looks  up
tags  by default in the "tags" file in the current directory.  You can
change the default tag name by  setting  the  "tag-file"  variable  to
another  name.  If you specify a numeric argument to this command, you
will be prompted for a tag file.  This is a good way to specify anoth-
er  tag file without changing the default.  If the tag cannot be found
the error is reported and point stays where it is.

:entry "find-tag-at-point" "Command"
This finds the file that contains the tag that point is currently  on.
See "find-tag."

:entry "first-non-blank" "Command"
This moves point back to the indent of the current line.

:entry "foreground-color" "Variable"
This specifies the foreground color of the screen (PC  version  only).
The  default  is  1,  which  stands for white.  The attribute used for
writing to the screen is formed by (bg&7)<<4 & (fg&7).

:entry "forward-character" "Command"
This moves forward over a single character.  If point is at the end of
the line it moves to the beginning of the next one.

:entry "forward-list" "Command"
This is like "forward-s-expression" except it moves over  lists  ONLY.
What  this does is search for the next "(" and then move to the match-
ing ")".  This is useful for when you are trying  to  find  mismatched
parentheses in a program.

:entry "forward-paragraph" "Command"
This moves point forward to the end of the current or next  paragraph.
Paragraphs are bounded by lines that begin with a Period or Tab, or by
blank lines; a change in indentation may also signal a  break  between
paragraphs,  except  that JOVE allows the first line of a paragraph to
be indented differently from the other lines.

:entry "forward-s-expression" "Command"
This moves point forward over a s-expression.  If the  first  signifi-
cant  character  after point is "(", this moves past the matching ")".
If the character begins an identifier, this moves just past it.   This
is  mode  dependent,  so  this will move over atoms in LISP mode and C
identifiers in C mode.  JOVE also matches "{".

:entry "forward-sentence" "Command"
This moves point forward to the end of the current or  next  sentence.
JOVE  considers the end of a sentence to be the characters ".", "!" or
"?" followed by a Return, or one or more spaces.

:entry "forward-word" "Command"
This moves point forward to the end of the current or next word.

:entry "fundamental-mode" "Command"
This sets the major mode to Fundamental.  This affects what JOVE  con-
siders  as  characters that make up words.  For instance, Single-quote
is not part of a word in Fundamental mode, but is in Text mode.

:entry "gather-numeric-argument" "Command"
This command is one of two ways to specify a  numeric  argument  to  a
command.   It's  usually  bound to C-U.  Typing C-U once means, Do the
next command 4 times.  Typing C-U twice will do the  next  command  16
times, and so on.  If at any point you type a number, then that number
will be used instead of 4.  For instance, C-U 3 5 means  do  the  next
command 35 times.

:entry "goto-line" "Command"
If a numeric argument is supplied point moves to the beginning of that
line.  If no argument is supplied one is prompted for.

:entry "goto-window-with-buffer" "Command"
This command prompts for a buffer name and then selects  that  buffer.
If the buffer is currently being displayed in one of the windows, that
window is selected instead.

:entry "grind-s-expr" "Command"
When point is positioned on a "(", this re-indents that  LISP  expres-
sion.

:entry "grow-window" "Command"
This makes the current window one line bigger.  This only  works  when
there is more than one window and provided there is room to change the
size.

:entry "handle-tab" "Command"
This handles indenting to the "right" place in C and  Lisp  mode,  and
just inserts itself in Text mode.

:entry "i-search-forward" "Command"
Incremental  search.   Like  search-forward  except  that  instead  of
prompting  for  a string and searching for that string all at once, it
accepts the string one character at a time.  After each character  you
type  as  part of the search string, it searches for the entire string
so far.  When you like what it found, type the Return  key  to  finish
the  search.  You can take back a character with Rubout and the search
will back up to the position before that  character  was  typed.   C-G
aborts the search.

:entry "i-search-reverse" "Command"
Incremental  search.   Like  search-reverse  except  that  instead  of
prompting  for  a string and searching for that string all at once, it
accepts the string one character at a time.  After each character  you
type  as  part of the search string, it searches for the entire string
so far.  When you like what it found, type the Return  key  to  finish
the  search.  You can take back a character with Rubout and the search
will back up to the position before that  character  was  typed.   C-G
aborts the search.

:entry "i-shell-command" "Command"
This is like "shell-command" except it lets  you  continue  with  your
editing  while the command is running.  This is really useful for long
running commands with sporadic output.  See the manual for information
on how to use interactive processes.

:entry "insert-file" "Command"
This inserts a specified file into the current buffer at point.  Point
is positioned at the beginning of the inserted file.

:entry "internal-tabstop" "Variable"
The number of spaces JOVE should print when it displays a tab  charac-
ter.  The default value is 8.

:entry "interrupt-character" "Variable"
This is set to the character that interrupts JOVE (with a  signal)  no
matter  what  JOVE  is  doing.  It's main use is for interrupting non-
interactive processes, but it also has  uses  for  debugging.   Unfor-
tunately there is no way to turn off the interrupt character.

:entry "interrupt-process" "Command"
This sends the interrupt character (usually C-C)  to  the  interactive
process in the current buffer.  This is only for versions of JOVE that
have the interactive processes feature.  This only works when you  are
inside a buffer that's attached to a process.

:entry "kill-next-word" "Command"
This kills the text from point to the end of the current or next word.

:entry "kill-previous-word" "Command"
This kills the text from point to the beginning of the current or pre-
vious word.

:entry "kill-process" "Command"
This command prompts for a buffer  name  or  buffer  number  (just  as
select-buffer  does)  and then sends the process in that buffer a kill
signal (9).

:entry "kill-region" "Command"
This deletes the text in the region and saves it  on  the  kill  ring.
Commands  that  delete  text but save it on the kill ring all have the
word "kill" in their names.  Type "C-Y" to yank back the  most  recent
kill.

:entry "kill-s-expression" "Command"
This kills the text from point to the end of the current  or  next  s-
expression.

:entry "kill-some-buffers" "Command"
This goes through all the existing buffers and asks whether or not  to
kill  them.  If you decide to kill a buffer, and it turns out that the
buffer is modified, JOVE will offer to save it first.  This is  useful
for  when JOVE runs out of memory to store lines (this only happens on
PDP-11's) and you have lots of buffers that you are no longer using.

:entry "kill-to-beginning-of-sentence" "Command"
This kills from point to the beginning of the current or previous sen-
tence.

:entry "kill-to-end-of-line" "Command"
This kills from point to the end of the current line.  When  point  is
at the end of the line the line separator is deleted and the next line
is joined with current one.  If a numeric argument  is  supplied  that
many  lines  are  killed;  if the argument is negative that many lines
"before" point are killed; if the argument is zero the text from point
to the beginning of the line is killed.

:entry "kill-to-end-of-sentence" "Command"
This kills from point to the end of the current or next sentence.   If
a negative numeric argument is supplied it kills from point to the be-
ginning of the current or previous sentence.

:entry "left-margin" "Variable"
This is how far lines should be indented when auto-indent mode is  on,
or  when  the  "newline-and-indent"  command is run (usually by typing
LineFeed).  It is also used by fill-paragraph and auto-fill mode.   If
the  value  is  zero  (the default) then the left margin is determined
from the surrounding lines.

:entry "left-margin-here" "Command"
This sets the "left-margin" variable to the current position of point.
This is an easy way to say, "Make the left margin begin here," without
having to count the number of spaces over it actually is.

:entry "lisp-mode" "Command"
This turns on Lisp mode.  Lisp mode is one of four mutually  exclusive
major  modes: Fundamental, Text, C, and Lisp.  In Lisp mode, the char-
acters Tab and ) are treated specially, similar to the  way  they  are
treated  in  C  mode.  Also, Auto Indent mode is affected, and handled
specially.

:entry "list-buffers" "Command"
This types out  a  list  containing  various  information  about  each
buffer.  Right now that list looks like this:

      (* means the buffer needs saving)
      NO  Lines Type        Name           File
      --  ----- ----        ----           ----
      1   1     File        Main           [No file]
      2   1     Scratch   * Minibuf        [No file]
      3   519   File      * commands.doc   commands.doc

The first column lists the buffer's number.  When JOVE prompts  for  a
buffer  name  you  can either type in the full name, or you can simply
type the buffer's number.  The second column is the number of lines in
the  buffer.   The  third  says  what  type of buffer.  There are four
types: "File", "Scratch", "Process", "I-Process".  "File" is simply  a
buffer  that  holds  a  file;  "Scratch" is for buffers that JOVE uses
internally; "Process" is one that holds the output from  a  UNIX  com-
mand;  "I-Process"  is one that has an interactive process attached to
it.  The next column contains the name of the buffer.   And  the  last
column is the name of the file that's attached to the buffer.  In this
case, both Minibuf and commands.doc have  been  changed  but  not  yet
saved.   In  fact  Minibuf  won't be saved since it's an internal JOVE
buffer that I don't even care about.

:entry "list-processes" "Command"
This makes a list somewhat like "list-buffers" does, except  its  list
consists  of  the  current  interactive processes.  Right now the list
looks like this:

      Buffer           Status           Pid    Command
      ------           ------           ---    -------
      *shell*          Running          18415shell
      fgrep            Done             18512   fgrep -n Buffer *.c

The first column has the name of the buffer to which  the  process  is
attached.   The second has the status of the process; if a process has
exited normally the status is "Done" as in fgrep; if the process exit-
ed  with  an  error the status is "Exit N" where N is the value of the
exit code; if the process was killed by some signal the status is  the
name  of  the  signal that was used; otherwise the process is running.
The last column is the name of the command that is being run.

:entry "mail-check-frequency" "Variable"
This is how often (in seconds) JOVE should check your mailbox for  in-
coming  mail.   If you set this to ZERO JOVE won't check for new mail.
See also the "mailbox" and "disable-biff" variables.

:entry "mailbox" "Variable"
Set this to the full pathname of your mailbox.  JOVE will look here to
decide  whether  or  not  you  have any unread mail.  This defaults to
/usr/spool/mail/$USER, where $USER is set to your login name.

:entry "make-backup-files" "Variable"
If this variable is set, then whenever JOVE writes out a file, it will
move  the  previous  version  of  the  file  (if  there  was  one)  to
"#filename".  This is often convenient if you save a file by accident.
The  default  value of this variable is "off".  "Note:" this is an op-
tional part of JOVE, and your guru may not have it enabled, so it  may
not work.

:entry "make-buffer-unmodified" "Command"
This makes JOVE think the selected buffer hasn't been changed even  if
it  has.   Use  this when you accidentally change the buffer but don't
want it considered changed.  Watch the mode line to see the  *  disap-
pear when you use this command.

:entry "make-keymap" "Command"
This creates an empty keymap with a name you supply.  That name can be
used  to  reference the keymap in other commands, such as bind-keymap-
to-key.

:entry "make-macro-interactive" "Command"
This command is meaningful only while you are defining a keyboard mac-
ro, and when you are in the minibuffer.  Ordinarily, when a command in
a macro definition requires  a  trailing  text  argument  (file  name,
search string, etc.), the argument you supply becomes part of the mac-
ro definition.  If you want to be able to supply a different  argument
each  time  the  macro  is  used,  then while you are defining it, you
should give the make-macro-interactive command just before typing  the
argument  which will be used during the definition process.  Note: you
must bind this command to a key in order to use it; you can't say "ESC
X make-macro-interactive".

:entry "mark-threshold" "Variable"
This variable contains the number of lines point may  move  by  before
the  mark  is  set.  If, in a search or something, point moves by more
than this many lines, the mark is set so that you may  return  easily.
The  default value of this variable is 22 (one screenful, on most ter-
minals).

:entry "marks-should-float" "Variable"
When this variable is "off", the position of a mark is remembered as a
line  number within the buffer and a character number within the line.
If you add or delete text before the mark, it will no longer point  to
the  text  you marked originally because that text is no longer at the
same line and character number.  When this variable is "on", the posi-
tion  of a mark is adjusted to compensate for each insertion and dele-
tion.  This makes marks much more sensible to  use,  at  the  cost  of
slowing  down  insertion  and deletion somewhat.  The default value is
"on".

:entry "match-regular-expressions" "Variable"
When set, JOVE will match  regular  expressions  in  search  patterns.
This  makes  special the characters ., *, [, ], ^, and $, and the two-
character sequences \<, \>, \{, \} and \|.   See  the  "ed(1)"  manual
page,  the  tutorial "Advanced Editing in UNIX", and the section above
"Searching with Regular Expressions" for more information.

:entry "meta-key" "Variable"
You should set this variable to "on" if your terminal has a real  Meta
key.   If your terminal has such a key, then a key sequence like ESC Y
can be entered by holding down Meta and typing Y.  NOTE:  In some sys-
tems, this disables interrupting noninteractive shell commands.

:entry "mode-line" "Variable"
The format of the mode line can be determined by  setting  this  vari-
able.   The  items in the line are specified using a format similar to
that used by printf(3), with the special things being marked as  "%x".
Digits may be used between the 'x' may be:

          C    check for new mail, and displays "[New mail]" if there
               is any (see also the mail-check-interval and disable-biff
               variables)
          F    the current file name, with leading path stripped
          M    the current list of major and minor modes
          b    the current buffer name
          c    the fill character (-)
          d    the current directory
          e    extra space in modeline is distributed evenly
               among the place %e is used (used for justifying,
               separating, or centering parts of the modeline)
          f    the current file name
          l    the current load average (updated automatically)
          mxy  x, when the buffer is modified or y, when not
          n    the current buffer number
          p    interactive process status for process windows
          s    space, but only if previous character is not a space
          t    the current time (updated automatically)
          w    a '>' for windows which are scrolled left
          [ ]  the square brackets printed when in a recursive edit
          ( )  items enclosed in %( ... %) will only be printed on
               the bottom mode line, rather than copied when the
               window is split

In addition, any other character is simply copied into the mode  line.
Characters  may  be  escaped  with a backslash.  To get a feel for all
this, try typing "ESC X print mode-line" and compare the  result  with
your current mode line.

:entry "mode-line-color" "Variable"
This specifies the color of the modeline (PC version only).   Its  de-
fault  value  is 0, and in that case it is drawn in reverse video.  If
it has any other value, this value is used as  the  attribute  in  the
Bios calls.

:entry "mode-line-should-standout" "Variable"
If set, the mode line will be printed in reverse video, if your termi-
nal supports it.  The default for this variable is "off".

:entry "name-kbd-macro" "Command"
This copies the keyboard macro and gives it a name freeing up the key-
board  macro  so you can define some more.  Keyboard macros with their
own names can be bound to keys just like built in commands  can.   See
the "define-macro," "source" and "write-macros-to-file" commands.

:entry "newline" "Command"
This divides the current line at point moving  all  the  text  to  the
right  of point down onto the newly created line.  Point moves down to
the beginning of the new line.

:entry "newline-and-backup" "Command"
This divides the current line at point moving  all  the  text  to  the
right  of  point  down  onto  the  newly created line.  The difference
between this and "newline" is that point does not move down to the be-
ginning of the new line.

:entry "newline-and-indent" "Command"
This behaves the same was as Return does when  in  Auto  Indent  mode.
This  makes  Auto  Indent  mode obsolete but it remains in the name of
backward compatibility.

:entry "next-error" "Command"
This moves to the next error in the list of errors  that  were  parsed
with  "parse-errors."  In  one window the list of errors is shown with
the current one always at the top.  In another window is the file that
contains  the  error.   Point is positioned in this window on the line
where the error occurred.

:entry "next-line" "Command"
This moves down to the next line.

:entry "next-page" "Command"
This displays the next page of the buffer by taking the bottom line of
the  window  and  redrawing  the  window with it at the top.  If there
isn't another page in the buffer JOVE rings the bell.   If  a  numeric
argument is supplied the screen is scrolled up that many lines; if the
argument is negative the screen is scrolled down.

:entry "next-window" "Command"
This moves into the next window.  Windows live in a circular  list  so
when  you're  in the bottom window and you try to move to the next one
you are moved to the top window.  It is an error to use  this  command
with only one window.

:entry "number-lines-in-window" "Command"
This displays the line numbers for  each  line  in  the  buffer  being
displayed.   The  number  isn't  actually  part of the text; it's just
printed before the actual buffer line is.  To turn this  off  you  run
the command again; it toggles.

:entry "over-write-mode" "Command"
This turns Over Write mode on (or off if it's  currently  on)  in  the
selected  buffer.   When  on,  this  mode  changes  the  way the self-
inserting characters work.  Instead of inserting themselves and  push-
ing the rest of the line over to the right, they replace or over-write
the existing character.  Also, Rubout replaces  the  character  before
point with a space instead of deleting it.  When Over Write mode is on
"OvrWt" is displayed on the mode line.

:entry "page-next-window" "Command"
This displays the next page in the next window.  This is  exactly  the
same as "C-X N C-V C-X P".

:entry "paren-flash" "Command"
This handles the C mode curly brace indentation, the Lisp  mode  paren
indentation,  and the Show Match mode paren/curly brace/square bracket
flashing.

:entry "paren-flash-delay" "Variable"
How long, in tenths of  seconds,  JOVE  should  pause  on  a  matching
parenthesis in "Show" mode.  The default is 5.

:entry "parse-errors" "Command"
This takes the list of C compilation errors (or  output  from  another
program  in the same format) in the current buffer and parses them for
use with the "next-error"  and  "previous-error"  and  "current-error"
commands.   This is a very useful tool and helps with compiling C pro-
grams and when used in conjunction with the "grep" UNIX  command  very
helpful  in  making  changes to a bunch of files.  This command under-
stands errors produced by cc, cpp, and lint; plus  any  other  program
with  the  same  format (e.g., "grep -n").  JOVE visits each file that
has an error and remembers each  line  that  contains  an  error.   It
doesn't matter if later you insert or delete some lines in the buffers
containing  errors;  JOVE  remembers  where   they   are   regardless.
"current-error"  is automatically executed after one of the parse com-
mands, so you end up at the  first  error.   See  also  "error-format-
string" to make it possible to parse errors of a different format.

:entry "parse-spelling-errors-in-buffer" "Command"
This parses a list of words in the current buffer and looks them up in
another buffer that you specify.  This will probably go away soon.

:entry "pause-jove" "Command"
This stops JOVE and returns control to the parent  shell.   This  only
works  for  users  using the C-shell, and on systems that have the job
control facility.  To return to JOVE you type "fg" to the C-shell.

:entry "physical-tabstop" "Variable"
How many spaces your terminal prints when it prints a tab character.

:entry "pop-mark" "Command"
This gets executed when you run "set-mark" with  a  numeric  argument.
JOVE remembers the last 16 marks and you use "pop-mark" to go backward
through the ring of marks.  If you execute "pop-mark" enough times you
will eventually get back to where you started.

:entry "popd" "Command"
This pops one entry off the directory stack.  Entries are pushed  with
the  "pushd"  command.  The names were stolen from the C-shell and the
behavior is the same.

:entry "previous-error" "Command"
This is the same as "next-error" except it goes to the previous error.
See "next-error" for documentation.

:entry "previous-line" "Command"
This moves up to the previous line.

:entry "previous-page" "Command"
This displays the previous page of the current buffer  by  taking  the
top line and redrawing the window with it at the bottom.  If a numeric
argument is supplied the screen is scrolled down that many  lines;  if
the argument is negative the screen is scrolled up.

:entry "previous-window" "Command"
This moves into the next window.  Windows live in a circular  list  so
when  you're in the top window and you try to move to the previous one
you are moved to the bottom window.  It is an error to use  this  com-
mand with only one window.

:entry "print" "Command"
This prints the value of a JOVE variable.

:entry "process-bind-keymap-to-key" "Command"
This is just like "bind-to-key" except that it starts at the  process-
keymap map, instead of the default mainmap.

:entry "process-bind-to-key" "Command"
This command is identical to bind-to-key, except that it only  affects
your  bindings  when  you are in a buffer attached to a process.  When
you enter the process buffer, any keys bound with  this  command  will
automatically take their new values.  When you switch to a non-process
buffer, the old bindings for those keys will be restored.   For  exam-
ple, you might want to execute

     process-bind-to-key stop-process ^Z
     process-bind-to-key interrupt-process ^C

Then, when you start up an interactive process and  switch  into  that
buffer,  C-Z will execute stop-process and C-C will execute interrupt-
process.  When you switch back to a non-process buffer,  C-Z  will  go
back to executing scroll-up (or whatever you have it bound to).

:entry "process-dbx-output" "Command"
This command only makes sense in a buffer running a shell process.  If
you are running dbx in a window, JOVE will automatically find the file
you are currently stepping through and display it in  another  window.
The  string DBX will appear in the modeline along with the other minor
modes when this feature is enabled.

:entry "process-newline" "Command"
This only gets executed when in  a  buffer  that  is  attached  to  an
interactive-process.   JOVE  does  two  different  things depending on
where you are when you hit Return.  When you're at the end of  the  I-
Process  buffer  this  does  what Return normally does, except it also
makes the line available to the process.  When point is positioned  at
some other position that line is copied to the end of the buffer (with
the prompt stripped) and point is moved there with it, so you can then
edit  that line before sending it to the process.  This command "must"
be bound to the key you usually use to enter shell commands  (Return),
or else you won't be able to enter any.

:entry "process-prompt" "Variable"
What a prompt looks like from the shell and i-shell-command processes.
The  default  is "% ", the default C-shell prompt.  This is actually a
regular expression search string.  So you can set it to be  more  than
one thing at once using the \| operator.  For instance, for LISP hack-
ers, the prompt can be

     "% \|-> \|<[0-9]>: ".


:entry "process-send-data-no-return" "Command"
This is like "process-newline" except it sends everything to the  pro-
cess without the newline.  Normally, when you type return in a process
buffer it sends everything you typed including the Return.  This  com-
mand just provides a way to send data to the process without having to
send a newline as well.

:entry "push-shell" "Command"
This spawns a child shell and relinquishes control to it.  This  works
on any version of UNIX, but this isn't as good as "pause-jove" because
it takes time to start up the new shell and you get a  brand  new  en-
vironment every time.  To return to JOVE you type "C-D".

:entry "pushd" "Command"
This pushes a directory onto the directory stack and cd's into it.  It
asks  for  the directory name but if you don't specify one it switches
the top two entries no the stack.  It purposely behaves  the  same  as
C-shell's "pushd."

:entry "pwd" "Command"
This prints the working directory.

:entry "query-replace-string" "Command"
This replaces the occurrences of a specified string with  a  specified
replacement  string.  When an occurrence is found point is moved to it
and then JOVE asks what to do.  The options are:

     Space    to replace this occurrence and go on to the next one.
     Period   to replace this occurrence and then stop.
     Rubout   to skip this occurrence and go on to the next one.
     C-R      to enter a recursive edit.  This lets you temporarily
              suspend the replace, do some editing, and then return
              to continue where you left off.  To continue with the
              Query Replace type "C-X C-C" as if you were trying to
              exit JOVE.  Normally you would but when you are in a
              recursive edit all it does is exit that recursive
              editing level.
     C-W      to delete the matched string and then enter a recursive
              edit.
     U        to undo all changes to the last modified line.
     P or !   to go ahead and replace the remaining occurrences without
              asking.
     Return   to stop the Query Replace.

The search for occurrences starts at point and goes to the end of  the
buffer,  so  to  replace in the entire buffer you must first go to the
beginning.

:entry "quit-process" "Command"
This is the same as typing "C-\" (the Quit character) to a normal UNIX
process,  except  it sends it to the current process in JOVE.  This is
only for versions of JOVE that have the interactive processes feature.
This only works when you are inside a buffer that's attached to a pro-
cess.

:entry "quoted-insert" "Command"
This lets you insert characters that normally  would  be  executed  as
other JOVE commands.  For example, to insert "C-F" you type "C-Q C-F".

:entry "read-only-mode" "Command"
Read-only-mode is a minor mode.  It puts a buffer in  read-only  mode,
so that any attempts to modify the buffer fail.  When a file is found,
and it's not got write permission, JOVE automatically puts the  buffer
in  read-only mode.  This is very helpful when you are in environments
which use source control programs like RCS and SCCS.  It prevents  ac-
cidents  like making a bunch of changes and only THEN discovering that
you haven't checked the file out for making changes.  This, like other
minor modes, toggles.

:entry "read-word-abbrev-file" "Command"
This reads a specified file that contains a bunch of abbreviation  de-
finitions,  and  makes those abbreviations available.  If the selected
buffer is not already in Word Abbrev mode this command puts it in that
mode.

:entry "recursive-edit" "Command"
This enters a recursive editing level.  This isn't really very useful.
I  don't  know why it's available for public use.  I think I'll delete
it some day.

:entry "redraw-display" "Command"
This centers the line containing point in the window.  If that line is
already  in  the  middle the window is first cleared and then redrawn.
If a numeric argument is supplied, the  line  is  positioned  at  that
offset from the top of the window.  For example, "ESC 0 C-L" positions
the line containing point at the top of the window.

:entry "rename-buffer" "Command"
This lets you rename the current buffer.

:entry "replace-in-region" "Command"
This is the same as "replace-string" except that it is  restricted  to
occurrences between Point and Mark.

:entry "replace-string" "Command"
This replaces all occurrences of a specified string with  a  specified
replacement  string.   This is just like "query-replace-string" except
it replaces without asking.

:entry "right-margin" "Variable"
Where the right margin is for  "Auto  Fill"  mode  and  the  "justify-
paragraph" and "justify-region" commands.  The default is 78.

:entry "right-margin-here" "Command"
This sets the "right-margin"  variable  to  the  current  position  of
point.   This  is  an  easy  way  to say, "Make the right margin begin
here," without having to count the number of spaces over  it  actually
is.

:entry "save-file" "Command"
This saves the current buffer to the associated file.  This makes your
changes  permanent  so  you should be sure you really want to.  If the
buffer has not been modified "save-file" refuses to do the  save.   If
you  really do want to write the file you can use "C-X C-W" which exe-
cutes "write-file."

:entry "scroll-all-lines" "Variable"
When this is turned on, the entire window will  be  scrolled  left  or
right  when the current line scrolls.  The default value is OFF, which
will cause JOVE to behave in the familiar way, namely to  scroll  only
the current line.

:entry "scroll-down" "Command"
This scrolls the screen one line down.  If the line  containing  point
moves past the bottom of the window point is moved up to the center of
the window.  If a numeric argument is supplied  that  many  lines  are
scrolled;  if  the  argument is negative the screen is scrolled up in-
stead.

:entry "scroll-left" "Command"
This scrolls the text in the current window 10 character positions  to
the  left.   If  a  numeric  argument  is  specified  then the text is
scrolled  that  number  of  character  positions.   If  the   variable
"scroll-all-lines" is ON then "scroll-left" may actually do nothing if
the scrolling would cause Point not to be visible.

:entry "scroll-next-page" "Command"
This continuously scrolls up screen-full lines (PC version only).

:entry "scroll-previous-page" "Command"
This continuously scrolls down screen-full lines (PC version only).

:entry "scroll-right" "Command"
This scrolls the text in the current window 10 character positions  to
the  right.   If  a  numeric  argument  is  specified then the text is
scrolled  that  number  of  character  positions.   If  the   variable
"scroll-all-lines"  is  ON then "scroll-right" may actually do nothing
if the scrolling would cause Point not to be visible.

:entry "scroll-step" "Variable"
How many lines should be scrolled if  the  "previous-line"  or  "next-
line"  commands move you off the top or bottom of the screen.  You may
wish to decrease this variable if you are on a slow terminal.  The de-
fault  value  is 0, which means to center the current line in the win-
dow.  If the value is negative, the behavior  is  slightly  different.
If  you  move off the top of the window, and "scroll-step" is, say, -5
then the new line will be displayed 5 lines from  the  bottom  of  the
window.   If  you move off the bottom of the window, the new line will
be positioned 5 lines from the top of the window.

:entry "scroll-up" "Command"
This scrolls the screen one line up.  If  the  line  containing  point
moves  past the top of the window point is moved down to the center of
the window.  If a numeric argument is supplied  that  many  lines  are
scrolled;  if the argument is negative the screen is scrolled down in-
stead.

:entry "search-exit-char" "Variable"
Set this to the character you want to use to exit incremental  search.
The  default  is  Newline, which makes i-search compatible with normal
string search.

:entry "search-forward" "Command"
This searches forward for a  specified  search  string  and  positions
point  at  the  end of the string if it's found.  If the string is not
found point remains unchanged.  This searches from point to the end of
the buffer, so any matches before point will be missed.

:entry "search-forward-nd" "Command"
This is just like "search-forward" except that it doesn't assume a de-
fault  search  string,  and  it doesn't set the default search string.
This is useful for defining macros, when you want to search for  some-
thing,  but  you  don't  want  it to affect the current default search
string.

:entry "search-reverse" "Command"
This searches backward for a specified  search  string  and  positions
point  at the beginning if the string if it's found.  If the string is
not found point remains unchanged.  This searches from  point  to  the
beginning of the buffer, so any matches after point will be missed.

:entry "search-reverse-nd" "Command"
This is just like "search-reverse" except that it doesn't assume a de-
fault  search  string,  and  it doesn't set the default search string.
This is useful for defining macros, when you want to search for  some-
thing,  but  you  don't  want  it to affect the current default search
string.

:entry "select-buffer" "Command"
This selects a new or already existing buffer making  it  the  current
one.   You  can type either the buffer name or number.  If you type in
the name you need only type the name until it is unambiguous, at which
point typing Escape or Space will complete it for you.  If you want to
create a new buffer you can type Return instead of Space,  and  a  new
empty buffer will be created.

:entry "select-buffer-1" "Command"
This selects buffer number 1, if it exists (PC version only).

:entry "select-buffer-2" "Command"
This selects buffer number 2, if it exists (PC version only).

:entry "select-buffer-3" "Command"
This selects buffer number 3, if it exists (PC version only).

:entry "select-buffer-4" "Command"
This selects buffer number 4, if it exists (PC version only).

:entry "select-buffer-5" "Command"
This selects buffer number 5, if it exists (PC version only).

:entry "select-buffer-6" "Command"
This selects buffer number 6, if it exists (PC version only).

:entry "select-buffer-7" "Command"
This selects buffer number 7, if it exists (PC version only).

:entry "select-buffer-8" "Command"
This selects buffer number 8, if it exists (PC version only).

:entry "select-buffer-9" "Command"
This selects buffer number 9, if it exists (PC version only).

:entry "self-insert" "Command"
This inserts the character that invoked it into the buffer  at  point.
Initially  all  but  a  few  of  the  printing characters are bound to
"self-insert."

:entry "send-typeout-to-buffer" "Variable"
When this is set JOVE will send output that  normally  overwrites  the
screen  (temporarily) to a buffer instead.  This affects commands like
"list-buffers," "list-processes," and commands  that  use  completion.
The default value is "off".

:entry "set" "Command"
This gives a specified variable a new value.  Occasionally you'll  see
lines  like  "set  this variable to that value to do this".  Well, you
use the "set" command to do that.

:entry "set-mark" "Command"
This sets the mark at the current position in the buffer.   It  prints
the  message "Point pushed" on the message line.  It says that instead
of "Mark set" because when you set the mark the previous mark is still
remembered  on  a  ring of 16 marks.  So "Point pushed" means point is
pushed onto the ring of marks and becomes the value of "the mark".  To
go  through the ring of marks you type "C-U C-@", or execute the "pop-
mark" command.  If you type this enough times you  will  get  back  to
where you started.

:entry "shell" "Variable"
The shell to be used with all the shell  commands  command.   If  your
SHELL environment variable is set, it is used as the value of "shell;"
otherwise "/bin/csh" is the default.

:entry "shell" "Command"
This starts up an interactive shell in a window.  JOVE uses  "*shell*"
as  the  name of the buffer in which the interacting takes place.  See
the manual for information on how to use interactive processes.

:entry "shell-command" "Command"
This runs a UNIX command and places the output from that command in  a
buffer.   JOVE  creates  a buffer that matches the name of the command
you specify and then attaches that buffer to a window.  So,  when  you
have only one window running this command will cause JOVE to split the
window and attach the new buffer  to  that  window.   Otherwise,  JOVE
finds  the  most convenient of the available windows and uses that one
instead.  If the buffer already exists it  is  first  emptied,  except
that  if it's holding a file, not some output from a previous command,
JOVE prints an error message and refuses to execute the  command.   If
you  really  want to execute the command you should delete that buffer
(saving it first, if you like) or use  "shell-command-to-buffer,"  and
try again.

:entry "shell-command-no-buffer" "Command"
This is just like "shell-command" except  it  just  runs  the  command
without  saving  the output to any buffer.  It will report the success
of the command in the usual way.

:entry "shell-command-to-buffer" "Command"
This is just like "shell-command"  except  it  lets  you  specify  the
buffer to use instead of JOVE.

:entry "shell-command-with-typeout" "Command"
This is just like "shell-command" except that instead  of  saving  the
output to a buffer, and displaying it in a window, this just types out
the output in the same way that "list-buffers"  does.   Actually,  how
this  behaves  depends  on the value of the variable "send-typeout-to-
buffer." If it is on then shell-command-with-typeout will behave  just
like "shell-command."

:entry "shell-flags" "Variable"
This defines the flags that are passed to shell commands.  The default
is "-c".  See the "shell" variable to change the default shell.

:entry "shift-region-left" "Command"
This shifts the region  left  by  c-indentation-increment  OR  by  the
numeric  argument, if one is supplied.  If a negative argument is sup-
plied the region is shifted the other way.

:entry "shift-region-right" "Command"
This shifts the region  left  by  c-indentation-increment  OR  by  the
numeric  argument, if one is supplied.  If a negative argument is sup-
plied the region is shifted the other way.

:entry "show-match-mode" "Command"
This turns on Show Match mode (or off if it's  currently  on)  in  the
selected  buffer.  This changes "}", ")" and "]" so that when they are
typed the are inserted as usual, and then the cursor flashes  back  to
the  matching  "{", "(" or "[" (depending on what was typed) for about
half a second, and then goes back to just after the "}",  ")"  or  "]"
that  invoked  the  command.  This is useful for typing in complicated
expressions in a program.  You can change how long the cursor sits  on
the  matching  paren  by  setting  the "paren-flash-delay" variable in
tenths of a second.  If the matching "{", "(" or  "["  isn't  visible,
the  line  containing  the  match  is  displayed  at the bottom of the
screen.

:entry "shrink-window" "Command"
This makes the current window one line shorter, if possible.   Windows
must  be at least 2 lines high, one for the text and the other for the
mode line.

:entry "source" "Command"
This reads a bunch of JOVE commands from a file.  The  format  of  the
file  is the same as that in your initialization file (your ".joverc")
in your main directory.  There should be one command per line  and  it
should  be  as  though  you typed "ESC X" while in JOVE.  For example,
here's part of my initialization file:

     bind-to-key i-search-reverse ^R
     bind-to-key i-search-forward ^S
     bind-to-key pause-jove ^[S

What they do is make "C-R" call  the  "i-search-reverse"  command  and
"C-S" call "i-search-forward" and "ESC S" call "pause-jove."

:entry "spell-buffer" "Command"
This runs the current buffer through  the  UNIX  "spell"  program  and
places the output in buffer "Spell".  Then JOVE lets you edit the list
of words, expecting you to delete the ones that you don't care  about,
i.e.,  the  ones  you  know  are  spelled correctly.  Then the "parse-
spelling-errors-in-buffer" command  comes  along  and  finds  all  the
misspelled words and sets things up so the error commands work.

:entry "split-current-window" "Command"
This splits the current window into two  equal  parts  (providing  the
resulting  windows  would  be  big  enough)  and displays the selected
buffer in both windows.  Use "C-X 1" to go back to 1 window mode.   If
a numeric argument is supplied, the window is split "evenly" that many
times (when possible).

:entry "start-remembering" "Command"
This is just another name for the "begin-kbd-macro" name.  It  is  in-
cluded for backward compatibility.

:entry "stop-process" "Command"
This sends a stop signal (C-Z, for most people) to  the  current  pro-
cess.   It only works if you have the interactive process feature, and
you are in a buffer attached to a process.

:entry "stop-remembering" "Command"
This is just another name for the "end-kbd-macro" command.  It is  in-
cluded for backward compatibility.

:entry "string-length" "Command"
This prints the number of characters in the string that point sits in.
Strings  are  surrounded  by double quotes.  JOVE knows that "\007" is
considered a single character, namely "C-G", and also knows about oth-
er common ones, like "\r" (Return) and "\n" (LineFeed).  This is most-
ly useful only for C programmers.

:entry "suspend-jove" "Command"
This is a synonym for "pause-jove."

:entry "sync-frequency" "Variable"
The temporary files used by JOVE are forced out to disk  every  "sync-
frequency"  modifications.  The default is 50, which really makes good
sense.  Unless your system is very unstable,  you  probably  shouldn't
fool with this.

:entry "tag-file" "Variable"
This the name of the file in which JOVE should  look  up  tag  defini-
tions.  The default value is "./tags".

:entry "text-mode" "Command"
This sets the major mode to Text.  Currently the other modes are  Fun-
damental, C and Lisp mode.

:entry "tmp-file-pathname" "Variable"
This tells JOVE where to put the tmp files, which is where JOVE stores
buffers  internally.   The default is usually in /tmp, but if you want
to store them somewhere else, you can set this variable.  If your sys-
tem  crashes  a  lot  it  might be a good idea to set this variable to
somewhere other than /tmp because the system removes all the files  in
/tmp  upon  reboot,  and  so  you  would not be able to recover editor
buffers using the "jove -r" command.

NOTE: In order for this to work correctly you must set  this  variable
BEFORE  JOVE  creates  the tmp file.  You can set this in your .joverc
(the closer to tbe beginning the better), or as soon as you  start  up
JOVE before you visit any files.

:entry "transpose-characters" "Command"
This switches the character before point with the one after point, and
then  moves  forward  one.   This doesn't work at the beginning of the
line, and at the end of the line it switches the two characters before
point.   Since  point is moved forward, so that the character that was
before point is still before point, you can use "C-T" to drag a  char-
acter  down the length of a line.  This command pretty quickly becomes
very useful.

:entry "transpose-lines" "Command"
This switches the current line with the one above it, and  then  moves
down  one  so that the line that was above point is still above point.
This, like "transpose-characters," can be used to drag a line  down  a
page.

:entry "unbind-key" "Command"
Use this to unbind "any" key sequence.  You can  use  this  to  unbind
even  a  prefix command, since this command does not use "key-map com-
pletion".  For example, "ESC X unbind-key ESC [" unbinds the  sequence
"ESC  [".   This  is  useful  for  "turning  off" something set in the
system-wide ".joverc" file.

:entry "update-time-frequency" "Variable"
How often the mode line is updated (and thus the time and  load  aver-
age, if you display them).  The default is 30 seconds.

:entry "use-i/d-char" "Variable"
If your terminal has insert/delete character capability you  can  tell
JOVE not to use it by setting this to "off".  In my opinion it is only
worth using insert/delete character at low baud  rates.   WARNING:  if
you  set  this  to  "on" when your terminal doesn't have insert/delete
character capability, you will get weird (perhaps fatal) results.

:entry "version" "Command"
Displays the version number of this JOVE.

:entry "visible-bell" "Variable"
Use the terminal's visible bell instead of beeping.  This is  set  au-
tomatically if your terminal has the capability.

:entry "visible-spaces-in-window" "Command"
This displays an underscore character instead of  each  space  in  the
window  and displays a greater-than followed by spaces for each tab in
the window.  The actual text in the buffer is not  changed;  only  the
screen  display  is  affected.   To  turn this off you run the command
again; it toggles.

:entry "visit-file" "Command"
This reads a specified file into the current buffer replacing the  old
text.   If the buffer needs saving JOVE will offer to save it for you.
Sometimes you use this to start over, say if you make lots of  changes
and  then change your mind.  If that's the case you don't want JOVE to
save your buffer and you answer "NO" to the question.

:entry "window-find" "Command"
This lets you select another buffer in another window three  different
ways.   This  waits for another character which can be one of the fol-
lowing:

     T    Finds a tag in the other window.
     ^T   Finds the tag at point in the other window
     F    Finds a file in the other window.
     B    Selects a buffer in the other window.

This is just a convenient short hand for "C-X 2" (or "C-X O" if  there
are  already two windows) followed by the appropriate sequence for in-
voking each command.  With this, though, there isn't the  extra  over-
head  of  having  to redisplay.  In addition, you don't have to decide
whether to type "C-X 2" or "C-X O" since "C-X 4" does the right thing.

:entry "word-abbrev-mode" "Command"
This turns on Word Abbrev mode (or off if it's currently  on)  in  the
selected  buffer.  Word Abbrev mode lets you specify a word (an abbre-
viation) and a phrase with which JOVE should substitute the  abbrevia-
tion.   You  can use this to define words to expand into long phrases,
e.g., "jove" can expand into "Jonathan's Own Version of Emacs"; anoth-
er  common  use  is defining words that you often misspell in the same
way, e.g., "thier" => "their" or "teh" => "the".  See the  information
on the "auto-case-abbrev" variable.

There are two kinds of abbreviations: mode specific  and  global.   If
you define a Mode specific abbreviation in C mode, it will expand only
in buffers that are in C mode.  This is so you can have the  same  ab-
breviation expand to different things depending on your context.  Glo-
bal abbreviations expand regardless of the major mode of  the  buffer.
The way it works is this: JOVE looks first in the mode specific table,
and then in the global table.  Whichever it finds it in first  is  the
one  that's  used in the expansion.  If it doesn't find the word it is
left untouched. JOVE tries to expand words as they are typed, when you
type  a  punctuation character or Space or Return.  If you are in Auto
Fill mode the expansion will be filled as if you typed it yourself.

:entry "wrap-search" "Variable"
If set, searches will "wrap around" the ends of the buffer instead  of
stopping at the bottom or top.  The default is "off".

:entry "write-file" "Command"
This saves the current buffer to a specified file, and then makes that
file  the  default  file  name for this buffer.  If you specify a file
that already exists you are asked to confirm over-writing it.

:entry "write-files-on-make" "Variable"
When set, all modified files will be written out before  calling  make
when the "compile-it" command is executed.  The default is "on".

:entry "write-macros-to-file" "Command"
This writes the currently defined macros to a specified file in a for-
mat  appropriate  for  reading them back in with the "source" command.
The purpose of this command is to allow you to define macros once  and
use them in other instances of JOVE.

:entry "write-modified-files" "Command"
This saves all the buffers that need saving.  If you supply a  numeric
argument it asks for each buffer whether you really want to save it.

:entry "write-region" "Command"
This writes the text in the region to a specified file.  If  the  file
already exists you are asked to confirm over-writing it.

:entry "write-word-abbrev-file" "Command"
This writes the currently defined abbreviations to a  specified  file.
They  can  be  read back in and automatically defined with "read-word-
abbrev-file."

:entry "yank" "Command"
This undoes the last kill command.  That is,  it  inserts  the  killed
text  at point.  When you do multiple kill commands in a row, they are
merged so that yanking them back with "C-Y" yanks back all of them.

:entry "yank-pop" "Command"
This yanks back previous killed text.  JOVE has a kill ring  on  which
the  last 10 kills are stored.  "yank" yanks a copy of the text at the
front of the ring.  If you want one of the last ten kills you use "ESC
Y"  which  rotates  the  ring so another different entry is now at the
front.  You can use "ESC Y" only  immediately  following  a  "C-Y"  or
another  "ESC  Y".  If you supply a negative numeric argument the ring
is rotated the other way.  If you use this command enough times  in  a
row  you  will  eventually  get back to where you started.  Experiment
with this.  It's extremely useful.

























































