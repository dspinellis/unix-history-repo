Info file emacs, produced by texinfo-format-buffer   -*-Text-*-
from file emacs.tex

This file documents the GNU Emacs editor.

Copyright (C) 1985, 1986 Richard M. Stallman.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU Emacs
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU Emacs General Public License" may be included in a translation
approved by the author instead of in the original English.


File: emacs  Node: Shell, Prev: Sorting, Up: Top, Next: Hardcopy

Running Shell Commands from Emacs
=================================

  Emacs has commands for passing single command lines to inferior shell
processes; it can also run a shell interactively with input and output to
an Emacs buffer `*shell*'.

`M-!'     
     Run a specified shell command line and display the output
     (`shell-command').
`M-|'     
     Run a specified shell command line with region contents as input;
     optionally replace the region with the output
     (`shell-command-on-region').
`M-x shell'     
     Run a subshell with input and output through an Emacs buffer.
     You can then give commands interactively.

* Menu:

* Single Shell::         How to run one shell command and return.
* Interactive Shell::    Permanent shell taking input via Emacs.
* Shell Mode::           Special Emacs commands used with permanent shell.


File: emacs  Node: Single Shell, Prev: Shell, Up: Shell, Next: Interactive Shell

Single Shell Commands
---------------------

  `M-!' (`shell-command') reads a line of text using the
minibuffer and creates an inferior shell to execute the line as a command.
Standard input from the command comes from the null device.  If the shell
command produces any output, the output goes into an Emacs buffer named
`*Shell Command Output*', which is displayed in another window but not
selected.  A numeric argument, as in `M-1 M-!', directs this command to
insert any output into the current buffer.  In that case, point is left
before the output and the mark is set after the output.

  `M-|' (`shell-command-on-region') is like `M-!' but passes the contents
of the region as input to the shell command, instead of no input.  If a
numeric argument is used, meaning insert output in the current buffer, then
the old region is deleted first and the output replaces it as the contents
of the region.

  Both `M-!' and `M-|' use `shell-file-name' to specify the shell to use.
This variable is initialized based on your `SHELL' environment variable
when Emacs is started.  If the file name does not specify a directory, the
directories in the list `exec-path' are searched; this list is initialized
based on the environment variable `PATH' when Emacs is started.  Your
`.emacs' file can override either or both of these default initializations.

  With `M-!' and `M-|', Emacs has to wait until the shell command
completes.  You can quit with `C-g'; that terminates the shell command.


File: emacs  Node: Interactive Shell, Prev: Single Shell, Up: Shell, Next: Shell Mode

Interactive Inferior Shell
--------------------------

  To run a subshell interactively, putting its typescript in an Emacs
buffer, use `M-x shell'.  This creates (or reuses) a buffer named
`*shell*' and runs a subshell with input coming from and output going
to that buffer.  That is to say, any "terminal output" from the subshell
will go into the buffer, advancing point, and any "terminal input" for
the subshell comes from text in the buffer.  To give input to the subshell,
go to the end of the buffer and type the input, terminated by RET.

  Emacs does not wait for the subshell to do anything.  You can switch
windows or buffers and edit them while the shell is waiting, or while it is
running a command.  Output from the subshell waits until Emacs has time to
process it; this happens whenever Emacs is waiting for keyboard input or
for time to elapse.

  If you would like multiple subshells, change the name of buffer
`*shell*' to something different by using `M-x rename-buffer'.  The
next use of `M-x shell' will create a new buffer `*shell*' with
its own subshell.  By renaming this buffer as well you can create a third
one, and so on.  All the subshells run independently and in parallel.

  The file name used to load the subshell is the value of the variable
`explicit-shell-file-name', if that is non-`nil'.  Otherwise, the
environment variable `ESHELL' is used, or the environment variable `SHELL'
if there is no `ESHELL'.  If the file name specified is relative, the
directories in the list `exec-path' are searched (*Note Single Shell
Commands: Single Shell.).

  As soon as the subshell is started, it is sent as input the contents of
the file `~/.emacs_SHELLNAME', if that file exists, where SHELLNAME is the
name of the file that the shell was loaded from.  For example, if you use
`csh', the file sent to it is `~/.emacs_csh'.

  `cd', `pushd' and `popd' commands given to the inferior shell are watched
by Emacs so it can keep the `*shell*' buffer's default directory the same
as the shell's working directory.  These commands are recognized
syntactically by examining lines of input that are sent.  If you use
aliases for these commands, you can tell Emacs to recognize them also.  For
example, if the value of the variable `shell-pushd-regexp' matches the
beginning of a shell command line, that line is regarded as a `pushd'
command.  Change this variable when you add aliases for `pushd'.  Likewise,
`shell-popd-regexp' and `shell-cd-regexp' are used to recognize commands
with the meaning of `popd' and `cd'.  These commands are recognized only at
the beginning of a shell command line.

  If Emacs gets an error while trying to handle what it believes is a `cd',
`pushd' or `popd' command, and the value of
`shell-set-directory-error-hook' is non-`nil', that value is called as a
function with no arguments.


File: emacs  Node: Shell Mode, Prev: Interactive Shell, Up: Shell

Shell Mode
----------

  The shell buffer uses Shell mode, which defines several special keys
attached to the `C-c' prefix.  They are chosen to resemble the usual
editing and job control characters present in shells that are not under
Emacs, except that you must type `C-c' first.  Here is a complete list
of the special key bindings of Shell mode:

`RET'     
     At end of buffer send line as input; otherwise, copy current line to end of
     buffer and send it (`send-shell-input').  When a line is copied, any
     text at the beginning of the line that matches the variable
     `shell-prompt-pattern' is left out; this variable's value should be a
     regexp string that matches the prompts that you use in your subshell.
`C-c C-d'     
     Send end-of-file as input, probably causing the shell or its current
     subjob to finish (`shell-send-eof').
`C-c C-u'     
     Kill all text that has yet to be sent as input (`kill-shell-input').
`C-c C-w'     
     Kill a word before point (`backward-kill-word').
`C-c C-c'     
     Interrupt the shell or its current subjob if any
     (`interrupt-shell-subjob').
`C-c C-z'     
     Stop the shell or its current subjob if any (`stop-shell-subjob').
`C-c C-\'     
     Send quit signal to the shell or its current subjob if any
     (`quit-shell-subjob').
`C-c C-o'     
     Delete last batch of output from shell (`kill-output-from-shell').
`C-c C-r'     
     Scroll top of last batch of output to top of window
     (`show-output-from-shell').
`C-c C-y'     
     Copy the previous bunch of shell input, and insert it into the
     buffer before point (`copy-last-shell-input').  No final newline
     is inserted, and the input copied is not resubmitted until you type
     RET.


File: emacs  Node: Hardcopy, Prev: Shell, Up: Top, Next: Dissociated Press

Hardcopy Output
===============

  The Emacs commands for making hardcopy derive their names from the
Unix commands `print' and `lpr'.

`M-x print-buffer'     
     Print hardcopy of current buffer using Unix command `print'
     (`lpr -p').  This makes page headings containing the file name
     and page number.
`M-x lpr-buffer'     
     Print hardcopy of current buffer using Unix command `lpr'.
     This makes no page headings.
`M-x print-region'     
     Like `print-buffer' but prints only the current region.
`M-x lpr-region'     
     Like `lpr-buffer' but prints only the current region.

  All the hardcopy commands pass extra switches to the `lpr' program
based on the value of the variable `lpr-switches'.  Its value should
be a list of strings, each string a switch starting with `-'.  For
example, the value could be `("-Pfoo")' to print on printer
`foo'.


File: emacs  Node: Dissociated Press, Prev: Hardcopy, Up: Top, Next: Amusements

Dissociated Press
=================

  `M-x dissociated-press' is a command for scrambling a file of text
either word by word or character by character.  Starting from a buffer of
straight English, it produces extremely amusing output.  The input comes
from the current Emacs buffer.  Dissociated Press writes its output in a
buffer named `*Dissociation*', and redisplays that buffer after every
couple of lines (approximately) to facilitate reading it.

  `dissociated-press' asks every so often whether to continue
operating.  Answer `n' to stop it.  You can also stop at any time by
typing `C-g'.  The dissociation output remains in the `*Dissociation*'
buffer for you to copy elsewhere if you wish.

  Dissociated Press operates by jumping at random from one point in the
buffer to another.  In order to produce plausible output rather than
gibberish, it insists on a certain amount of overlap between the end of one
run of consecutive words or characters and the start of the next.  That is,
if it has just printed out `president' and then decides to jump to a
different point in the file, it might spot the `ent' in `pentagon' and
continue from there, producing `presidentagon'.  Long sample texts produce
the best results.

  A positive argument to `M-x dissociated-press' tells it to operate
character by character, and specifies the number of overlap characters.  A
negative argument tells it to operate word by word and specifies the number
of overlap words.  In this mode, whole words are treated as the elements to
be permuted, rather than characters.  No argument is equivalent to an
argument of two.  For your againformation, the output goes only into the
buffer `*Dissociation*'.  The buffer you start with is not changed.

  Dissociated Press produces nearly the same results as a Markov chain
based on a frequency table constructed from the sample text.  It is,
however, an independent, ignoriginal invention.  Dissociated Press
techniquitously copies several consecutive characters from the sample
between random choices, whereas a Markov chain would choose randomly for
each word or character.  This makes for more plausible sounding results,
and runs faster.

  It is a mustatement that too much use of Dissociated Press can be a
developediment to your real work.  Sometimes to the point of outragedy.
And keep dissociwords out of your documentation, if you want it to be well
userenced and properbose.  Have fun.  Your buggestions are welcome.


File: emacs  Node: Amusements, Prev: Dissociated Press, Up: Top, Next: Emulation

Other Amusements
================

  If you are a little bit bored, you can try `M-x hanoi'.  If you are
considerably bored, give it a numeric argument.  If you are very very
bored, try an argument of 9.  Sit back and watch.

  When you are frustrated, try the famous Eliza program.  Just do
`M-x doctor'.  End each input by typing `RET' twice.

  When you are feeling strange, type `M-x yow'.


File: emacs  Node: Emulation, Prev: Amusements, Up: Top, Next: Customization

Emulation
=========

  GNU Emacs can be programmed to emulate (more or less) most other
editors.  Standard facilities can emulate these:

EDT (DEC VMS editor)     
     Turn on EDT emulation with `M-x edt-emulation-on'.  `M-x
     edt-emulation-off' restores normal Emacs command bindings.
     
     Most of the EDT emulation commands are keypad keys, and most standard Emacs
     key bindings are still available.  The EDT emulation rebindings are done in
     the global keymap, so there is no problem switching buffers or major modes
     while in EDT emulation.
     
Gosling Emacs     
     Turn on emulation of Gosling Emacs (aka Unipress Emacs) with `M-x
     set-gosmacs-bindings'.  This redefines many keys, mostly on the
     `C-x' and `ESC' prefixes, to work as they do in Gosmacs.
     `M-x set-gnu-bindings' returns to normal GNU Emacs by rebinding
     the same keys to the definitions they had at the time `M-x
     set-gosmacs-bindings' was done.
     
     It is also possible to run Mocklisp code written for Gosling Emacs.
     *Note Mocklisp::.
     
vi (Berkeley Unix editor)     
     Turn on vi emulation with `M-x vi-mode'.  This is a major mode
     that replaces the previously established major mode.  All of the
     vi commands that, in real vi, enter "input" mode are programmed
     in the Emacs emulator to return to the previous major mode.  Thus,
     ordinary Emacs serves as vi's "input" mode.
     
     Because vi emulation works through major modes, it does not work
     to switch buffers during emulation.  Return to normal Emacs first.
     
     If you plan to use vi emulation much, you probably want to bind a key
     to the `vi-mode' command.
     
vi (alternate emulator)     
     Another vi emulator said to resemble real vi more thoroughly is
     invoked by `M-x vip-mode'.  "Input" mode in this emulator is
     changed from ordinary Emacs so you can use ESC to go back to
     emulated vi command mode.  To get from emulated vi command mode back
     to ordinary Emacs, type `C-z'.
     
     This emulation does not work through major modes, and it is possible
     to switch buffers in various ways within the emulator.  It is not
     so necessary to assign a key to the command `vip-mode' as
     it is with `vi-mode' because terminating insert mode does
     not use it.
     
     For full information, see the long comment at the beginning of the
     source file, which is `lisp/vip.el' in the Emacs distribution.

I am interested in hearing which vi emulator users prefer, as well as in
receiving more complete user documentation for either or both emulators.
Warning: loading both at once may cause name conficts; no one has checked.


File: emacs  Node: Customization, Prev: Emulation, Up: Top, Next: Quitting

Customization
*************

  This chapter talks about various topics relevant to adapting the
behavior of Emacs in minor ways.

  All kinds of customization affect only the particular Emacs job that you
do them in.  They are completely lost when you kill the Emacs job, and have
no effect on other Emacs jobs you may run at the same time or later.  The
only way an Emacs job can affect anything outside of it is by writing a
file; in particular, the only way to make a customization `permanent' is to
put something in your `.emacs' file or other appropriate file to do the
customization in each session.  *Note Init File::.

* Menu:

* Minor Modes::     Each minor mode is one feature you can turn on
                     independently of any others.
* Variables::       Many Emacs commands examine Emacs variables
                     to decide what to do; by setting variables,
                     you can control their functioning.
* Keyboard Macros:: A keyboard macro records a sequence of keystrokes
                     to be replayed with a single command.
* Key Bindings::    The keymaps say what command each key runs.
                     By changing them, you can "redefine keys".
* Syntax::          The syntax table controls how words and expressions
                     are parsed.
* Init File::       How to write common customizations in the `.emacs' file.


File: emacs  Node: Minor Modes, Prev: Customization, Up: Customization, Next: Variables

Minor Modes
===========

  Minor modes are options which you can use or not.  For example, Auto Fill
mode is a minor mode in which SPC breaks lines between words as you
type.  All the minor modes are independent of each other and of the
selected major mode.  Most minor modes say in the mode line when they are
on; for example, `Fill' in the mode line means that Auto Fill mode is
on.

  Append `-mode' to the name of a minor mode to get the name of a
command function that turns the mode on or off.  Thus, the command to
enable or disable Auto Fill mode is called `M-x auto-fill-mode'.  These
commands are usually invoked with `M-x', but you can bind keys to them
if you wish.  With no argument, the function turns the mode on if it was
off and off if it was on.  This is known as "toggling".  A positive
argument always turns the mode on, and an explicit zero argument or a
negative argument always turns it off.

  Auto Fill mode allows you to enter filled text without breaking lines
explicitly.  Emacs inserts newlines as necessary to prevent lines from
becoming too long.  *Note Filling::.

  Overwrite mode causes ordinary printing characters to replace existing
text instead of shoving it over.  For example, if the point is in front of
the `B' in `FOOBAR', then in Overwrite mode typing a `G' changes it to
`FOOGAR', instead of making it `FOOGBAR' as usual.

  Abbrev mode allows you to define abbreviations that automatically expand
as you type them.  For example, `amd' might expand to `abbrev
mode'.  *Note Abbrevs::, for full information.


File: emacs  Node: Variables, Prev: Minor Modes, Up: Customization, Next: Keyboard Macros

Variables
=========

  A "variable" is a Lisp symbol which has a value.  The symbol's name
is also called the name of the variable.  Variable names can contain any
characters, but conventionally they are chosen to be words separated by
hyphens.  A variable can have a documentation string which describes what
kind of value it should have and how the value will be used.

  Lisp allows any variable to have any kind of value, but most variables
that Emacs uses require a value of a certain type.  Often the value should
always be a string, or should always be a number.  Sometimes we say that a
certain feature is turned on if a variable is "non-`nil'," meaning
that if the variable's value is `nil', the feature is off, but the
feature is on for any other value.  The conventional value to use to
turn on the feature---since you have to pick one particular value when you
set the variable---is `t'.

  Emacs uses many Lisp variables for internal recordkeeping, as any Lisp
program must, but the most interesting variables for you are the ones that
exist for the sake of customization.  Emacs does not (usually) change the
values of these variables; instead, you set the values, and thereby alter
and control the behavior of certain Emacs commands.  These variables are
called "options".  Most options are documented in this manual, and
appear in the Variable Index (*Note Variable Index::).

  One example of a variable which is an option is `fill-column', which
specifies the position of the right margin (as a number of characters from
the left margin) to be used by the fill commands (*Note Filling::).

* Menu:

* Examining::           Examining or setting one variable's value.
* Edit Options::        Examining or editing list of all variables' values.
* Locals::              Per-buffer values of variables.
* File Variables::      How files can specify variable values.


File: emacs  Node: Examining, Prev: Variables, Up: Variables, Next: Edit Options

Examining and Setting Variables
-------------------------------

`C-h v'     
`M-x describe-variable'     
     Print the value and documentation of a variable.
`M-x set-variable'     
     Change the value of a variable.

  To examine the value of a single variable, use `C-h v'
(`describe-variable'), which reads a variable name using the
minibuffer, with completion.  It prints both the value and the
documentation of the variable.

     C-h v fill-column RET
prints something like
     fill-column's value is 75
     
     Documentation:
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes local when set in any fashion.

The star at the beginning of the documentation indicates that this variable
is an option.  `C-h v' is not restricted to options; it allows any
variable name.

  If you know which option you want to set, you can set it using `M-x
set-variable'.  This reads the variable name with the minibuffer (with
completion), and then reads a Lisp expression for the new value using the
minibuffer a second time.  For example,

     M-x set-variable RET fill-column RET 75 RET

sets `fill-column' to 75, like executing the Lisp expression

     (setq fill-column 75)

  Setting variables in this way, like all means of customizing Emacs
except where explicitly stated, affects only the current Emacs session.


File: emacs  Node: Edit Options, Prev: Examining, Up: Variables, Next: Locals

Editing Variable Values
-----------------------

`M-x list-options'     
     Display a buffer listing names, values and documentation of all options.
`M-x edit-options'     
     Change option values by editing a list of options.

  `M-x list-options' displays a list of all Emacs option variables, in
an Emacs buffer named `*List Options*'.  Each option is shown with its
documentation and its current value.  Here is what a portion of it might
look like:

     ;; exec-path:
     ("." "/usr/local/bin" "/usr/ucb" "/bin" "/usr/bin" "/u2/emacs/etc")
     *List of directories to search programs to run in subprocesses.
     Each element is a string (directory name)
     or nil (try the default directory).
     ;;
     ;; fill-column:
     75
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes local when set in any fashion.
     ;;

  `M-x edit-options' goes one step further and immediately selects the
`*List Options*' buffer; this buffer uses the major mode Options mode,
which provides commands that allow you to point at an option and change its
value:

`s'     
     Set the variable point is in or near to a new value read using the
     minibuffer.
`x'     
     Toggle the variable point is in or near: if the value was `nil',
     it becomes `t'; otherwise it becomes `nil'.
`1'     
     Set the variable point is in or near to `t'.
`0'     
     Set the variable point is in or near to `nil'.
`n'     
`p'     
     Move to the next or previous variable.


File: emacs  Node: Locals, Prev: Edit Options, Up: Variables, Next: File Variables

Local Variables
---------------

`M-x make-local-variable'     
     Make a variable have a local value in the current buffer.
`M-x kill-local-variable'     
     Make a variable use its global value in the current buffer.
`M-x make-variable-buffer-local'     
     Mark a variable so that setting it will make it local to the
     buffer that is current at that time.

  Any variable can be made "local" to a specific Emacs buffer.  This
means that its value in that buffer is independent of its value in other
buffers.  A few variables are always local in every buffer.  Every other
Emacs variable has a "global" value which is in effect in all buffers
that have not made the variable local.

  Major modes always make the variables they set local to the buffer.
This is why changing major modes in one buffer has no effect on other
buffers.

  `M-x make-local-variable' reads the name of a variable and makes it
local to the current buffer.  Further changes in this buffer will not
affect others, and further changes in the global value will not affect this
buffer.

  `M-x make-variable-buffer-local' reads the name of a variable and
changes the future behavior of the variable so that it will become local
automatically when it is set.  More precisely, once a variable has been
marked in this way, the usual ways of setting the variable will
automatically do `make-local-variable' first.  We call such variables
"per-buffer" variables.

  Some important variables have been marked per-buffer already.  These
include `abbrev-mode', `auto-fill-hook', `case-fold-search',
`comment-column', `ctl-arrow', `fill-column', `fill-prefix',
`indent-tabs-mode', `left-margin', `mode-line-format', `overwrite-mode',
`selective-display-ellipses', `selective-display', `tab-width', and
`truncate-lines'.  Some other variables are always local in every buffer,
but they are used for internal purposes.

  `M-x kill-local-variable' reads the name of a variable and makes it
cease to be local to the current buffer.  The global value of the variable
henceforth is in effect in this buffer.  Setting the major mode kills all
the local variables of the buffer.

  To set the global value of a variable, regardless of whether the
variable has a local value in the current buffer, you can use the
Lisp function `setq-default'.  It works like `setq'.
If there is a local value in the current buffer, the local value is
not affected by `setq-default'; thus, the new global value may
not be visible until you switch to another buffer.  For example,

     (setq-default fill-column 75)

`setq-default' is the only way to set the global value of a variable
that has been marked with `make-variable-buffer-local'.

  Programs can look at a variable's default value with `default-value'.
This function takes a symbol as argument and returns its default value.
The argument is evaluated; usually you must quote it explicitly.  For
example,

     (default-value 'fill-column)


File: emacs  Node: File Variables, Prev: Locals, Up: Variables

Local Variables in Files
------------------------

  A file can contain a "local variables list", which specifies the
values to use for certain Emacs variables when that file is edited.
Visiting the file checks for a local variables list and makes each variable
in the list local to the buffer in which the file is visited, with the
value specified in the file.

  A local variables list goes near the end of the file, in the last page.
(It is often best to put it on a page by itself.)  The local variables list
starts with a line containing the string `Local Variables:', and ends
with a line containing the string `End:'.  In between come the
variable names and values, one set per line, as `VARIABLE:
VALUE'.  The VALUEs are not evaluated; they are used literally.

  The line which starts the local variables list does not have to say just
`Local Variables:'.  If there is other text before `Local Variables:', that
text is called the "prefix", and if there is other text after, that is
called the "suffix".  If these are present, each entry in the local
variables list should have the prefix before it and the suffix after it.
This includes the `End:' line.  The prefix and suffix are included to
disguise the local variables list as a comment so that the compiler or text
formatter will not be perplexed by it.  If you do not need to disguise the
local variables list as a comment in this way, do not bother with a prefix
or a suffix.

  Two "variable" names are special in a local variables list: a value for
the variable `mode' really sets the major mode, and a value for the
variable `eval' is simply evaluated as an expression and the value is
ignored.  These are not real variables; setting such variables in any other
context has no such effect.  If `mode' is used in a local variables
list, it should be the first entry in the list.

Here is an example of a local variables list:
     ;;; Local Variables: ***
     ;;; mode:lisp ***
     ;;; comment-column:0 ***
     ;;; comment-start: ";;; "  ***
     ;;; comment-end:"***" ***
     ;;; End: ***

  Note that the prefix is `;;; ' and the suffix is ` ***'.  Note also
that comments in the file begin with and end with the same strings.
Presumably the file contains code in a language which is like Lisp
(like it enough for Lisp mode to be useful) but in which comments start
and end in that way.  The prefix and suffix are used in the local
variables list to make the list appear as comments when the file is read
by the compiler or interpreter for that	language.

  The start of the local variables list must be no more than 3000
characters from the end of the file, and must be in the last page if the
file is divided into pages.  Otherwise, Emacs will not notice it is there.
The purpose of this is so that a stray `Local Variables:' not in the
last page does not confuse Emacs, and so that visiting a long file that is
all one page and has no local variables list need not take the time to
search the whole file.

  You may be tempted to try to turn on Auto Fill mode with a local variable
list.  That is a mistake.  The choice of Auto Fill mode or not is a matter
of individual taste, not a matter of the contents of particular files.
If you want to use Auto Fill, set up major mode hooks with your `.emacs'
file to turn it on (when appropriate) for you alone (*Note Init File::).
Don't try to use a local variable list that would impose your taste on
everyone.


File: emacs  Node: Keyboard Macros, Prev: Variables, Up: Customization, Next: Key Bindings

Keyboard Macros
===============

  A "keyboard macro" is a command defined by the user to abbreviate a
sequence of keys.  For example, if you discover that you are about to type
`C-n C-d' forty times, you can speed your work by defining a keyboard
macro to do `C-n C-d' and calling it with a repeat count of forty.

`C-x ('     
     Start defining a keyboard macro (`start-kbd-macro').
`C-x )'     
     End the definition of a keyboard macro (`end-kbd-macro').
`C-x e'     
     Execute the most recent keyboard macro (`call-last-kbd-macro').
`C-u C-x ('     
     Re-execute last keyboard macro, then add more keys to its definition.
`C-x q'     
     When this point is reached during macro execution, ask for confirmation
     (`kbd-macro-query').
`M-x name-last-kbd-macro'     
     Give a command name (for the duration of the session) to the most
     recently defined keyboard macro.
`M-x insert-kbd-macro'     
     Insert in the buffer a keyboard macro's definition, as Lisp code.

  Keyboard macros differ from ordinary Emacs commands in that they are
written in the Emacs command language rather than in Lisp.  This makes it
easier for the novice to write them, and makes them more convenient as
temporary hacks.  However, the Emacs command language is not powerful
enough as a programming language to be useful for writing anything
intelligent or general.  For such things, Lisp must be used.

  You define a keyboard macro while executing the commands which are the
definition.  Put differently, as you are defining a keyboard macro, the
definition is being executed for the first time.  This way, you can see
what the effects of your commands are, so that you don't have to figure
them out in your head.  When you are finished, the keyboard macro is
defined and also has been, in effect, executed once.  You can then do the
whole thing over again by invoking the macro.

* Menu:

* Basic Kbd Macro::     Defining and running keyboard macros.
* Save Kbd Macro::      Giving keyboard macros names; saving them in files.
* Kbd Macro Query::     Keyboard macros that do different things each use.


File: emacs  Node: Basic Kbd Macro, Prev: Keyboard Macros, Up: Keyboard Macros, Next: Save Kbd Macro

Basic Use
---------

  To start defining a keyboard macro, type the `C-x (' command
(`start-kbd-macro').  From then on, your keys continue to be
executed, but also become part of the definition of the macro.  `Def'
appears in the mode line to remind you of what is going on.  When you are
finished, the `C-x )' command (`end-kbd-macro') terminates the
definition (without becoming part of it!).  For example

     C-x ( M-F foo C-x )

defines a macro to move forward a word and then insert `foo'.

  The macro thus defined can be invoked again with the `C-x e' command
(`call-last-kbd-macro'), which may be given a repeat count as a
numeric argument to execute the macro many times.  `C-x )' can also be
given a repeat count as an argument, in which case it repeats the macro
that many times right after defining it, but defining the macro counts as
the first repetition (since it is executed as you define it).  So, giving
`C-x )' an argument of 4 executes the macro immediately 3 additional
times.  An argument of zero to `C-x e' or `C-x )' means repeat the
macro indefinitely (until it gets an error or you type `C-g').

  If you wish to repeat an operation at regularly spaced places in the
text, define a macro and include as part of the macro the commands to move
to the next place you want to use it.  For example, if you want to change
each line, you should position point at the start of a line, and define a
macro to change that line and leave point at the start of the next line.
Then repeating the macro will operate on successive lines.

  After you have terminated the definition of a keyboard macro, you can add
to the end of its definition by typing `C-u C-x ('.  This is equivalent
to plain `C-x (' followed by retyping the whole definition so far.  As
a consequence it re-executes the macro as previously defined.


File: emacs  Node: Save Kbd Macro, Prev: Basic Kbd Macro, Up: Keyboard Macros, Next: Kbd Macro Query

Naming and Saving Keyboard Macros
---------------------------------

  If you wish to save a keyboard macro for longer than until you define the
next one, you must give it a name using `M-x name-last-kbd-macro'.
This reads a name as an argument using the minibuffer and defines that name
to execute the macro.  The macro name is a Lisp symbol, and defining it in
this way makes it a valid command name for calling with `M-x' or for
binding a key to with `global-set-key' (*Note Keymaps::).  If you
specify a name that has a prior definition other than another keyboard
macro, an error message is printed and nothing is changed.

  Once a macro has a command name, you can save its definition in a file.
Then it can be used in another editing session.  First visit the file
you want to save the definition in.  Then use the command

     M-x insert-kbd-macro RET MACRONAME RET

This inserts some Lisp code that, when executed later, will define the same
macro with the same definition it has now.  You need not understand Lisp
code to do this, because `insert-kbd-macro' writes the Lisp code for you.
Then save the file.  The file can be loaded with `load-file'
(*Note Lisp Libraries::).  If the file you save in is your init file
`~/.emacs' (*Note Init File::) then the macro will be defined each
time you run Emacs.

  If you give `insert-kbd-macro' a prefix argument, it makes
additional Lisp code to record the keys (if any) that you have bound to the
keyboard macro, so that the macro will be reassigned the same keys when you
load the file.


File: emacs  Node: Kbd Macro Query, Prev: Save Kbd Macro, Up: Keyboard Macros

Executing Macros with Variations
--------------------------------

  Using `C-x q' (`kbd-macro-query'), you can get an effect similar
to that of `query-replace', where the macro asks you each time around
whether to make a change.  When you are defining the macro, type `C-x
q' at the point where you want the query to occur.  During macro
definition, the `C-x q' does nothing, but when the macro is invoked the
`C-x q' reads a character from the terminal to decide whether to
continue.

  The special answers are SPC, DEL, `C-d', `C-l' and `C-r'.  Any other
character terminates execution of the keyboard macro and is then read as a
command.  SPC means to continue.  DEL means to skip the remainder of this
repetition of the macro, starting again from the beginning in the next
repetition.  `C-d' means to skip the remainder of this repetition and
cancel further repetition.  `C-l' redraws the screen and asks you again for
a character to say what to do.  `C-r' enters a recursive editing level, in
which you can perform editing which is not part of the macro.  When you
exit the recursive edit using `C-M-c', you are asked again how to continue
with the keyboard macro.  If you type a SPC at this time, the rest of the
macro definition is executed.  It is up to you to leave point and the text
in a state such that the rest of the macro will do what you want.

  `C-u C-x q', which is `C-x q' with a numeric argument, performs a
different function.  It enters a recursive edit reading input from the
keyboard, both when you type it during the definition of the macro, and
when it is executed from the macro.  During definition, the editing you do
inside the recursive edit does not become part of the macro.  During macro
execution, the recursive edit gives you a chance to do some particularized
editing.  *Note Recursive Edit::.


File: emacs  Node: Key Bindings, Prev: Keyboard Macros, Up: Customization, Next: Syntax

Customizing Key Bindings
========================

  This section deals with the "keymaps" which define the bindings
between keys and functions, and shows how you can customize these bindings.

  A command is a Lisp function whose definition provides for interactive
use.  Like every Lisp function, a command has a function name, a Lisp
symbol whose name usually consists of lower case letters and hyphens.

* Menu:

* Keymaps::    Definition of the keymap data structure.
               Names of Emacs's standard keymaps.
* Rebinding::  How to redefine one key's meaning conveniently.
* Disabling::  Disabling a command means confirmation is required
                before it can be executed.  This is done to protect
                beginners from surprises.


File: emacs  Node: Keymaps, Prev: Key Bindings, Up: Key Bindings, Next: Rebinding

Keymaps
-------

  The bindings between characters and command functions are recorded in
data structures called "keymaps".  Emacs has many of these.  One, the
"global" keymap, defines the meanings of the single-character keys that
are defined regardless of major mode.  It is the value of the variable
`global-map'.

  Each major mode has another keymap, its "local keymap", which
contains overriding definitions for the single-character keys that are to
be redefined in that mode.  Each buffer records which local keymap is
installed for it at any time, and the current buffer's local keymap is the
only one that directly affects command execution.  The local keymaps for
Lisp mode, C mode, and many other major modes always exist even when not in
use.  They are the values of the variables `lisp-mode-map',
`c-mode-map', and so on.  For major modes less often used, the local
keymap is sometimes constructed only when the mode is used for the first
time in a session.  This is to save space.

  There are local keymaps for the minibuffer too; they contain various
completion and exit commands.

   * `minibuffer-local-map' is used for ordinary input (no completion).
   * `minibuffer-local-ns-map' is similar, except that SPC exits
     just like RET.  This is used mainly for Mocklisp compatibility.
   * `minibuffer-local-completion-map' is for permissive completion.
   * `minibuffer-local-must-match-map' is for strict completion and
     for cautious completion.
   * `repeat-complex-command-map' is for use in `C-x ESC'.

  Finally, each prefix key has a keymap which defines the key sequences
that start with it.  For example, `ctl-x-map' is the keymap used for
characters following a `C-x'.

   * `ctl-x-map' is the variable name for the map used for characters that
     follow `C-x'.
   * `help-map' is used for characters that follow `C-h'.
   * `esc-map' is for characters that follow ESC.  Thus, all Meta
     characters are actually defined by this map.
   * `ctl-x-4-map' is for characters that follow `C-x 4'.
   * `mode-specific-map' is for characters that follow `C-c'.

  The definition of a prefix key is just the keymap to use for looking up
the following character.  Actually, the definition is sometimes a Lisp
symbol whose function definition is the following character keymap.  The
effect is the same, but it provides a command name for the prefix key that
can be used as a description of what the prefix key is for.  Thus, the
binding of `C-x' is the symbol `Ctl-X-Prefix', whose function definition is
the keymap for `C-x' commands, the value of `ctl-x-map'.

  Prefix key definitions of this sort can appear in either the global map
or a local map.  The definitions of `C-c', `C-x', `C-h' and ESC as prefix
keys appear in the global map, so these prefix keys are always available.
Major modes can locally redefine a key as a prefix by putting a prefix key
definition for it in the local map.

  A mode can also put a prefix definition of a global prefix character such
as `C-x' into its local map.  This is how major modes override the
definitions of certain keys that start with `C-x'.  This case is special,
because the local definition does not entirely replace the global one.
When both the global and local definitions of a key are other keymaps, the
next character is looked up in both keymaps, with the local definition
overriding the global one as usual.  So, the character after the `C-x' is
looked up in both the major mode's own keymap for redefined `C-x' commands
and in `ctl-x-map'.  If the major mode's own keymap for `C-x' commands
contains `nil', the definition from the global keymap for `C-x' commands is
used.

  A keymap is actually a Lisp object.  The simplest form of keymap is a
Lisp vector of length 128.  The binding for a character in such a keymap is
found by indexing into the vector with the character as an index.  A keymap
can also be a Lisp list whose car is the symbol `keymap' and whose
remaining elements are pairs of the form `(CHAR . BINDING)'.
Such lists are called "sparse keymaps" because they are used when most
of the characters' entries will be `nil'.  Sparse keymaps are used
mainly for prefix characters.

  Keymaps are only of length 128, so what about Meta characters, whose
codes are from 128 to 255?  A key that contains a Meta character actually
represents it as a sequence of two characters, the first of which is ESC.
So the key `M-a' is really represented as `ESC a', and its binding is found
at the slot for `a' in `esc-map'.


File: emacs  Node: Rebinding, Prev: Keymaps, Up: Key Bindings, Next: Disabling

Changing Key Bindings Interactively
-----------------------------------

  The way to redefine an Emacs key is to change its entry in a keymap.
You can change the global keymap, in which case the change is effective in
all major modes (except those that have their own overriding local
definitions for the same key).  Or you can change the current buffer's
local map, which affects all buffers using the same major mode.

`M-x global-set-key RET KEY CMD RET'     
     Defines KEY globally to run CMD.
`M-x local-set-key RET KEY CMD RET'     
     Defines KEY locally (in the major mode now in effect) to run
     CMD.

  For example,

     M-x global-set-key RET C-f next-line RET

would redefine `C-f' to move down a line.  The fact that CMD is
read second makes it serve as a kind of confirmation for KEY.

  These functions offer no way to specify a particular prefix keymap as the
one to redefine in, but that is not necessary, as you can include prefixes
in KEY.  KEY is read by reading characters one by one until they amount to
a complete key (that is, not a prefix key).  Thus, if you type `C-f' for
KEY, that's the end; the minibuffer is entered immediately to read CMD.
But if you type `C-x', another character is read; if that is `4', another
character is read, and so on.  For example,

     M-x global-set-key RET C-x 4 $ spell-other-window RET

would redefine `C-x 4 $' to run the (fictitious) command
`spell-other-window'.

  The most general way to modify a keymap is the function `define-key',
used in Lisp code (such as your `.emacs' file).  `define-key'
takes three arguments: the keymap, the key to modify in it, and the new
definition.  *Note Init File::, for an example.  `substitute-key-definition'
is used similarly; it takes three arguments, an old definition, a new
definition and a keymap, and redefines in that keymap all keys that were
previously defined with the old definition to have the new definition
instead.


File: emacs  Node: Disabling, Prev: Rebinding, Up: Key Bindings

Disabling Commands
------------------

  Disabling a command marks the command as requiring confirmation before it
can be executed.  The purpose of disabling a command is to prevent
beginning users from executing it by accident and being confused.

  The direct mechanism for disabling a command is to have a non-`nil'
`disabled' property on the Lisp symbol for the command.  These
properties are normally set up by the user's `.emacs' file with
Lisp expressions such as

     (put 'delete-region 'disabled t)

  If the value of the `disabled' property is a string, that string
is included in the message printed when the command is used:

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

  You can make a command disabled either by editing the `.emacs' file
directly or with the command `M-x disable-command', which edits the
`.emacs' file for you.  *Note Init File::.

  Attempting to invoke a disabled command interactively in Emacs causes the
display of a window containing the command's name, its documentation, and
some instructions on what to do immediately; then Emacs asks for input
saying whether to execute the command as requested, enable it and execute,
or cancel it.  If you decide to enable the command, you are asked whether to
do this permanently or just for the current session.  Enabling permanently
works by automatically editing your `.emacs' file.  You can use
`M-x enable-command' at any time to enable any command permanently.

  Whether a command is disabled is independent of what key is used to
invoke it; it also applies if the command is invoked using `M-x'.
Disabling a command has no effect on calling it as a function from Lisp
programs.


File: emacs  Node: Syntax, Prev: Key Bindings, Up: Customization, Next: Init File

The Syntax Table
================

  All the Emacs commands which parse words or balance parentheses are
controlled by the "syntax table".  The syntax table says which
characters are opening delimiters, which are parts of words, which are
string quotes, and so on.  Actually, each major mode has its own syntax
table (though sometimes related major modes use the same one) which it
installs in each buffer that uses that major mode.  The syntax table
installed in the current buffer is the one that all commands use, so we
call it "the" syntax table.  A syntax table is a Lisp object, a vector of
length 256 whose elements are numbers.

* Menu:

* Entry: Syntax Entry.    What the syntax table records for each character.
* Change: Syntax Change.  How to change the information.


File: emacs  Node: Syntax Entry, Prev: Syntax, Up: Syntax, Next: Syntax Change

Information about Each Character
--------------------------------

  The syntax table entry for a character is a number that encodes six
pieces of information:

   * The syntactic class of the character, represented as a small integer.
   * The matching delimiter, for delimiter characters only.
     The matching delimiter of `(' is `)', and vice versa.
   * A flag saying whether the character is the first character of a
     two-character comment starting sequence.
   * A flag saying whether the character is the second character of a
     two-character comment starting sequence.
   * A flag saying whether the character is the first character of a
     two-character comment ending sequence.
   * A flag saying whether the character is the second character of a
     two-character comment ending sequence.

  The syntactic classes are stored internally as small integers, but are
usually described to or by the user with characters.  For example, `('
is used to specify the syntactic class of opening delimiters.  Here is a
table of syntactic classes, with the characters that specify them.

` '     
     The class of whitespace characters.
`w'     
     The class of word-constituent characters.
`_'     
     The class of characters that are part of symbol names but not words.
     This class is represented by `_' because the character `_'
     has this class in both C and Lisp.
`.'     
     The class of punctuation characters that do not fit into any other
     special class.
`('     
     The class of opening delimiters. 
`)'     
     The class of closing delimiters. 
`''     
     The class of expression-adhering characters.  These characters are
     part of a symbol if found within or adjacent to one, and are part
     of a following expression if immediately preceding one, but are like
     whitespace if surrounded by whitespace.
`"'     
     The class of string-quote characters.  They match each other in pairs,
     and the characters within the pair all lose their syntactic
     significance except for the `\' and `/' classes of escape
     characters, which can be used to include a string-quote inside the
     string.
`$'     
     The class of self-matching delimiters.  This is intended for TeX's
     `$', which is used both to enter and leave math mode.  Thus,
     a pair of matching `$' characters surround each piece of math mode
     TeX input.  A pair of adjacent `$' characters act like a single
     one for purposes of matching
     
`/'     
     The class of escape characters that always just deny the following
     character its special syntactic significance.  The character after one
     of these escapes is always treated as alphabetic.
`\'     
     The class of C-style escape characters.  In practice, these are
     treated just like `/'-class characters, because the extra
     possibilities for C escapes (such as being followed by digits) have no
     effect on where the containing expression ends.
`<'     
     The class of comment-starting characters.  Only single-character
     comment starters (such as `;' in Lisp mode) are represented this
     way.
`>'     
     The class of comment-ending characters.  Newline has this syntax in
     Lisp mode.

  The characters flagged as part of two-character comment delimiters can
have other syntactic functions most of the time.  For example, `/' and
`*' in C code, when found separately, have nothing to do with
comments.  The comment-delimiter significance overrides when the pair of
characters occur together in the proper order.  Only the list and sexp
commands use the syntax table to find comments; the commands specifically
for comments have other variables that tell them where to find comments.
And the list and sexp commands notice comments only if
`parse-sexp-ignore-comments' is non-`nil'.  This variable is set
to `nil' in modes where comment-terminator sequences are liable to
appear where there is no comment; for example, in Lisp mode where the
comment terminator is a newline but not every newline ends a comment.


