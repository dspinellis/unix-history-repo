Info file ../info/emacs, produced by Makeinfo, -*- Text -*- from
input file emacs.tex.

This file documents the GNU Emacs editor.

Copyright (C) 1985, 1986, 1988 Richard M. Stallman.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and
"GNU General Public License" are included exactly as in the original,
and provided that the entire resulting derived work is distributed
under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.



File: emacs,  Node: Lisp Interaction,  Next: External Lisp,  Prev: Lisp Debug,  Up: Running

Lisp Interaction Buffers
========================

  The buffer `*scratch*' which is selected when Emacs starts up is
provided for evaluating Lisp expressions interactively inside Emacs. 
Both the expressions you evaluate and their output goes in the buffer.

  The `*scratch*' buffer's major mode is Lisp Interaction mode, which
is the same as Emacs-Lisp mode except for one command, LFD.  In
Emacs-Lisp mode, LFD is an indentation command, as usual.  In Lisp
Interaction mode, LFD is bound to `eval-print-last-sexp'.  This
function reads the Lisp expression before point, evaluates it, and
inserts the value in printed representation before point.

  Thus, the way to use the `*scratch*' buffer is to insert Lisp
expressions at the end, ending each one with LFD so that it will be
evaluated.  The result is a complete typescript of the expressions
you have evaluated and their values.

  The rationale for this feature is that Emacs must have a buffer when
it starts up, but that buffer is not useful for editing files since a
new buffer is made for every file that you visit.  The Lisp
interpreter typescript is the most useful thing I can think of for
the initial buffer to do.  `M-x lisp-interaction-mode' will put any
buffer in Lisp Interaction mode.



File: emacs,  Node: External Lisp,  Prev: Lisp Interaction,  Up: Running

Running an External Lisp
========================

  Emacs has facilities for running programs in other Lisp systems.  You
can run a Lisp process as an inferior of Emacs, and pass expressions
to it to be evaluated.  You can also pass changed function
definitions directly from the Emacs buffers in which you edit the
Lisp programs to the inferior Lisp process.

  To run an inferior Lisp process, type `M-x run-lisp'.  This runs the
program named `lisp', the same program you would run by typing `lisp'
as a shell command, with both input and output going through an Emacs
buffer named `*lisp*'.  That is to say, any "terminal output" from
Lisp will go into the buffer, advancing point, and any "terminal
input" for Lisp comes from text in the buffer.  To give input to
Lisp, go to the end of the buffer and type the input, terminated by
RET.  The `*lisp*' buffer is in Inferior Lisp mode, a mode which has
all the special characteristics of Lisp mode and Shell mode (*note
Shell Mode::.).

  For the source files of programs to run in external Lisps, use Lisp
mode.  This mode can be selected with `M-x lisp-mode', and is used
automatically for files whose names end in `.l' or `.lisp', as most
Lisp systems usually expect.

  When you edit a function in a Lisp program you are running, the
easiest way to send the changed definition to the inferior Lisp
process is the key `C-M-x'.  In Lisp mode, this runs the function
`lisp-send-defun', which finds the defun around or following point
and sends it as input to the Lisp process.  (Emacs can send input to
any inferior process regardless of what buffer is current.)

  Contrast the meanings of `C-M-x' in Lisp mode (for editing programs
to be run in another Lisp system) and Emacs-Lisp mode (for editing
Lisp programs to be run in Emacs): in both modes it has the effect of
installing the function definition that point is in, but the way of
doing so is different according to where the relevant Lisp
environment is found.  *Note Lisp Modes::.



File: emacs,  Node: Abbrevs,  Next: Picture,  Prev: Running,  Up: Top

Abbrevs
*******

  An "abbrev" is a word which "expands", if you insert it, into some
different text.  Abbrevs are defined by the user to expand in
specific ways.  For example, you might define `foo' as an abbrev
expanding to `find outer otter'.  With this abbrev defined, you would
be able to get `find outer otter ' into the buffer by typing `f o o
SPC'.

  Abbrevs expand only when Abbrev mode (a minor mode) is enabled. 
Disabling Abbrev mode does not cause abbrev definitions to be
forgotten, but they do not expand until Abbrev mode is enabled again.
The command `M-x abbrev-mode' toggles Abbrev mode; with a numeric
argument, it turns Abbrev mode on if the argument is positive, off
otherwise.  *Note Minor Modes::.  `abbrev-mode' is also a variable;
Abbrev mode is on when the variable is non-`nil'.  The variable
`abbrev-mode' automatically becomes local to the current buffer when
it is set.

  Abbrev definitions can be "mode-specific"--active only in one major
mode.  Abbrevs can also have "global" definitions that are active in
all major modes.  The same abbrev can have a global definition and
various mode-specific definitions for different major modes.  A mode
specific definition for the current major mode overrides a global
definition.

  Abbrevs can be defined interactively during the editing session. 
Lists of abbrev definitions can also be saved in files and reloaded
in later sessions.  Some users keep extensive lists of abbrevs that
they load in every session.

  A second kind of abbreviation facility is called the "dynamic
expansion".  Dynamic abbrev expansion happens only when you give an
explicit command and the result of the expansion depends only on the
current contents of the buffer.  *Note Dynamic Abbrevs::.

* Menu:

* Defining Abbrevs::  Defining an abbrev, so it will expand when typed.
* Expanding Abbrevs:: Controlling expansion: prefixes, canceling expansion.
* Editing Abbrevs::   Viewing or editing the entire list of defined abbrevs.
* Saving Abbrevs::    Saving the entire list of abbrevs for another session.
* Dynamic Abbrevs::   Abbreviations for words already in the buffer.

 

File: emacs,  Node: Defining Abbrevs,  Next: Expanding Abbrevs,  Prev: Abbrevs,  Up: Abbrevs

Defining Abbrevs
================

`C-x +'
     Define an abbrev to expand into some text before point
     (`add-global-abbrev').

`C-x C-a'
     Similar, but define an abbrev available only in the current
     major mode (`add-mode-abbrev').

`C-x -'
     Define a word in the buffer as an abbrev
     (`inverse-add-global-abbrev').

`C-x C-h'
     Define a word in the buffer as a mode-specific abbrev
     (`inverse-add-mode-abbrev').

`M-x kill-all-abbrevs'
     After this command, there are no abbrev definitions in effect.

  The usual way to define an abbrev is to enter the text you want the
abbrev to expand to, position point after it, and type `C-x +'
(`add-global-abbrev').  This reads the abbrev itself using the
minibuffer, and then defines it as an abbrev for one or more words
before point.  Use a numeric argument to say how many words before
point should be taken as the expansion.  For example, to define the
abbrev `foo' as mentioned above, insert the text `find outer otter'
and then type `C-u 3 C-x + f o o RET'.

  An argument of zero to `C-x +' means to use the contents of the
region as the expansion of the abbrev being defined.

  The command `C-x C-a' (`add-mode-abbrev') is similar, but defines a
mode-specific abbrev.  Mode specific abbrevs are active only in a
particular major mode.  `C-x C-a' defines an abbrev for the major
mode in effect at the time `C-x C-a' is typed.  The arguments work
the same as for `C-x +'.

  If the text of the abbrev you want is already in the buffer instead
of the expansion, use command `C-x -' (`inverse-add-global-abbrev')
instead of `C-x +', or use `C-x C-h' (`inverse-add-mode-abbrev')
instead of `C-x C-a'.  These commands are called "inverse" because
they invert the meaning of the argument found in the buffer and the
argument read using the minibuffer.

  To change the definition of an abbrev, just add the new definition. 
You will be asked to confirm if the abbrev has a prior definition. 
To remove an abbrev definition, give a negative argument to `C-x +'
or `C-x C-a'.  You must choose the command to specify whether to kill
a global definition or a mode-specific definition for the current
mode, since those two definitions are independent for one abbrev.

  `M-x kill-all-abbrevs' removes all the abbrev definitions there are.



File: emacs,  Node: Expanding Abbrevs,  Next: Editing Abbrevs,  Prev: Defining Abbrevs,  Up: Abbrevs

Controlling Abbrev Expansion
============================

  An abbrev expands whenever it is present in the buffer just before
point and a self-inserting punctuation character (SPC, comma, etc.)
is typed.  Most often the way an abbrev is used is to insert the
abbrev followed by punctuation.

  Abbrev expansion preserves case; thus, `foo' expands into `find outer
otter'; `Foo' into `Find outer otter', and `FOO' into `FIND OUTER
OTTER' or `Find Outer Otter' according to the variable
`abbrev-all-caps' (a non-`nil' value chooses the first of the two
expansions).

  These two commands are used to control abbrev expansion:

`M-''
     Separate a prefix from a following abbrev to be expanded
     (`abbrev-prefix-mark').

`C-x ''
     Expand the abbrev before point (`expand-abbrev').  This is
     effective even when Abbrev mode is not enabled.

`M-x unexpand-abbrev'
     Undo last abbrev expansion.

`M-x expand-region-abbrevs'
     Expand some or all abbrevs found in the region.

  You may wish to expand an abbrev with a prefix attached; for example,
if `cnst' expands into `construction', you might want to use it to
enter `reconstruction'.  It does not work to type `recnst', because
that is not necessarily a defined abbrev.  What does work is to use
the command `M-'' (`abbrev-prefix-mark') in between the prefix `re'
and the abbrev `cnst'.  First, insert `re'.  Then type `M-''; this
inserts a minus sign in the buffer to indicate that it has done its
work.  Then insert the abbrev `cnst'; the buffer now contains
`re-cnst'.  Now insert a punctuation character to expand the abbrev
`cnst' into `construction'.  The minus sign is deleted at this point,
because `M-'' left word for this to be done.  The resulting text is
the desired `reconstruction'.

  If you actually want the text of the abbrev in the buffer, rather
than its expansion, you can accomplish this by inserting the
following punctuation with `C-q'.  Thus, `foo C-q -' leaves `foo-' in
the buffer.

  If you expand an abbrev by mistake, you can undo the expansion
(replace the expansion by the original abbrev text) with `M-x
unexpand-abbrev'.  `C-_' (`undo') can also be used to undo the
expansion; but first it will undo the insertion of the following
punctuation character!

  `M-x expand-region-abbrevs' searches through the region for defined
abbrevs, and for each one found offers to replace it with its
expansion.  This command is useful if you have typed in text using
abbrevs but forgot to turn on Abbrev mode first.  It may also be
useful together with a special set of abbrev definitions for making
several global replacements at once.  This command is effective even
if Abbrev mode is not enabled.



File: emacs,  Node: Editing Abbrevs,  Next: Saving Abbrevs,  Prev: Expanding Abbrevs,  Up: Abbrevs

Examining and Editing Abbrevs
=============================

`M-x list-abbrevs'
     Print a list of all abbrev definitions.

`M-x edit-abbrevs'
     Edit a list of abbrevs; you can add, alter or remove definitions.

  The output from `M-x list-abbrevs' looks like this:

     (lisp-mode-abbrev-table)
     "dk"	       0    "define-key"
     (global-abbrev-table)
     "dfn"	       0    "definition"

(Some blank lines of no semantic significance, and some other abbrev
tables, have been omitted.)

  A line containing a name in parentheses is the header for abbrevs in
a particular abbrev table; `global-abbrev-table' contains all the
global abbrevs, and the other abbrev tables that are named after
major modes contain the mode-specific abbrevs.

  Within each abbrev table, each nonblank line defines one abbrev.  The
word at the beginning is the abbrev.  The number that appears is the
number of times the abbrev has been expanded.  Emacs keeps track of
this to help you see which abbrevs you actually use, in case you
decide to eliminate those that you don't use often.  The string at
the end of the line is the expansion.

  `M-x edit-abbrevs' allows you to add, change or kill abbrev
definitions by editing a list of them in an Emacs buffer.  The list
has the same format described above.  The buffer of abbrevs is called
`*Abbrevs*', and is in Edit-Abbrevs mode.  This mode redefines the
key `C-c C-c' to install the abbrev definitions as specified in the
buffer.  The command that does this is `edit-abbrevs-redefine'.  Any
abbrevs not described in the buffer are eliminated when this is done.

  `edit-abbrevs' is actually the same as `list-abbrevs' except that it
selects the buffer `*Abbrevs*' whereas `list-abbrevs' merely displays
it in another window.



File: emacs,  Node: Saving Abbrevs,  Next: Dynamic Abbrevs,  Prev: Editing Abbrevs,  Up: Abbrevs

Saving Abbrevs
==============

  These commands allow you to keep abbrev definitions between editing
sessions.

`M-x write-abbrev-file'
     Write a file describing all defined abbrevs.

`M-x read-abbrev-file'
     Read such a file and define abbrevs as specified there.

`M-x quietly-read-abbrev-file'
     Similar but do not display a message about what is going on.

`M-x define-abbrevs'
     Define abbrevs from buffer.

`M-x insert-abbrevs'
     Insert all abbrevs and their expansions into the buffer.

  `M-x write-abbrev-file' reads a file name using the minibuffer and
writes a description of all current abbrev definitions into that
file.  The text stored in the file looks like the output of `M-x
list-abbrevs'.  This is used to save abbrev definitions for use in a
later session.

  `M-x read-abbrev-file' reads a file name using the minibuffer and
reads the file, defining abbrevs according to the contents of the file.
`M-x quietly-read-abbrev-file' is the same except that it does not
display a message in the echo area saying that it is doing its work;
it is actually useful primarily in the `.emacs' file.  If an empty
argument is given to either of these functions, the file name used is
the value of the variable `abbrev-file-name', which is by default
`"~/.abbrev_defs"'.

  Emacs will offer to save abbrevs automatically if you have changed
any of them, whenever it offers to save all files (for `C-x s' or
`C-x C-c').  This feature can be inhibited by setting the variable
`save-abbrevs' to `nil'.

  The commands `M-x insert-abbrevs' and `M-x define-abbrevs' are
similar to the previous commands but work on text in an Emacs buffer.
`M-x insert-abbrevs' inserts text into the current buffer before
point, describing all current abbrev definitions; `M-x
define-abbrevs' parses the entire current buffer and defines abbrevs
accordingly.



File: emacs,  Node: Dynamic Abbrevs,  Prev: Saving Abbrevs,  Up: Abbrevs

Dynamic Abbrev Expansion
========================

  The abbrev facility described above operates automatically as you
insert text, but all abbrevs must be defined explicitly.  By
contrast, "dynamic abbrevs" allow the meanings of abbrevs to be
determined automatically from the contents of the buffer, but dynamic
abbrev expansion happens only when you request it explicitly.

`M-/'
     Expand the word in the buffer before point as a "dynamic
     abbrev", by searching in the buffer for words starting with that
     abbreviation (`dabbrev-expand').

  For example, if the buffer contains `does this follow ' and you type
`f o M-/', the effect is to insert `follow' because that is the last
word in the buffer that starts with `fo'.  A numeric argument to
`M-/' says to take the second, third, etc. distinct expansion found
looking backward from point.  Repeating `M-/' searches for an
alternative expansion by looking farther back.  After the entire
buffer before point has been considered, the buffer after point is
searched.

  Dynamic abbrev expansion is completely independent of Abbrev mode;
the expansion of a word with `M-/' is completely independent of
whether it has a definition as an ordinary abbrev.



File: emacs,  Node: Picture,  Next: Sending Mail,  Prev: Abbrevs,  Up: Top

Editing Pictures
****************

  If you want to create a picture made out of text characters (for
example, a picture of the division of a register into fields, as a
comment in a program), use the command `edit-picture' to enter
Picture mode.

  In Picture mode, editing is based on the "quarter-plane" model of
text, according to which the text characters lie studded on an area
that stretches infinitely far to the right and downward.  The concept
of the end of a line does not exist in this model; the most you can
say is where the last nonblank character on the line is found.

  Of course, Emacs really always considers text as a sequence of
characters, and lines really do have ends.  But in Picture mode most
frequently-used keys are rebound to commands that simulate the
quarter-plane model of text.  They do this by inserting spaces or by
converting tabs to spaces.

  Most of the basic editing commands of Emacs are redefined by Picture
mode to do essentially the same thing but in a quarter-plane way.  In
addition, Picture mode defines various keys starting with the `C-c'
prefix to run special picture editing commands.

  One of these keys, `C-c C-c', is pretty important.  Often a picture
is part of a larger file that is usually edited in some other major
mode.  `M-x edit-picture' records the name of the previous major
mode, and then you can use the `C-c C-c' command
(`picture-mode-exit') to restore that mode.  `C-c C-c' also deletes
spaces from the ends of lines, unless given a numeric argument.

  The commands used in Picture mode all work in other modes (provided
the `picture' library is loaded), but are not bound to keys except in
Picture mode.  Note that the descriptions below talk of moving "one
column" and so on, but all the picture mode commands handle numeric
arguments as their normal equivalents do.

  Turning on Picture mode calls the value of the variable
`picture-mode-hook' as a function, with no arguments, if that value
exists and is non-`nil'.

* Menu:

* Basic Picture::         Basic concepts and simple commands of Picture Mode.
* Insert in Picture::     Controlling direction of cursor motion
                           after "self-inserting" characters.
* Tabs in Picture::       Various features for tab stops and indentation.
* Rectangles in Picture:: Clearing and superimposing rectangles.

 

File: emacs,  Node: Basic Picture,  Next: Insert in Picture,  Prev: Picture,  Up: Picture

Basic Editing in Picture Mode
=============================

  Most keys do the same thing in Picture mode that they usually do, but
do it in a quarter-plane style.  For example, `C-f' is rebound to run
`picture-forward-column', which is defined to move point one column
to the right, by inserting a space if necessary, so that the actual
end of the line makes no difference.  `C-b' is rebound to run
`picture-backward-column', which always moves point left one column,
converting a tab to multiple spaces if necessary.  `C-n' and `C-p'
are rebound to run `picture-move-down' and `picture-move-up', which
can either insert spaces or convert tabs as necessary to make sure
that point stays in exactly the same column.  `C-e' runs
`picture-end-of-line', which moves to after the last nonblank
character on the line.  There is no need to change `C-a', as the
choice of screen model does not affect beginnings of lines.

  Insertion of text is adapted to the quarter-plane screen model
through the use of Overwrite mode (*note Minor Modes::.). 
Self-inserting characters replace existing text, column by column,
rather than pushing existing text to the right.  RET runs
`picture-newline', which just moves to the beginning of the following
line so that new text will replace that line.

  Deletion and killing of text are replaced with erasure.  DEL
(`picture-backward-clear-column') replaces the preceding character
with a space rather than removing it.  `C-d' (`picture-clear-column')
does the same thing in a forward direction.  `C-k'
(`picture-clear-line') really kills the contents of lines, but does
not ever remove the newlines from the buffer.

  To do actual insertion, you must use special commands.  `C-o'
(`picture-open-line') still creates a blank line, but does so after
the current line; it never splits a line.  `C-M-o', `split-line',
makes sense in Picture mode, so it is not changed.  LFD
(`picture-duplicate-line') inserts below the current line another
line with the same contents.

  Real deletion can be done with `C-w', or with `C-c C-d' (which is
defined as `delete-char', as `C-d' is in other modes), or with one of
the picture rectangle commands (*note Rectangles in Picture::.).



File: emacs,  Node: Insert in Picture,  Next: Tabs in Picture,  Prev: Basic Picture,  Up: Picture

Controlling Motion after Insert
===============================

  Since "self-inserting" characters in Picture mode just overwrite and
move point, there is no essential restriction on how point should be
moved.  Normally point moves right, but you can specify any of the
eight orthogonal or diagonal directions for motion after a
"self-inserting" character.  This is useful for drawing lines in the
buffer.

`C-c <'
     Move left after insertion (`picture-movement-left').

`C-c >'
     Move right after insertion (`picture-movement-right').

`C-c ^'
     Move up after insertion (`picture-movement-up').

`C-c .'
     Move down after insertion (`picture-movement-down').

`C-c `'
     Move up and left ("northwest") after insertion 
     (`picture-movement-nw').

`C-c ''
     Move up and right ("northeast") after insertion 
      (`picture-movement-ne').

`C-c /'
     Move down and left ("southwest") after insertion 
     (`picture-movement-sw').

`C-c \'
     Move down and right ("southeast") after insertion 
     (`picture-movement-se').

  Two motion commands move based on the current Picture insertion
direction.  The command `C-c C-f' (`picture-motion') moves in the
same direction as motion after "insertion" currently does, while `C-c
C-b' (`picture-motion-reverse') moves in the opposite direction.



File: emacs,  Node: Tabs in Picture,  Next: Rectangles in Picture,  Prev: Insert in Picture,  Up: Picture

Picture Mode Tabs
=================

  Two kinds of tab-like action are provided in Picture mode. 
Context-based tabbing is done with `M-TAB' (`picture-tab-search'). 
With no argument, it moves to a point underneath the next
"interesting" character that follows whitespace in the previous
nonblank line.  "Next" here means "appearing at a horizontal position
greater than the one point starts out at".  With an argument, as in
`C-u M-TAB', this command moves to the next such interesting
character in the current line.  `M-TAB' does not change the text; it
only moves point.  "Interesting" characters are defined by the
variable `picture-tab-chars', which contains a string whose
characters are all considered interesting.  Its default value is
`"!-~"'.

  TAB itself runs `picture-tab', which operates based on the current
tab stop settings; it is the Picture mode equivalent of
`tab-to-tab-stop'.  Normally it just moves point, but with a numeric
argument it clears the text that it moves over.

  The context-based and tab-stop-based forms of tabbing are brought
together by the command `C-c TAB', `picture-set-tab-stops'.  This
command sets the tab stops to the positions which `M-TAB' would
consider significant in the current line.  The use of this command,
together with TAB, can get the effect of context-based tabbing.  But
`M-TAB' is more convenient in the cases where it is sufficient.



File: emacs,  Node: Rectangles in Picture,  Prev: Tabs in Picture,  Up: Picture

Picture Mode Rectangle Commands
===============================

  Picture mode defines commands for working on rectangular pieces of
the text in ways that fit with the quarter-plane model.  The standard
rectangle commands may also be useful (*note Rectangles::.).

`C-c C-k'
     Clear out the region-rectangle (`picture-clear-rectangle'). 
     With argument, kill it.

`C-c C-w R'
     Similar but save rectangle contents in register R first
     (`picture-clear-rectangle-to-register').

`C-c C-y'
     Copy last killed rectangle into the buffer by overwriting, with
     upper left corner at point (`picture-yank-rectangle').  With
     argument, insert instead.

`C-c C-x R'
     Similar, but use the rectangle in register R
      (`picture-yank-rectangle-from-register').

  The picture rectangle commands `C-c C-k' (`picture-clear-rectangle')
and `C-c C-w' (`picture-clear-rectangle-to-register') differ from the
standard rectangle commands in that they normally clear the rectangle
instead of deleting it; this is analogous with the way `C-d' is
changed in Picture mode.

  However, deletion of rectangles can be useful in Picture mode, so
these commands delete the rectangle if given a numeric argument.

  The Picture mode commands for yanking rectangles differ from the
standard ones in overwriting instead of inserting.  This is the same
way that Picture mode insertion of other text is different from other
modes.  `C-c C-y' (`picture-yank-rectangle') inserts (by overwriting)
the rectangle that was most recently killed, while `C-c C-x'
(`picture-yank-rectangle-from-register') does likewise for the
rectangle found in a specified register.



File: emacs,  Node: Sending Mail,  Next: Rmail,  Prev: Picture,  Up: Top

Sending Mail
************

  To send a message in Emacs, you start by typing a command (`C-x m')
to select and initialize the `*mail*' buffer.  Then you edit the text
and headers of the message in this buffer, and type another command
(`C-c C-c') to send the message.

`C-x m'
     Begin composing a message to send (`mail').

`C-x 4 m'
     Likewise, but display the message in another window
     (`mail-other-window').

`C-c C-c'
     In Mail mode, send the message and switch to another buffer
     (`mail-send-and-exit').

  The command `C-x m' (`mail') selects a buffer named `*mail*' and
initializes it with the skeleton of an outgoing message.  `C-x 4 m'
(`mail-other-window') selects the `*mail*' buffer in a different
window, leaving the previous current buffer visible.

  Because the mail composition buffer is an ordinary Emacs buffer, you
can switch to other buffers while in the middle of composing mail,
and switch back later (or never).  If you use the `C-x m' command
again when you have been composing another message but have not sent
it, you are asked to confirm before the old message is erased.  If
you answer `n', the `*mail*' buffer is left selected with its old
contents, so you can finish the old message and send it.  `C-u C-x m'
is another way to do this.  Sending the message marks the `*mail*'
buffer "unmodified", which avoids the need for confirmation when `C-x
m' is next used.

  If you are composing a message in the `*mail*' buffer and want to
send another message before finishing the first, rename the `*mail*'
buffer using `M-x rename-buffer' (*note Misc Buffer::.).

* Menu:

* Format: Mail Format.    Format of the mail being composed.
* Headers: Mail Headers.  Details of allowed mail header fields.
* Mode: Mail Mode.        Special commands for editing mail being composed.

 

File: emacs,  Node: Mail Format,  Next: Mail Headers,  Prev: Sending Mail,  Up: Sending Mail

The Format of the Mail Buffer
=============================

  In addition to the "text" or contents, a message has "header fields"
which say who sent it, when, to whom, why, and so on.  Some header
fields such as the date and sender are created automatically after
the message is sent.  Others, such as the recipient names, must be
specified by you in order to send the message properly.

  Mail mode provides a few commands to help you edit some header
fields, and some are preinitialized in the buffer automatically at
times.  You can insert or edit any header fields using ordinary
editing commands.

  The line in the buffer that says

     --text follows this line--

is a special delimiter that separates the headers you have specified
from the text.  Whatever follows this line is the text of the
message; the headers precede it.  The delimiter line itself does not
appear in the message actually sent.  The text used for the delimiter
line is controlled by the variable `mail-header-separator'.

Here is an example of what the headers and text in the `*mail*'
buffer might look like.

     To: rms@mc
     CC: mly@mc, rg@oz
     Subject: The Emacs Manual
     --Text follows this line--
     Please ignore this message.

 

File: emacs,  Node: Mail Headers,  Next: Mail Mode,  Prev: Mail Format,  Up: Sending Mail

Mail Header Fields
==================

  There are several header fields you can use in the `*mail*' buffer. 
Each header field starts with a field name at the beginning of a
line, terminated by a colon.  It does not matter whether you use
upper or lower case in the field name.  After the colon and optional
whitespace comes the contents of the field.

`To'
     This field contains the mailing addresses to which the message
     is addressed.

`Subject'
     The contents of the `Subject' field should be a piece of text
     that says what the message is about.  The reason `Subject'
     fields are useful is that most mail-reading programs can provide
     a summary of messages, listing the subject of each message but
     not its text.

`CC'
     This field contains additional mailing addresses to send the
     message to, but whose readers should not regard the message as
     addressed to them.

`BCC'
     This field contains additional mailing addresses to send the
     message to, but which should not appear in the header of the
     message actually sent.

`FCC'
     This field contains the name of one file (in Unix mail file
     format) to which a copy of the message should be appended when
     the message is sent.

`From'
     Use the `From' field to say who you are, when the account you
     are using to send the mail is not your own.  The contents of the
     `From' field should be a valid mailing address, since replies
     will normally go there.

`Reply-To'
     Use the `Reply-to' field to direct replies to a different
     address, not your own.  There is no difference between `From'
     and `Reply-to' in their effect on where replies go, but they
     convey a different meaning to the human who reads the message.

`In-Reply-To'
     This field contains a piece of text describing a message you are
     replying to.  Some mail systems can use this information to
     correlate related pieces of mail.  Normally this field is filled
     in by Rmail when you are replying to a message in Rmail, and you
     never need to think about it (*note Rmail::.).

The `To', `CC', `BCC' and `FCC' fields can appear any number of
times, to specify many places to send the message.

The `To', `CC', and `BCC' fields can have continuation lines.  All
the lines starting with whitespace, following the line on which the
field starts, are considered part of the field.  For example,

     To: foo@here, this@there,
       me@gnu.cambridge.mass.usa.earth.spiral3281

If you have a `~/.mailrc' file, Emacs will scan it for mail aliases
the first time you try to send mail in an Emacs session.  Aliases
found in the `To', `CC', and `BCC' fields will be expanded where
appropriate.

  If the variable `mail-archive-file-name' is non-`nil', it should be a
string naming a file; every time you start to edit a message to send,
an `FCC' field will be put in for that file.  Unless you remove the
`FCC' field, every message will be written into that file when it is
sent.



File: emacs,  Node: Mail Mode,  Prev: Mail Headers,  Up: Sending Mail

Mail Mode
=========

  The major mode used in the `*mail*' buffer is Mail mode, which is
much like Text mode except that various special commands are provided
on the `C-c' prefix.  These commands all have to do specifically with
editing or sending the message.

`C-c C-s'
     Send the message, and leave the `*mail*' buffer selected
     (`mail-send').

`C-c C-c'
     Send the message, and select some other buffer
     (`mail-send-and-exit').

`C-c C-f C-t'
     Move to the `To' header field, creating one if there is none
     (`mail-to').

`C-c C-f C-s'
     Move to the `Subject' header field, creating one if there is
     none (`mail-subject').

`C-c C-f C-c'
     Move to the `CC' header field, creating one if there is none
     (`mail-cc').

`C-c C-w'
     Insert the file `~/.signature' at the end of the message text
     (`mail-signature').

`C-c C-y'
     Yank the selected message from Rmail (`mail-yank-original'). 
     This command does nothing unless your command to start sending a
     message was issued with Rmail.

`C-c C-q'
     Fill all paragraphs of yanked old messages, each individually
     (`mail-fill-yanked-message').

  There are two ways to send the message.  `C-c C-s' (`mail-send')
sends the message and marks the `*mail*' buffer unmodified, but
leaves that buffer selected so that you can modify the message
(perhaps with new recipients) and send it again.  `C-c C-c'
(`mail-send-and-exit') sends and then deletes the window (if there is
another window) or switches to another buffer.  It puts the `*mail*'
buffer at the lowest priority for automatic reselection, since you
are finished with using it.  This is the usual way to send the message.

  Mail mode provides some other special commands that are useful for
editing the headers and text of the message before you send it. 
There are three commands defined to move point to particular header
fields, all based on the prefix `C-c C-f' (`C-f' is for "field"). 
They are `C-c C-f C-t' (`mail-to') to move to the `To' field, `C-c
C-f C-s' (`mail-subject') for the `Subject' field, and `C-c C-f C-c'
(`mail-cc') for the `CC' field.  These fields have special motion
commands because they are the most common fields for the user to want
to edit.

  `C-c C-w' (`mail-signature') adds a standard piece text at the end of
the message to say more about who you are.  The text comes from the
file `.signature' in your home directory.

  When mail sending is invoked from the Rmail mail reader using an
Rmail command, `C-c C-y' can be used inside the `*mail*' buffer to
insert the text of the message you are replying to.  Normally it
indents each line of that message four spaces and eliminates most
header fields.  A numeric argument specifies the number of spaces to
indent.  An argument of just `C-u' says not to indent at all and not
to eliminate anything.  `C-c C-y' always uses the current message
from the `RMAIL' buffer, so you can insert several old messages by
selecting one in `RMAIL', switching to `*mail*' and yanking it, then
switching back to `RMAIL' to select another.

  After using `C-c C-y', the command `C-c C-q'
(`mail-fill-yanked-message') can be used to fill the paragraphs of
the yanked old message or messages.  One use of `C-c C-q' fills all
such paragraphs, each one separately.

  Turning on Mail mode (which `C-x m' does automatically) calls the
value of `text-mode-hook', if it is not void or `nil', and then calls
the value of `mail-mode-hook' if that is not void or `nil'.



File: emacs,  Node: Rmail,  Next: Recursive Edit,  Prev: Sending Mail,  Up: Top

Reading Mail with Rmail
***********************

  Rmail is an Emacs subsystem for reading and disposing of mail that
you receive.  Rmail stores mail messages in files called Rmail files.
Reading the message in an Rmail file is done in a special major mode,
Rmail mode, which redefines most letters to run commands for managing
mail.  To enter Rmail, type `M-x rmail'.  This reads your primary
mail file, merges new mail in from your inboxes, displays the first
new message, and lets you begin reading.

  Using Rmail in the simplest fashion, you have one Rmail file
`~/RMAIL' in which all of your mail is saved.  It is called your
"primary mail file".  In more sophisticated usage, you can copy
messages into other Rmail files and then edit those files with Rmail.

  Rmail displays only one message at a time.  It is called the "current
message".  Rmail mode's special commands can do such things as move
to another message, delete the message, copy the message into another
file, or send a reply.

  Within the Rmail file, messages are arranged sequentially in order of
receipt.  They are also assigned consecutive integers as their
"message numbers".  The number of the current message is displayed in
Rmail's mode line, followed by the total number of messages in the
file.  You can move to a message by specifying its message number
using the `j' key (*note Rmail Motion::.).

  Following the usual conventions of Emacs, changes in an Rmail file
become permanent only when the file is saved.  You can do this with
`s' (`rmail-save'), which also expunges deleted messages from the
file first (*note Rmail Deletion::.).  To save the file without
expunging, use `C-x C-s'.  Rmail saves the Rmail file spontaneously
when moving new mail from an inbox file (*note Rmail Inbox::.).

  You can exit Rmail with `q' (`rmail-quit'); this expunges and saves
the Rmail file and then switches to another buffer.  But there is no
need to `exit' formally.  If you switch from Rmail to editing in
other buffers, and never happen to switch back, you have exited. 
Just make sure to save the Rmail file eventually (like any other file
you have changed).  `C-x s' is a good enough way to do this (*note
Saving::.).

* Menu:

* Scroll: Rmail Scrolling.   Scrolling through a message.
* Motion: Rmail Motion.      Moving to another message.
* Deletion: Rmail Deletion.  Deleting and expunging messages.
* Inbox: Rmail Inbox.        How mail gets into the Rmail file.
* Files: Rmail Files.        Using multiple Rmail files.
* Output: Rmail Output.	     Copying message out to files.
* Labels: Rmail Labels.      Classifying messages by labeling them.
* Summary: Rmail Summary.    Summaries show brief info on many messages.
* Reply: Rmail Reply.        Sending replies to messages you are viewing.
* Editing: Rmail Editing.    Editing message text and headers in Rmail.
* Digest: Rmail Digest.      Extracting the messages from a digest message.

 

File: emacs,  Node: Rmail Scrolling,  Next: Rmail Motion,  Prev: Rmail,  Up: Rmail

Scrolling Within a Message
==========================

  When Rmail displays a message that does not fit on the screen, it is
necessary to scroll through it.  This could be done with `C-v', `M-v'
and `M-<', but in Rmail scrolling is so frequent that it deserves to
be easier to type.

`SPC'
     Scroll forward (`scroll-up').

`DEL'
     Scroll backward (`scroll-down').

`.'
     Scroll to start of message (`rmail-beginning-of-message').

  Since the most common thing to do while reading a message is to
scroll through it by screenfuls, Rmail makes SPC and DEL synonyms of
`C-v' (`scroll-up') and `M-v' (`scroll-down')

  The command `.' (`rmail-beginning-of-message') scrolls back to the
beginning of the selected message.  This is not quite the same as
`M-<': for one thing, it does not set the mark; for another, it
resets the buffer boundaries to the current message if you have
changed them.



File: emacs,  Node: Rmail Motion,  Next: Rmail Deletion,  Prev: Rmail Scrolling,  Up: Rmail

Moving Among Messages
=====================

  The most basic thing to do with a message is to read it.  The way to
do this in Rmail is to make the message current.  You can make any
message current given its message number using the `j' command, but
the usual thing to do is to move sequentially through the file, since
this is the order of receipt of messages.  When you enter Rmail, you
are positioned at the first new message (new messages are those
received since the previous use of Rmail), or at the last message if
there are no new messages this time.  Move forward to see the other
new messages; move backward to reexamine old messages.

`n'
     Move to the next nondeleted message, skipping any intervening
     deleted 
      messages (`rmail-next-undeleted-message').

`p'
     Move to the previous nondeleted message 
      (`rmail-previous-undeleted-message').

`M-n'
     Move to the next message, including deleted messages
     (`rmail-next-message').

`M-p'
     Move to the previous message, including deleted messages
     (`rmail-previous-message').

`j'
     Move to the first message.  With argument N, move to message
     number N (`rmail-show-message').

`>'
     Move to the last message (`rmail-last-message').

`M-s REGEXP RET'
     Move to the next message containing a match for REGEXP
     (`rmail-search').  If REGEXP is empty, the last regexp used is
     used again.

`- M-s REGEXP RET'
     Move to the previous message containing a match for REGEXP.  If
     REGEXP is empty, the last regexp used is used again.

  `n' and `p' are the usual way of moving among messages in Rmail. 
They move through the messages sequentially, but skip over deleted
messages, which is usually what you want to do.  Their command
definitions are named `rmail-next-undeleted-message' and
`rmail-previous-undeleted-message'.  If you do not want to skip
deleted messages--for example, if you want to move to a message to
undelete it--use the variants `M-n' and `M-p' (`rmail-next-message'
and `rmail-previous-message').  A numeric argument to any of these
commands serves as a repeat count.

  In Rmail, you can specify a numeric argument by typing the digits. 
It is not necessary to type `C-u' first.

  The `M-s' (`rmail-search') command is Rmail's version of search.  The
usual incremental search command `C-s' works in Rmail, but it
searches only within the current message.  The purpose of `M-s' is to
search for another message.  It reads a regular expression (*note
Regexps::.) nonincrementally, then searches starting at the beginning
of the following message for a match.  The message containing the
match is selected.

  To search backward in the file for another message, give `M-s' a
negative argument.  In Rmail this can be done with `- M-s'.

  It is also possible to search for a message based on labels.  *Note
Rmail Labels::.

  To move to a message specified by absolute message number, use `j'
(`rmail-show-message') with the message number as argument.  With no
argument, `j' selects the first message.  `>' (`rmail-last-message')
selects the last message.



File: emacs,  Node: Rmail Deletion,  Next: Rmail Inbox,  Prev: Rmail Motion,  Up: Rmail

Deleting Messages
=================

  When you no longer need to keep a message, you can "delete" it.  This
flags it as ignorable, and some Rmail commands will pretend it is no
longer present; but it still has its place in the Rmail file, and
still has its message number.

  "Expunging" the Rmail file actually removes the deleted messages. 
The remaining messages are renumbered consecutively.  Expunging is
the only action that changes the message number of any message,
except for undigestifying (*note Rmail Digest::.).

`d'
     Delete the current message, and move to the next nondeleted
     message (`rmail-delete-forward').

`C-d'
     Delete the current message, and move to the previous nondeleted
     message (`rmail-delete-backward').

`u'
     Undelete the current message, or move back to a deleted message
     and undelete it (`rmail-undelete-previous-message').

`x'
`e'
     Expunge the Rmail file (`rmail-expunge').  These two commands
     are synonyms.

  There are two Rmail commands for deleting messages.  Both delete the
current message and select another message.  `d'
(`rmail-delete-forward') moves to the following message, skipping
messages already deleted, while `C-d' (`rmail-delete-backward') moves
to the previous nondeleted message.  If there is no nondeleted
message to move to in the specified direction, the message that was
just deleted remains current.

  To make all the deleted messages finally vanish from the Rmail file,
type `e' (`rmail-expunge').  Until you do this, you can still
"undelete" the deleted messages.

  To undelete, type `u' (`rmail-undelete-previous-message'), which is
designed to cancel the effect of a `d' command (usually).  It
undeletes the current message if the current message is deleted. 
Otherwise it moves backward to previous messages until a deleted
message is found, and undeletes that message.

  You can usually undo a `d' with a `u' because the `u' moves back to
and undeletes the message that the `d' deleted.  But this does not
work when the `d' skips a few already-deleted messages that follow
the message being deleted; then the `u' command will undelete the
last of the messages that were skipped.  There is no clean way to
avoid this problem.  However, by repeating the `u' command, you can
eventually get back to the message that you intended to undelete. 
You can also reach that message with `M-p' commands and then type `u'.

  A deleted message has the `deleted' attribute, and as a result
`deleted' appears in the mode line when the current message is
deleted.  In fact, deleting or undeleting a message is nothing more
than adding or removing this attribute.  *Note Rmail Labels::.



File: emacs,  Node: Rmail Inbox,  Next: Rmail Files,  Prev: Rmail Deletion,  Up: Rmail

Rmail Files and Inboxes
=======================

  Unix places incoming mail for you in a file that we call your "inbox".
When you start up Rmail, it copies the new messages from your inbox
into your primary mail file, an Rmail file, which also contains other
messages saved from previous Rmail sessions.  It is in this file that
you actually read the mail with Rmail.  This operation is called
"getting new mail".  It can be repeated at any time using the `g' key
in Rmail.  The inbox file name is `/usr/spool/mail/USERNAME' in
Berkeley Unix, `/usr/mail/USERNAME' in system V.

  There are two reason for having separate Rmail files and inboxes.

  1. The format in which Unix delivers the mail in the inbox is not
     adequate for Rmail mail storage.  It has no way to record
     attributes (such as `deleted') or user-specified labels; it has
     no way to record old headers and reformatted headers; it has no
     way to record cached summary line information.

  2. It is very cumbersome to access an inbox file without danger of
     losing mail, because it is necessary to interlock with mail
     delivery.  Moreover, different Unix systems use different
     interlocking techniques.  The strategy of moving mail out of the
     inbox once and for all into a separate Rmail file avoids the
     need for interlocking in all the rest of Rmail, since only Rmail
     operates on the Rmail file.

  When getting new mail, Rmail first copies the new mail from the inbox
file to the Rmail file; then it saves the Rmail file; then it deletes
the inbox file.  This way, a system crash may cause duplication of
mail between the inbox and the Rmail file, but cannot lose mail.

  Copying mail from an inbox in the system's mailer directory actually
puts it in an intermediate file `~/.newmail'.  This is because the
interlocking is done by a C program that copies to another file. 
`~/.newmail' is deleted after mail merging is successful.  If there
is a crash at the wrong time, this file will continue to exist and
will be used as an inbox the next time you get new mail.



File: emacs,  Node: Rmail Files,  Next: Rmail Output,  Prev: Rmail Inbox,  Up: Rmail

Multiple Mail Files
===================

  Rmail operates by default on your "primary mail file", which is named
`~/RMAIL' and receives your incoming mail from your system inbox file.
But you can also have other mail files and edit them with Rmail. 
These files can receive mail through their own inboxes, or you can
move messages into them by explicit command in Rmail (*note Rmail
Output::.).

`i FILE RET'
     Read FILE into Emacs and run Rmail on it (`rmail-input').

`M-x set-rmail-inbox-list RET FILES RET'
     Specify inbox file names for current Rmail file to get mail from.

`g'
     Merge new mail from current Rmail file's inboxes
     (`rmail-get-new-mail').

`C-u g FILE'
     Merge new mail from inbox file FILE.

  To run Rmail on a file other than your primary mail file, you may use
the `i' (`rmail-input') command in Rmail.  This visits the file, puts
it in Rmail mode, and then gets new mail from the file's inboxes if
any.  You can also use `M-x rmail-input' even when not in Rmail.

  The file you read with `i' does not have to be in Rmail file format. 
It could also be Unix mail format, or mmdf format; or it could be a
mixture of all three, as long as each message belongs to one of the
three formats.  Rmail recognizes all three and converts all the
messages to proper Rmail format before showing you the file.

  Each Rmail file can contain a list of inbox file names; you can
specify this list with `M-x set-rmail-inbox-list RET FILES RET'.  The
argument can contain any number of file names, separated by commas. 
It can also be empty, which specifies that this file should have no
inboxes.  Once a list of inboxes is specified, the Rmail file
remembers it permanently until it is explicitly changed.

  If an Rmail file has inboxes, new mail is merged in from the inboxes
when the Rmail file is brought into Rmail, and when the `g'
(`rmail-get-new-mail') command is used.  If the Rmail file specifies
no inboxes, then no new mail is merged in at these times.  A special
exception is made for your primary mail file in using the standard
system inbox for it if it does not specify any.

  To merge mail from a file that is not the usual inbox, give the `g'
key a numeric argument, as in `C-u g'.  Then it reads a file name and
merges mail from that file.  The inbox file is not deleted or changed
in any way when `g' with an argument is used.  This is, therefore, a
general way of merging one file of messages into another.


