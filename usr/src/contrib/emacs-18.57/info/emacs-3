Info file ../info/emacs, produced by Makeinfo, -*- Text -*- from
input file emacs.tex.

This file documents the GNU Emacs editor.

Copyright (C) 1985, 1986, 1988 Richard M. Stallman.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and
"GNU General Public License" are included exactly as in the original,
and provided that the entire resulting derived work is distributed
under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.



File: emacs,  Node: M-x,  Next: Help,  Prev: Minibuffer,  Up: Top

Running Commands by Name
************************

  The Emacs commands that are used often or that must be quick to type
are bound to keys--short sequences of characters--for convenient use.
Other Emacs commands that do not need to be brief are not bound to
keys; to run them, you must refer to them by name.

  A command name is, by convention, made up of one or more words,
separated by hyphens; for example, `auto-fill-mode' or
`manual-entry'.  The use of English words makes the command name
easier to remember than a key made up of obscure characters, even
though it is more characters to type.  Any command can be run by
name, even if it is also runnable by keys.

  The way to run a command by name is to start with `M-x', type the
command name, and finish it with RET.  `M-x' uses the minibuffer to
read the command name.  RET exits the minibuffer and runs the command.

  Emacs uses the minibuffer for reading input for many different
purposes; on this occasion, the string `M-x' is displayed at the
beginning of the minibuffer as a "prompt" to remind you that your
input should be the name of a command to be run.  *Note Minibuffer::,
for full information on the features of the minibuffer.

  You can use completion to enter the command name.  For example, the
command `forward-char' can be invoked by name by typing

     M-x forward-char RET
or

          M-x fo TAB c RET

Note that `forward-char' is the same command that you invoke with the
key `C-f'.  Any command (interactively callable function) defined in
Emacs can be called by its name using `M-x' whether or not any keys
are bound to it.

  If you type `C-g' while the command name is being read, you cancel
the `M-x' command and get out of the minibuffer, ending up at top
level.

  To pass a numeric argument to the command you are invoking with
`M-x', specify the numeric argument before the `M-x'.  `M-x' passes
the argument along to the function which it calls.  The argument
value appears in the prompt while the command name is being read.

  Normally, when describing a command that is run by name, we omit the
RET that is needed to terminate the name.  Thus we might speak of
`M-x auto-fill-mode' rather than `M-x auto-fill-mode RET'.  We
mention the RET only when there is a need to emphasize its presence,
such as when describing a sequence of input that contains a command
name and arguments that follow it.

  `M-x' is defined to run the command `execute-extended-command', which
is responsible for reading the name of another command and invoking it.



File: emacs,  Node: Help,  Next: Mark,  Prev: M-x,  Up: Top

Help
****

  Emacs provides extensive help features which revolve around a single
character, `C-h'.  `C-h' is a prefix key that is used only for
documentation-printing commands.  The characters that you can type
after `C-h' are called "help options".  One help option is `C-h';
that is how you ask for help about using `C-h'.

  `C-h C-h' prints a list of the possible help options, and then asks
you to go ahead and type the option.  It prompts with a string

     A, B, C, F, I, K, L, M, N, S, T, V, W, C-c, C-d, C-n, C-w or C-h for more help:

and you should type one of those characters.

  Typing a third `C-h' displays a description of what the options mean;
it still waits for you to type an option.  To cancel, type `C-g'.

  Here is a summary of the defined help commands.

`C-h a STRING RET'
     Display list of commands whose names contain STRING
     (`command-apropos').

`C-h b'
     Display a table of all key bindings in effect now; local
     bindings of the current major mode first, followed by all global
     bindings (`describe-bindings').

`C-h c KEY'
     Print the name of the command that KEY runs
     (`describe-key-briefly').  `c' is for `character'.  For more
     extensive information on KEY, use `C-h k'.

`C-h f FUNCTION RET'
     Display documentation on the Lisp function named FUNCTION
     (`describe-function').  Note that commands are Lisp functions,
     so a command name may be used.

`C-h i'
     Run Info, the program for browsing documentation files (`info').
     The complete Emacs manual is available on-line in Info.

`C-h k KEY'
     Display name and documentation of the command KEY runs
     (`describe-key').

`C-h l'
     Display a description of the last 100 characters you typed
     (`view-lossage').

`C-h m'
     Display documentation of the current major mode (`describe-mode').

`C-h n'
     Display documentation of Emacs changes, most recent first
     (`view-emacs-news').

`C-h s'
     Display current contents of the syntax table, plus an
     explanation of what they mean (`describe-syntax').

`C-h t'
     Display the Emacs tutorial (`help-with-tutorial').

`C-h v VAR RET'
     Display the documentation of the Lisp variable VAR
     (`describe-variable').

`C-h w COMMAND RET'
     Print which keys run the command named COMMAND (`where-is').

Documentation for a Key
=======================

  The most basic `C-h' options are `C-h c' (`describe-key-briefly') and
`C-h k' (`describe-key').  `C-h c KEY' prints in the echo area the
name of the command that KEY is bound to.  For example, `C-h c C-f'
prints `forward-char'.  Since command names are chosen to describe
what the command does, this is a good way to get a very brief
description of what KEY does.

  `C-h k KEY' is similar but gives more information.  It displays the
documentation string of the command KEY is bound to as well as its
name.  This is too big for the echo area, so a window is used for the
display.

Help by Command or Variable Name
================================

  `C-h f' (`describe-function') reads the name of a Lisp function using
the minibuffer, then displays that function's documentation string in
a window.  Since commands are Lisp functions, you can use this to get
the documentation of a command that is known by name.  For example,

     C-h f auto-fill-mode RET

displays the documentation of `auto-fill-mode'.  This is the only way
to see the documentation of a command that is not bound to any key
(one which you would normally call using `M-x').

  `C-h f' is also useful for Lisp functions that you are planning to
use in a Lisp program.  For example, if you have just written the
code `(make-vector len)' and want to be sure that you are using
`make-vector' properly, type `C-h f make-vector RET'.  Because `C-h
f' allows all function names, not just command names, you may find
that some of your favorite abbreviations that work in `M-x' don't
work in `C-h f'.  An abbreviation may be unique among command names
yet fail to be unique when other function names are allowed.

  The function name for `C-h f' to describe has a default which is used
if you type RET leaving the minibuffer empty.  The default is the
function called by the innermost Lisp expression in the buffer around
point, provided that is a valid, defined Lisp function name.  For
example, if point is located following the text `(make-vector (car
x)', the innermost list containing point is the one that starts with
`(make-vector', so the default is to describe the function
`make-vector'.

  `C-h f' is often useful just to verify that you have the right
spelling for the function name.  If `C-h f' mentions a default in the
prompt, you have typed the name of a defined Lisp function.  If that
tells you what you want to know, just type `C-g' to cancel the `C-h
f' command and go on editing.

  `C-h w COMMAND RET' tells you what keys are bound to COMMAND.  It
prints a list of the keys in the echo area.  Alternatively, it says
that the command is not on any keys, which implies that you must use
`M-x' to call it.

  `C-h v' (`describe-variable') is like `C-h f' but describes Lisp
variables instead of Lisp functions.  Its default is the Lisp symbol
around or before point, but only if that is the name of a known Lisp
variable.  *Note Variables::.

Apropos
=======

  A more sophisticated sort of question to ask is, "What are the
commands for working with files?"  For this, type `C-h a file RET',
which displays a list of all command names that contain `file', such
as `copy-file', `find-file', and so on.  With each command name
appears a brief description of how to use the command, and what keys
you can currently invoke it with.  For example, it would say that you
can invoke `find-file' by typing `C-x C-f'.  The `a' in `C-h a'
stands for `Apropos'; `C-h a' runs the Lisp function `command-apropos'.

  Because `C-h a' looks only for functions whose names contain the
string which you specify, you must use ingenuity in choosing the
string.  If you are looking for commands for killing backwards and
`C-h a kill-backwards RET' doesn't reveal any, don't give up.  Try
just `kill', or just `backwards', or just `back'.  Be persistent. 
Pretend you are playing Adventure.  Also note that you can use a
regular expression as the argument (*note Regexps::.).

  Here is a set of arguments to give to `C-h a' that covers many
classes of Emacs commands, since there are strong conventions for
naming the standard Emacs commands.  By giving you a feel for the
naming conventions, this set should also serve to aid you in
developing a technique for picking `apropos' strings.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, buffer, screen, window, file, dir, register, mode,
     beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, fill, indent,
     case, change, set, what, list, find, view, describe.

  To list all Lisp symbols that contain a match for a regexp, not just
the ones that are defined as commands, use the command `M-x apropos'
instead of `C-h a'.

Other Help Commands
===================

  `C-h i' (`info') runs the Info program, which is used for browsing
through structured documentation files.  The entire Emacs manual is
available within Info.  Eventually all the documentation of the GNU
system will be available.  Type `h' after entering Info to run a
tutorial on using Info.

  If something surprising happens, and you are not sure what commands
you typed, use `C-h l' (`view-lossage').  `C-h l' prints the last 100
command characters you typed in.  If you see commands that you don't
know, you can use `C-h c' to find out what they do.

  Emacs has several major modes, each of which redefines a few keys and
makes a few other changes in how editing works.  `C-h m'
(`describe-mode') prints documentation on the current major mode,
which normally describes all the commands that are changed in this
mode.

  `C-h b' (`describe-bindings') and `C-h s' (`describe-syntax') present
other information about the current Emacs mode.  `C-h b' displays a
list of all the key bindings now in effect; the local bindings of the
current major mode first, followed by the global bindings (*note Key
Bindings::.).  `C-h s' displays the contents of the syntax table,
with explanations of each character's syntax (*note Syntax::.).

  The other `C-h' options display various files of useful information. 
`C-h C-w' displays the full details on the complete absence of
warranty for GNU Emacs.  `C-h n' (`view-emacs-news') displays the
file `emacs/etc/NEWS', which contains documentation on Emacs changes
arranged chronologically.  `C-h t' (`help-with-tutorial') displays
the learn-by-doing Emacs tutorial.  `C-h C-c' (`describe-copying')
displays the file `emacs/etc/COPYING', which tells you the conditions
you must obey in distributing copies of Emacs.  `C-h C-d'
(`describe-distribution') displays another file named
`emacs/etc/DISTRIB', which tells you how you can order a copy of the
latest version of Emacs.



File: emacs,  Node: Mark,  Next: Killing,  Prev: Help,  Up: Top

The Mark and the Region
***********************

  There are many Emacs commands which operate on an arbitrary
contiguous part of the current buffer.  To specify the text for such
a command to operate on, you set "the mark" at one end of it, and
move point to the other end.  The text between point and the mark is
called "the region".  You can move point or the mark to adjust the
boundaries of the region.  It doesn't matter which one is set first
chronologically, or which one comes earlier in the text.

  Once the mark has been set, it remains until it is set again at
another place.  The mark remains fixed with respect to the preceding
character if text is inserted or deleted in the buffer.  Each Emacs
buffer has its own mark, so that when you return to a buffer that had
been selected previously, it has the same mark it had before.

  Many commands that insert text, such as `C-y' (`yank') and `M-x
insert-buffer', position the mark at one end of the inserted
text--the opposite end from where point is positioned, so that the
region contains the text just inserted.

  Aside from delimiting the region, the mark is also useful for
remembering a spot that you may want to go back to.  To make this
feature more useful, Emacs remembers 16 previous locations of the
mark, in the `mark ring'.

* Menu:

* Setting Mark::	Commands to set the mark.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   Previous mark positions saved so you can go back there.

 

File: emacs,  Node: Setting Mark,  Next: Using Region,  Prev: Mark,  Up: Mark

Setting the Mark
================

  Here are some commands for setting the mark:

`C-SPC'
     Set the mark where point is (`set-mark-command').

`C-@'
     The same.

`C-x C-x'
     Interchange mark and point (`exchange-point-and-mark').

  For example, if you wish to convert part of the buffer to all
upper-case, you can use the `C-x C-u' (`upcase-region') command,
which operates on the text in the region.  You can first go to the
beginning of the text to be capitalized, type `C-SPC' to put the mark
there, move to the end, and then type `C-x C-u'.  Or, you can set the
mark at the end of the text, move to the beginning, and then type
`C-x C-u'.  Most commands that operate on the text in the region have
the word `region' in their names.

  The most common way to set the mark is with the `C-SPC' command
(`set-mark-command').  This sets the mark where point is.  Then you
can move point away, leaving the mark behind.  It is actually
incorrect to speak of the character `C-SPC'; there is no such
character.  When you type SPC while holding down CTRL, what you get
on most terminals is the character `C-@'.  This is the key actually
bound to `set-mark-command'.  But unless you are unlucky enough to
have a terminal where typing `C-SPC' does not produce `C-@', you
might as well think of this character as `C-SPC'.

  Since terminals have only one cursor, there is no way for Emacs to
show you where the mark is located.  You have to remember.  The usual
solution to this problem is to set the mark and then use it soon,
before you forget where it is.  But you can see where the mark is
with the command `C-x C-x' (`exchange-point-and-mark') which puts the
mark where point was and point where the mark was.  The extent of the
region is unchanged, but the cursor and point are now at the previous
location of the mark.

  `C-x C-x' is also useful when you are satisfied with the location of
point but want to move the mark; do `C-x C-x' to put point there and
then you can move it.  A second use of `C-x C-x', if necessary, puts
the mark at the new location with point back at its original location.



File: emacs,  Node: Using Region,  Next: Marking Objects,  Prev: Setting Mark,  Up: Mark

Operating on the Region
=======================

  Once you have created an active region, you can do many things to the
text in it:

   * Kill it with `C-w' (*note Killing::.).

   * Save it in a register with `C-x x' (*note Registers::.).

   * Save it in a buffer or a file (*note Accumulating Text::.).

   * Convert case with `C-x C-l' or `C-x C-u' 
     (*note Case::.).

   * Evaluate it as Lisp code with `M-x eval-region' (*note Lisp
     Eval::.).

   * Fill it as text with `M-g' (*note Filling::.).

   * Print hardcopy with `M-x print-region' (*note Hardcopy::.).

   * Indent it with `C-x TAB' or `C-M-\' (*note Indentation::.).



File: emacs,  Node: Marking Objects,  Next: Mark Ring,  Prev: Using Region,  Up: Mark

Commands to Mark Textual Objects
================================

  There are commands for placing point and the mark around a textual
object such as a word, list, paragraph or page.

`M-@'
     Set mark after end of next word (`mark-word').  This command and
     the following one do not move point.

`C-M-@'
     Set mark after end of next Lisp expression (`mark-sexp').

`M-h'
     Put region around current paragraph (`mark-paragraph').

`C-M-h'
     Put region around current Lisp defun (`mark-defun').

`C-x h'
     Put region around entire buffer (`mark-whole-buffer').

`C-x C-p'
     Put region around current page (`mark-page').

`M-@' (`mark-word') puts the mark at the end of the next word, while
`C-M-@' (`mark-sexp') puts it at the end of the next Lisp expression.
These characters allow you to save a little typing or redisplay,
sometimes.

   Other commands set both point and mark, to delimit an object in the
buffer.  `M-h' (`mark-paragraph') moves point to the beginning of the
paragraph that surrounds or follows point, and puts the mark at the
end of that paragraph (*note Paragraphs::.).  `M-h' does all that's
necessary if you wish to indent, case-convert, or kill a whole
paragraph.  `C-M-h' (`mark-defun') similarly puts point before and
the mark after the current or following defun (*note Defuns::.). 
`C-x C-p' (`mark-page') puts point before the current page (or the
next or previous, according to the argument), and mark at the end
(*note Pages::.).  The mark goes after the terminating page delimiter
(to include it), while point goes after the preceding page delimiter
(to exclude it).  Finally, `C-x h' (`mark-whole-buffer') sets up the
entire buffer as the region, by putting point at the beginning and
the mark at the end.



File: emacs,  Node: Mark Ring,  Prev: Marking Objects,  Up: Mark

The Mark Ring
=============

  Aside from delimiting the region, the mark is also useful for
remembering a spot that you may want to go back to.  To make this
feature more useful, Emacs remembers 16 previous locations of the
mark, in the "mark ring".  Most commands that set the mark push the
old mark onto this ring.  To return to a marked location, use `C-u
C-SPC' (or `C-u C-@'); this is the command `set-mark-command' given a
numeric argument.  It moves point to where the mark was, and restores
the mark from the ring of former marks.  So repeated use of this
command moves point to all of the old marks on the ring, one by one. 
The marks you see go to the end of the ring, so no marks are lost.

  Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, `C-u C-SPC' always stays
in the same buffer.

  Many commands that can move long distances, such as `M-<'
(`beginning-of-buffer'), start by setting the mark and saving the old
mark on the mark ring.  This is to make it easier for you to move
back later.  Searches do this except when they do not actually move
point.  You can tell when a command sets the mark because `Mark Set'
is printed in the echo area.

  The variable `mark-ring-max' is the maximum number of entries to keep
in the mark ring.  If that many entries exist and another one is
pushed, the last one in the list is discarded.  Repeating `C-u C-SPC'
circulates through the limited number of entries that are currently
in the ring.

  The variable `mark-ring' holds the mark ring itself, as a list of
marker objects in the order most recent first.  This variable is
local in every buffer.



File: emacs,  Node: Killing,  Next: Yanking,  Prev: Mark,  Up: Top

Deletion and Killing
====================

  Most commands which erase text from the buffer save it so that you
can get it back if you change your mind, or move or copy it to other
parts of the buffer.  These commands are known as "kill" commands. 
The rest of the commands that erase text do not save it; they are
known as "delete" commands.  (This distinction is made only for
erasure of text in the buffer.)

  The delete commands include `C-d' (`delete-char') and DEL
(`delete-backward-char'), which delete only one character at a time,
and those commands that delete only spaces or newlines.  Commands
that can destroy significant amounts of nontrivial data generally kill.
The commands' names and individual descriptions use the words `kill'
and `delete' to say which they do.  If you do a kill or delete
command by mistake, you can use the `C-x u' (`undo') command to undo
it (*note Undo::.).

Deletion
--------

`C-d'
     Delete next character (`delete-char').

`DEL'
     Delete previous character (`delete-backward-char').

`M-\'
     Delete spaces and tabs around point (`delete-horizontal-space').

`M-SPC'
     Delete spaces and tabs around point, leaving one space
     (`just-one-space').

`C-x C-o'
     Delete blank lines around the current line (`delete-blank-lines').

`M-^'
     Join two lines by deleting the intervening newline, and any
     indentation following it (`delete-indentation').

  The most basic delete commands are `C-d' (`delete-char') and DEL
(`delete-backward-char').  `C-d' deletes the character after point,
the one the cursor is "on top of".  Point doesn't move.  DEL deletes
the character before the cursor, and moves point back.  Newlines can
be deleted like any other characters in the buffer; deleting a
newline joins two lines.  Actually, `C-d' and DEL aren't always
delete commands; if given an argument, they kill instead, since they
can erase more than one character this way.

  The other delete commands are those which delete only formatting
characters: spaces, tabs and newlines.  `M-\'
(`delete-horizontal-space') deletes all the spaces and tab characters
before and after point.  `M-SPC' (`just-one-space') does likewise but
leaves a single space after point, regardless of the number of spaces
that existed previously (even zero).

  `C-x C-o' (`delete-blank-lines') deletes all blank lines after the
current line, and if the current line is blank deletes all blank
lines preceding the current line as well (leaving one blank line, the
current line).  `M-^' (`delete-indentation') joins the current line
and the previous line, or the current line and the next line if given
an argument, by deleting a newline and all surrounding spaces,
possibly leaving a single space.  *Note M-^: Indentation.

Killing by Lines
----------------

`C-k'
     Kill rest of line or one or more lines (`kill-line').

  The simplest kill command is `C-k'.  If given at the beginning of a
line, it kills all the text on the line, leaving it blank.  If given
on a blank line, the blank line disappears.  As a consequence, if you
go to the front of a non-blank line and type `C-k' twice, the line
disappears completely.

  More generally, `C-k' kills from point up to the end of the line,
unless it is at the end of a line.  In that case it kills the newline
following the line, thus merging the next line into the current one. 
Invisible spaces and tabs at the end of the line are ignored when
deciding which case applies, so if point appears to be at the end of
the line, you can be sure the newline will be killed.

  If `C-k' is given a positive argument, it kills that many lines and
the newlines that follow them (however, text on the current line
before point is spared).  With a negative argument, it kills back to
a number of line beginnings.  An argument of -2 means kill back to
the second line beginning.  If point is at the beginning of a line,
that line beginning doesn't count, so `C-u - 2 C-k' with point at the
front of a line kills the two previous lines.

  `C-k' with an argument of zero kills all the text before point on the
current line.

Other Kill Commands
-------------------

`C-w'
     Kill region (from point to the mark) (`kill-region').  *Note
     Words::.

`M-d'
     Kill word (`kill-word').

`M-DEL'
     Kill word backwards (`backward-kill-word').

`C-x DEL'
     Kill back to beginning of sentence (`backward-kill-sentence'). 
     *Note Sentences::.

`M-k'
     Kill to end of sentence (`kill-sentence').

`C-M-k'
     Kill sexp (`kill-sexp').  *Note Lists::.

`M-z CHAR'
     Kill up to next occurrence of CHAR (`zap-to-char').

  A kill command which is very general is `C-w' (`kill-region'), which
kills everything between point and the mark.  With this command, you
can kill any contiguous sequence of characters, if you first set the
mark at one end of them and go to the other end.

  A convenient way of killing is combined with searching: `M-z'
(`zap-to-char') reads a character and kills from point up to (but not
including) the next occurrence of that character in the buffer.  If
there is no next occurrence, killing goes to the end of the buffer. 
A numeric argument acts as a repeat count.  A negative argument means
to search backward and kill text before point.

  Other syntactic units can be killed: words, with `M-DEL' and `M-d'
(*note Words::.); sexps, with `C-M-k' (*note Lists::.); and
sentences, with `C-x DEL' and `M-k' (*note Sentences::.).



File: emacs,  Node: Yanking,  Next: Accumulating Text,  Prev: Killing,  Up: Top

Yanking
=======

  "Yanking" is getting back text which was killed.  This is what some
systems call "pasting".  The usual way to move or copy text is to
kill it and then yank it one or more times.

`C-y'
     Yank last killed text (`yank').

`M-y'
     Replace re-inserted killed text with the previously killed text
     (`yank-pop').

`M-w'
     Save region as last killed text without actually killing it
     (`copy-region-as-kill').

`C-M-w'
     Append next kill to last batch of killed text
     (`append-next-kill').

* Menu:

* Kill Ring::       Where killed text is stored.  Basic yanking.
* Appending Kills:: Several kills in a row all yank together.
* Earlier Kills::   Yanking something killed some time ago.

 

File: emacs,  Node: Kill Ring,  Next: Appending Kills,  Prev: Yanking,  Up: Yanking

The Kill Ring
-------------

  All killed text is recorded in the "kill ring", a list of blocks of
text that have been killed.  There is only one kill ring, used in all
buffers, so you can kill text in one buffer and yank it in another
buffer.  This is the usual way to move text from one file to another.
(*Note Accumulating Text::, for some other ways.)

  The command `C-y' (`yank') reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text.  It sets the mark
at the beginning of the text.  *Note Mark::.

  `C-u C-y' leaves the cursor in front of the text, and sets the mark
after it.  This is only if the argument is specified with just a
`C-u', precisely.  Any other sort of argument, including `C-u' and
digits, has an effect described below (under "Yanking Earlier Kills").

  If you wish to copy a block of text, you might want to use `M-w'
(`copy-region-as-kill'), which copies the region into the kill ring
without removing it from the buffer.  This is approximately
equivalent to `C-w' followed by `C-y', except that `M-w' does not
mark the buffer as "modified" and does not temporarily change the
screen.



File: emacs,  Node: Appending Kills,  Next: Earlier Kills,  Prev: Kill Ring,  Up: Yanking

Appending Kills
---------------

  Normally, each kill command pushes a new block onto the kill ring. 
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' gets it all back as it was
before it was killed.  This means that you don't have to kill all the
text in one command; you can keep killing line after line, or word
after word, until you have killed it all, and you can still get it
all back at once.  (Thus we join television in leading people to kill
thoughtlessly.)

  Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add
onto the beginning.  This way, any sequence of mixed forward and
backward kill commands puts all the killed text into one entry
without rearrangement.  Numeric arguments do not break the sequence
of appending kills.  For example, suppose the buffer contains

     This is the first
     line of sample text
     and here is the third.

 with point at the beginning of the second line.  If you type `C-k C-u
2 M-DEL C-k', the first `C-k' kills the text `line of sample text',
`C-u 2 M-DEL' kills `the first' with the newline that followed it,
and the second `C-k' kills the newline after the second line.  The
result is that the buffer contains `This is and here is the third.'
and a single kill entry contains `the firstRETline of sample
textRET'--all the killed text, in its original order.

  If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the
kill ring.  But you can force it to append by first typing the
command `C-M-w' (`append-next-kill') in front of it.  The `C-M-w'
tells the following command, if it is a kill command, to append the
text it kills to the last killed text, instead of starting a new
entry.  With `C-M-w', you can kill several separated pieces of text
and accumulate them to be yanked back in one place.



File: emacs,  Node: Earlier Kills,  Prev: Appending Kills,  Up: Yanking

Yanking Earlier Kills
---------------------

  To recover killed text that is no longer the most recent kill, you
need the `Meta-y' (`yank-pop') command.  `M-y' can be used only after
a `C-y' or another `M-y'.  It takes the text previously yanked and
replaces it with the text from an earlier kill.  So, to recover the
text of the next-to-the-last kill, you first use `C-y' to recover the
last kill, and then use `M-y' to replace it with the previous kill.

  You can think in terms of a "last yank" pointer which points at an
item in the kill ring.  Each time you kill, the "last yank" pointer
moves to the newly made item at the front of the ring.  `C-y' yanks
the item which the "last yank" pointer points to.  `M-y' moves the
"last yank" pointer to a different item, and the text in the buffer
changes to match.  Enough `M-y' commands can move the pointer to any
item in the ring, so you can get any item into the buffer. 
Eventually the pointer reaches the end of the ring; the next `M-y'
moves it to the first item again.

  Yanking moves the "last yank" pointer around the ring, but it does
not change the order of the entries in the ring, which always runs
from the most recent kill at the front to the oldest one still
remembered.

  `M-y' can take a numeric argument, which tells it how many items to
advance the "last yank" pointer by.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves to the last entry and starts moving forward from there.

  Once the text you are looking for is brought into the buffer, you can
stop doing `M-y' commands and it will stay there.  It's just a copy
of the kill ring item, so editing it in the buffer does not change
what's in the ring.  As long as no new killing is done, the "last
yank" pointer remains at the same place in the kill ring, so
repeating `C-y' will yank another copy of the same old kill.

  If you know how many `M-y' commands it would take to find the text
you want, you can yank that text in one step using `C-y' with a
numeric argument.  `C-y' with an argument greater than one restores
the text the specified number of entries back in the kill ring. 
Thus, `C-u 2 C-y' gets the next to the last block of killed text.  It
is equivalent to `C-y M-y'.  `C-y' with a numeric argument starts
counting from the "last yank" pointer, and sets the "last yank"
pointer to the entry that it yanks.

  The length of the kill ring is controlled by the variable
`kill-ring-max'; no more than that many blocks of killed text are
saved.



File: emacs,  Node: Accumulating Text,  Next: Rectangles,  Prev: Yanking,  Up: Top

Accumulating Text
=================

  Usually we copy or move text by killing it and yanking it, but there
are other ways that are useful for copying one block of text in many
places, or for copying many scattered blocks of text into one place.

  You can accumulate blocks of text from scattered locations either
into a buffer or into a file if you like.  These commands are
described here.  You can also use Emacs registers for storing and
accumulating text.  *Note Registers::.

`C-x a'
     Append region to contents of specified buffer
     (`append-to-buffer').

`M-x prepend-to-buffer'
     Prepend region to contents of specified buffer.

`M-x copy-to-buffer'
     Copy region into specified buffer, deleting that buffer's old
     contents.

`M-x insert-buffer'
     Insert contents of specified buffer into current buffer at point.

`M-x append-to-file'
     Append region to contents of specified file, at the end.

  To accumulate text into a buffer, use the command `C-x a BUFFERNAME'
(`append-to-buffer'), which inserts a copy of the region into the
buffer BUFFERNAME, at the location of point in that buffer.  If there
is no buffer with that name, one is created.  If you append text into
a buffer which has been used for editing, the copied text goes into
the middle of the text of the buffer, wherever point happens to be in
it.

  Point in that buffer is left at the end of the copied text, so
successive uses of `C-x a' accumulate the text in the specified
buffer in the same order as they were copied.  Strictly speaking,
`C-x a' does not always append to the text already in the buffer; but
if `C-x a' is the only command used to alter a buffer, it does always
append to the existing text because point is always at the end.

  `M-x prepend-to-buffer' is just like `C-x a' except that point in the
other buffer is left before the copied text, so successive
prependings add text in reverse order.  `M-x copy-to-buffer' is
similar except that any existing text in the other buffer is deleted,
so the buffer is left containing just the text newly copied into it.

  You can retrieve the accumulated text from that buffer with `M-x
insert-buffer'; this too takes BUFFERNAME as an argument.  It inserts
a copy of the text in buffer BUFFERNAME into the selected buffer. 
You could alternatively select the other buffer for editing, perhaps
moving text from it by killing or with `C-x a'.  *Note Buffers::, for
background information on buffers.

  Instead of accumulating text within Emacs, in a buffer, you can
append text directly into a file with `M-x append-to-file', which
takes FILE-NAME as an argument.  It adds the text of the region to
the end of the specified file.  The file is changed immediately on
disk. This command is normally used with files that are not being
visited in Emacs.  Using it on a file that Emacs is visiting can
produce confusing results, because the text inside Emacs for that
file will not change while the file itself changes.



File: emacs,  Node: Rectangles,  Next: Registers,  Prev: Accumulating Text,  Up: Top

Rectangles
==========

  The rectangle commands affect rectangular areas of the text: all the
characters between a certain pair of columns, in a certain range of
lines.  Commands are provided to kill rectangles, yank killed
rectangles, clear them out, or delete them.  Rectangle commands are
useful with text in multicolumnar formats, such as perhaps code with
comments at the right, or for changing text into or out of such
formats.

  When you must specify a rectangle for a command to work on, you do it
by putting the mark at one corner and point at the opposite corner. 
The rectangle thus specified is called the "region-rectangle" because
it is controlled about the same way the region is controlled.  But
remember that a given combination of point and mark values can be
interpreted either as specifying a region or as specifying a
rectangle; it is up to the command that uses them to choose the
interpretation.

`M-x delete-rectangle'
     Delete the text of the region-rectangle, moving any following
     text on each line leftward to the left edge of the
     region-rectangle.

`M-x kill-rectangle'
     Similar, but also save the contents of the region-rectangle as
     the "last killed rectangle".

`M-x yank-rectangle'
     Yank the last killed rectangle with its upper left corner at
     point.

`M-x open-rectangle'
     Insert blank space to fill the space of the region-rectangle. 
     The previous contents of the region-rectangle are pushed
     rightward.

`M-x clear-rectangle'
     Clear the region-rectangle by replacing its contents with spaces.

  The rectangle operations fall into two classes: commands deleting and
moving rectangles, and commands for blank rectangles.

  There are two ways to get rid of the text in a rectangle: you can
discard the text (delete it) or save it as the "last killed"
rectangle.  The commands for these two ways are `M-x
delete-rectangle' and `M-x kill-rectangle'.  In either case, the
portion of each line that falls inside the rectangle's boundaries is
deleted, causing following text (if any) on the line to move left.

  Note that "killing" a rectangle is not killing in the usual sense;
the rectangle is not stored in the kill ring, but in a special place
that can only record the most recent rectangle killed.  This is
because yanking a rectangle is so different from yanking linear text
that different yank commands have to be used and yank-popping is hard
to make sense of.

  Inserting a rectangle is the opposite of deleting one.  All you need
to specify is where to put the upper left corner; that is done by
putting point there.  The rectangle's first line is inserted there,
the rectangle's second line is inserted at a point one line
vertically down, and so on.  The number of lines affected is
determined by the height of the saved rectangle.

  To insert the last killed rectangle, type `M-x yank-rectangle'.  This
can be used to convert single-column lists into double-column lists;
kill the second half of the list as a rectangle and then yank it
beside the first line of the list.

  There are two commands for working with blank rectangles: `M-x
clear-rectangle' to blank out existing text, and `M-x open-rectangle'
to insert a blank rectangle.  Clearing a rectangle is equivalent to
deleting it and then inserting as blank rectangle of the same size.

  Rectangles can also be copied into and out of registers.  *Note
Rectangle Registers: RegRect.



File: emacs,  Node: Registers,  Next: Display,  Prev: Rectangles,  Up: Top

Registers
*********

  Emacs "registers" are places you can save text or positions for later
use.  Text saved in a register can be copied into the buffer once or
many times; a position saved in a register is used by moving point to
that position.  Rectangles can also be copied into and out of
registers (*note Rectangles::.).

  Each register has a name, which is a single character.  A register
can store either a piece of text or a position or a rectangle, but
only one thing at any given time.  Whatever you store in a register
remains there until you store something else in that register.

* Menu:

* RegPos::    Saving positions in registers.
* RegText::   Saving text in registers.
* RegRect::   Saving rectangles in registers.

`M-x view-register RET R'
     Display a description of what register R contains.

  `M-x view-register' reads a register name as an argument and then
displays the contents of the specified register.



File: emacs,  Node: RegPos,  Next: RegText,  Prev: Registers,  Up: Registers

Saving Positions in Registers
=============================

  Saving a position records a spot in a buffer so that you can move
back there later.  Moving to a saved position reselects the buffer
and moves point to the spot.

`C-x / R'
     Save location of point in register R (`point-to-register').

`C-x j R'
     Jump to the location saved in register R (`register-to-point').

  To save the current location of point in a register, choose a name R
and type `C-x / R'.  The register R retains the location thus saved
until you store something else in that register.

  The command `C-x j R' moves point to the location recorded in
register R.  The register is not affected; it continues to record the
same location.  You can jump to the same position using the same
register any number of times.



File: emacs,  Node: RegText,  Next: RegRect,  Prev: RegPos,  Up: Registers

Saving Text in Registers
========================

  When you want to insert a copy of the same piece of text frequently,
it may be impractical to use the kill ring, since each subsequent
kill moves the piece of text further down on the ring.  It becomes
hard to keep track of what argument is needed to retrieve the same
text with `C-y'.  An alternative is to store the text in a register
with `C-x x' (`copy-to-register') and then retrieve it with `C-x g'
(`insert-register').

`C-x x R'
     Copy region into register R (`copy-to-register').

`C-x g R'
     Insert text contents of register R (`insert-register').

  `C-x x R' stores a copy of the text of the region into the register
named R.  Given a numeric argument, `C-x x' deletes the text from the
buffer as well.

  `C-x g R' inserts in the buffer the text from register R.  Normally
it leaves point before the text and places the mark after, but with a
numeric argument it puts point after the text and the mark before.



File: emacs,  Node: RegRect,  Prev: RegText,  Up: Registers

Saving Rectangles in Registers
==============================

  A register can contain a rectangle instead of linear text.  The
rectangle is represented as a list of strings.  *Note Rectangles::,
for basic information on rectangles and how rectangles in the buffer
are specified.

`C-x r R'
     Copy the region-rectangle into register R 
     (`copy-region-to-rectangle').  With numeric argument, delete it
     as well.

`C-x g R'
     Insert the rectangle stored in register R (if it contains a
     rectangle) (`insert-register').

  The `C-x g' command inserts linear text if the register contains
that, or inserts a rectangle if the register contains one.



File: emacs,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

Controlling the Display
***********************

  Since only part of a large buffer fits in the window, Emacs tries to
show the part that is likely to be interesting.  The display control
commands allow you to specify which part of the text you want to see.

`C-l'
     Clear screen and redisplay, scrolling the selected window to
     center point vertically within it (`recenter').

`C-v'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`M-v'
     Scroll backward (`scroll-down').

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

`C-x $'
     Make deeply indented lines invisible (`set-selective-display').

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Selective Display::      Hiding lines with lots of indentation.
* Display Vars::           Information on variables for customizing display.

 

File: emacs,  Node: Scrolling,  Next: Horizontal Scrolling,  Prev: Display,  Up: Display

Scrolling
=========

  If a buffer contains text that is too large to fit entirely within a
window that is displaying the buffer, Emacs shows a contiguous
section of the text.  The section shown always contains point.

  "Scrolling" means moving text up or down in the window so that
different parts of the text are visible.  Scrolling forward means
that text moves up, and new text appears at the bottom.  Scrolling
backward moves text down and new text appears at the top.

  Scrolling happens automatically if you move point past the bottom or
top of the window.  You can also explicitly request scrolling with
the commands in this section.

`C-l'
     Clear screen and redisplay, scrolling the selected window to
     center point vertically within it (`recenter').

`C-v'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`M-v'
     Scroll backward (`scroll-down').

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

  The most basic scrolling command is `C-l' (`recenter') with no
argument.  It clears the entire screen and redisplays all windows. 
In addition, the selected window is scrolled so that point is halfway
down from the top of the window.

  The scrolling commands `C-v' and `M-v' let you move all the text in
the window up or down a few lines.  `C-v' (`scroll-up') with an
argument shows you that many more lines at the bottom of the window,
moving the text and point up together as `C-l' might.  `C-v' with a
negative argument shows you more lines at the top of the window. 
`Meta-v' (`scroll-down') is like `C-v', but moves in the opposite
direction.

  To read the buffer a windowful at a time, use `C-v' with no argument.
It takes the last two lines at the bottom of the window and puts them
at the top, followed by nearly a whole windowful of lines not
previously visible.  If point was in the text scrolled off the top,
it moves to the new top of the window.  `M-v' with no argument moves
backward with overlap similarly.  The number of lines of overlap
across a `C-v' or `M-v' is controlled by the variable
`next-screen-context-lines'; by default, it is two.

  Another way to do scrolling is with `C-l' with a numeric argument. 
`C-l' does not clear the screen when given an argument; it only
scrolls the selected window.  With a positive argument N, it
repositions text to put point N lines down from the top.  An argument
of zero puts point on the very top line.  Point does not move with
respect to the text; rather, the text and point move rigidly on the
screen.  `C-l' with a negative argument puts point that many lines
from the bottom of the window.  For example, `C-u - 1 C-l' puts point
on the bottom line, and `C-u - 5 C-l' puts it five lines from the
bottom.  Just `C-u' as argument, as in `C-u C-l', scrolls point to
the center of the screen.

  Scrolling happens automatically if point has moved out of the visible
portion of the text when it is time to display.  Usually the
scrolling is done so as to put point vertically centered within the
window.  However, if the variable `scroll-step' has a nonzero value,
an attempt is made to scroll the buffer by that many lines; if that
is enough to bring point back into visibility, that is what is done.



File: emacs,  Node: Horizontal Scrolling,  Prev: Scrolling,  Up: Display

Horizontal Scrolling
====================

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

  The text in a window can also be scrolled horizontally.  This means
that each line of text is shifted sideways in the window, and one or
more characters at the beginning of each line are not displayed at
all.  When a window has been scrolled horizontally in this way, text
lines are truncated rather than continued (*note Continuation
Lines::.), with a `$' appearing in the first column when there is
text truncated to the left, and in the last column when there is text
truncated to the right.

  The command `C-x <' (`scroll-left') scrolls the selected window to
the left by N columns with argument N.  With no argument, it scrolls
by almost the full width of the window (two columns less, to be
precise).  `C-x >' (`scroll-right') scrolls similarly to the right. 
The window cannot be scrolled any farther to the right once it is
displaying normally (with each line starting at the window's left
margin); attempting to do so has no effect.



File: emacs,  Node: Selective Display,  Next: Display Vars,  Prev: Display,  Up: Display

Selective Display
=================

  Emacs has the ability to hide lines indented more than a certain
number of columns (you specify how many columns).  You can use this
to get an overview of a part of a program.

  To hide lines, type `C-x $' (`set-selective-display') with a numeric
argument N.  (*Note Arguments::, for how to give the argument.)  Then
lines with at least N columns of indentation disappear from the
screen.  The only indication of their presence is that three dots
(`...') appear at the end of each visible line that is followed by
one or more invisible ones.

  The invisible lines are still present in the buffer, and most editing
commands see them as usual, so it is very easy to put point in the
middle of invisible text.  When this happens, the cursor appears at
the end of the previous line, after the three dots.  If point is at
the end of the visible line, before the newline that ends it, the
cursor appears before the three dots.

  The commands `C-n' and `C-p' move across the invisible lines as if
they were not there.

  To make everything visible again, type `C-x $' with no argument.


