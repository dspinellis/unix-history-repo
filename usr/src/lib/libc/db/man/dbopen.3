.\" Copyright (c) 1990 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" %sccs.include.redist.man%
.\"
.\"	@(#)dbopen.3	5.6 (Berkeley) %G%
.\"
.TH DB 3  ""
.UC 7
.SH NAME
btree_open, hash_open, recno_open \- database manipulation routines
.SH SYNOPSIS
.nf
.ft B
#include <db.h>

DB *
btree_open(const char *file, int flags, int mode, const BTREEINFO * private);

DB *
hash_open(const char *file, int flags, int mode, const HASHINFO * private);

DB *
recno_open(const char *file, int flags, int mode, const RECNOINFO * private);
.ft R
.fi
.SH DESCRIPTION
.IR Btree_open ,
.IR hash_open ,
and
.I recno_open
are interfaces, respectively, to database files in btree, hashed, and
flat-file record formats.
Access to all file types is based on key/data pairs.
.PP
Each routine opens
.I file
for reading and/or writing.
The
.I flags
and
.I mode arguments
are as specified to the
.IR open (2)
routine, however only the O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC
and O_WRONLY flags are meaningful.
Databases which are temporary, i.e. not intended to be preserved
on disk, may be created by setting the file parameter to NULL.
The argument
.I private
is a pointer to a private, access-method specific structure described
below.
.PP
The open routines return a pointer to a structure on success and NULL
on error.
This structure contains at least the following fields:
.sp
typedef struct {
.RS
void *private;
.br
int (*close)(), (*delete)(), (*get)(), (*put)(), (*seq)(), (*sync)();
.RE
} DB;
.sp
.PP
The elements of this structure are defined as follows:
.TP
private
A pointer to an internal structure private to the access method.
.TP
close
A pointer to a routine to flush any cached information to disk, free any
allocated resources, and close the database file.
Its function prototype is:
.sp
.in +5
close(const DB *db);
.in -5
.sp
Since key/data pairs may be cached in memory, failing to close the
file with the
.I close
routine may result in inconsistent or lost information.
The
.I close
routine returns 0 on error and 1 on success.
.TP
delete
A pointer to a routine to remove key/data pairs from the database.
Its function prototype is:
.sp
.in +5
delete(const DB *db, const DBT *key);
.in -5
.sp
The
.I delete
routine returns 0 on error, 1 on success, and -1 if the specified
.I key
was not in the file.
.TP
get
A pointer to a routine which is the interface for keyed retrieval from
the database.
Its function prototype is:
.sp
.in +5
get(const DB *db, const DBT *key, DBT *data);
.in -5
.sp
The address and length of the data associated with the specified
.I key
are returned in the structure referenced by
.IR data .
The
.I get
routine returns 0 on error, 1 on success, and -1 if the
.I key
was not in the file.
.TP
put
A pointer to a routine to store key/data pairs in the database.
Its function prototype is:
.sp
.in +5
put(const DB *db, const DBT *key, const DBT *data, u_long flag);
.in -5
.sp
The
.I put
routine returns 0 on error, 1 on success, and -1 if the R_NOOVERWRITE
.I flag
is set and the key already exists in the file.
.sp
The parameter
.I flag
may be set to one of the following values:
.RS
.TP
R_APPEND
Append the data immediately after the data referenced by
.IR key ,
creating a new record.
(This implies that the access method is able to create new keys itself,
i.e. the keys are ordered and independent, for example, record numbers.
Currently applicable only to the RECNO access method.)
.TP
R_INSERT
Insert the data immediately before the data referenced by
.IR key ,
creating a new record.
(This implies that the access method is able to create new keys itself,
i.e. the keys are ordered and independent, for example, record numbers.
Currently applicable only to the RECNO access method.)
.TP
R_NOOVERWRITE
Enter the new key/data pair only if the key does not previously exist.
.RE
.TP
seq
A pointer to a routine which is the interface for sequential
retrieval from the database.
Its function prototype is:
.sp
.in +5
seq(const DB *db, DBT *key, DBT *data, int flag);
.in -5
.sp
The address and length of the key are returned in the structure
referenced by
.IR key ,
and the address and length of the data are returned in the
structure referenced
by
.IR data .
The first time the
.I seq
routine is called, the first record of the database is returned
if
.I flag
is not set or is set to R_FIRST or R_NEXT.
.sp
The
.I seq
routine returns 0 on error, 1 on success, -1 if end-of-file is reached,
and -2 if the input is a character device and no complete records are
available.
.sp
The flag value, if set, should be one of the following values:
.RS
.TP
R_FIRST
The first key of the hash table is returned.
.TP
R_LAST
The last key of the hash table is returned.
.TP
R_NEXT
Retrieve the record immediately after the most recently requested
record.
.TP
R_PREV
Retrieve the record immediately before the most recently requested
record.
.RE
.TP
sync
A pointer to a routine to flush any cached information to disk.
Its function prototype is:
.sp
.in +5
sync(const DB *db);
.in -5
.sp
If the database is in memory only, the
.I sync
routine is a no-op.
The
.I sync
routine returns 0 on error and 1 on success.
.PP
Each of the routines take a pointer to a structure as returned by
the open routine, one or more pointers to key/data structures, and,
optionally, a flag value.
.PP
Keys (and data) are represented by the following data structure:
.sp
typedef struct {
.RS
u_char *data;
.br
size_t size;
.RE
} DBT;
.PP
The elements of this structure are defined as follows:
.TP
data
A pointer to a byte string.
.TP
size
The length of the byte string.
.SH BTREE
One of the access methods is a btree: a sorted, balanced
tree structure with associated key and data pairs.
.PP
The private data structure provided to
.I btree_open
is as follows:
.sp
typedef struct {
.RS
int cachesize;
.RE
} BTREEINFO;
.PP
The elements of this structure are defined as follows:
.RE
.TP
cachesize
A suggested maximum size, in bytes, of the memory cache.
Setting this value to zero specifies that an appropriate amount of memory
should be used.
.SH HASH
One of the access methods is hashed access and storage.
The private data structure provided to
.I hash_open
is as follows:
.sp
typedef struct {
.RS
int bsize;
.br
int cachesize;
.br
int ffactor;
.br
int nelem;
.br
u_long (*hash)(const void *, const size_t);
.RE
} HASHINFO;
.PP
The elements of this structure are defined as follows:
.TP
bsize
.I Bsize
defines the hash table bucket size, and is, by default 1024, bytes.
For tables with large data items, it may be preferable to increase the
page size, and, conversely, applications doing exclusively in-memory hashing
may want to use a very small bucket size, for example, 256, to minimize
hash chain collisions.
.TP
cachesize
A suggested maximum size, in bytes, of the memory cache.
Setting this value to zero specifies that an appropriate amount of memory
should be used.
.TP
ffactor
.I Ffactor
indicates a desired density within the hash table.
It is an approximation of the number of keys allowed to accumulate in any
one bucket, determining when the hash table grows or shrinks.
The default value is 5.
.TP
hash
.I Hash
is a user defined hash function.
Since no hash function performs equally well on all possible data, the
user may find that the built-in hash function does poorly on a particular
data set.
Any user specified hash function should take two arguments, a pointer to
a byte string and a length, and return an unsigned long to be used as
the hash value.
.TP
nelem
.I Nelem
is an estimate of the final size of the hash table.
If not set, the default value is 1.
If not set or set too low, hash tables will expand gracefully as keys
are entered, although a slight performance degradation may be noticed.
.PP
If the pointer to the private data structure is NULL, the open routine
will use appropriate values.
.PP
If the hash table already exists, and the O_TRUNC flag is not
specified to 
.IR hash_open ,
the parameters
.IR bsize ,
.IR ffactor ,
and
.I nelem
are ignored. 
.PP
If a hash function is specified, 
.I hash_open
will attempt to determine if the hash function specified is the same as
the one with which the database was created, and will fail if it is not.
.PP
Both key and data structures may reference byte strings of essentially
unlimited length, however, the strings must fit into available memory.
.PP
Backward compatible interfaces to the routines described in
.IR dbm (3),
.IR hsearch (3),
and
.IR ndbm (3)
are provided as part of the compatibility library, ``libcompat.a''.
.SH RECNO
One of the access methods is either variable or fixed-length records,
the former delimited by a specific byte value.
The private data structure provided to
.I recno_open
is as follows:
.sp
typedef struct {
.RS
u_long flags;
.br
int cachesize;
.br
size_t reclen;
.br
u_char bval;
.RE
} RECNOINFO;
.PP
The elements of this structure are defined as follows:
.TP
flags
The flag value is specified by
.IR or 'ing
the following values:
.RS
.TP
R_FIXEDLEN
The records are fixed-length, not byte delimited.
The structure element
.I reclen
specifies the length of the record, and the structure element
.I bval
is used as the pad character.
.RE
.TP
cachesize
A suggested maximum size, in bytes, of the memory cache.
Setting this value to zero specifies that an appropriate amount of memory
should be used.
.TP
reclen
The length of a fixed-length record.
.TP
bval
The delimiting byte to be used to mark the end of a record for
variable-length records, and the pad character for fixed-length
records.
.PP
Variable-length and fixed-length data files require
.I key
structures to reference a byte followed by three unsigned longs.
The numbers are used as a record number, a byte offset and a record length,
respectively, and the byte is a flag value which indicates the validity
of the other fields.
These access methods do no validity checking as to the correctness of any
of these values, nor are they constrained to use the values provided.
If any of the record number, byte offset or record length are not specified
by the calling routine, and the record retrieval is successful, the correct
values are copied into the caller's
.I key
structure.
The flag value is specified by
.IR or 'ing
the following values:
.TP
R_LENGTH
The record length is valid.
.TP
R_OFFSET
The byte offset is valid.
.TP
R_RECNO
The record number is valid.
.PP
Data structures may reference byte strings of essentially
unlimited length, however, the strings must fit into available memory.
.SH ERRORS
The
.I open
routines may fail and set errno for any of the errors specified for the
library routines
.IR open (2)
and
.IR malloc (3)
or the following:
.TP
[EINVAL]
A parameter has been specified (hash function, pad byte etc.) that is
incompatible with the current file specification or there is a mismatch
between the version number of file and the software.
.TP
[EOPNOTSUPP]
A file used by an open routine is incorrectly formatted, corrupted,
or otherwise unusable.
.PP
The
.I get
routines may fail and set errno for any of the errors specified for the
library routine
.IR malloc (3).
.PP
The
.I close
routines may fail and set errno for any of the errors specified for the
library routines
.IR close (2),
.IR free (3),
or
.IR fsync (2).
.PP
The
.I sync
routines may fail and set errno for any of the errors specified for the
library routine
.IR fsync (2).
.SH BUGS
The typedef DBT is a mnemonic for ``data base thang'', and was used
because all of the reasonable names were taken.
