.\" Copyright (c) 1990 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek.
.\"
.\" %sccs.include.redist.man%
.\"
.\"	@(#)scanf.3	6.4 (Berkeley) %G%
.\"
.TH SCANF 3 ""
.UC 7
.SH NAME
scanf, fscanf, sscanf, vfscanf \- formatted input conversion
.SH SYNOPSIS
.B #include <stdio.h>
.PP
.B scanf(format
[ , pointer ... ]
.B )
.br
.B char *format;
.PP
.B fscanf(stream, format
[ , pointer ... ]
.B )
.br
.SM
.B FILE
.B *stream;
.br
.B char *format;
.PP
.B sscanf(str, format
[ , pointer ... ]
.B )
.br
.B char *str;
.br
.B char *format;
.PP
.B #include <varargs.h>
.PP
.B vfscanf(stream, format, ap)
.br
.SM
.B FILE
.B *stream;
.br
.B char *format;
.br
.B va_list ap;
.br
.SH DESCRIPTION
The
.I scanf
family of functions scans input according to a
.I format
as described below.
This format may contain
.IR "conversion specifiers" ;
the results from such conversions, if any,
are stored through the
.I pointer
arguments.
.I Scanf
reads the standard input stream
.BR stdin ,
.I fscanf
reads the named input
.IR stream ,
and
.I sscanf
reads from the character string
.IR str .
.I Vfscanf
is analogous to
.I vfprintf
and reads from a named input
.I stream
using a variable argument list of pointers (see
.IR varargs (3)).
Each successive
.I pointer
argument must correspond properly with
each successive conversion specifier
(but see `suppression' below).
All conversions are introduced by the
.B %
(percent sign) character.
The
.I format
string
may also contain other characters.
White space (such as blanks, tabs, or newlines) in the
.I format
string match any amount of white space, including none, in the input.
Everything else
matches only itself.
Scanning stops
when an input character does not match such a format character.
Scanning also stops
when an input conversion cannot be made (see below).

.SH CONVERSIONS
Following the
.B %
character introducing a conversion
there may be a number of
.I flag
characters, as follows:
.TP 4
.B *
suppresses assignment.
The conversion that follows occurs as usual, but no pointer is used;
the result of the conversion is simply discarded.
.TP 4
.B h
indicates that the conversion will be one of
.B dioux
or
.B n
and the next pointer is a pointer to a
.B short int
(rather than
.BR int ).
.TP 4
.B l
indicates either that the conversion will be one of
.B dioux
or
.B n
and the next pointer is a pointer to a
.B long int
(rather than
.BR int ),
or that the conversion will be one of
.B efg
and the next pointer is a pointer to
.B double
(rather than
.BR float ).
.TP 4
.B L
indicates that the conversion will be
.B efg
and the next pointer is a pointer to
.BR "long double" .
(This type is not implemented; the
.B L
flag is currently ignored.)
.PP
In addition to these flags,
there may be an optional maximum field width,
expressed as a decimal integer,
between the
.B %
and the conversion.
If no width is given,
a default of `infinity' is used (with one exception, below);
otherwise at most this many characters are scanned
in processing the conversion.
Before conversion begins,
most conversions skip white space;
this white space is not counted against the field width.
.PP
The following conversions are available:
.TP 4
.B %
matches a literal `%'.
That is, `%%' in the format string
matches a single input `%' character.
No conversion is done, and no assignment occurs.
.TP 4
.B d
a decimal integer is expected;
the next pointer must be a pointer to
.BR int .
.TP 4
.B D
equivalent to
.BR ld ;
this exists only for backwards compatibility.
.TP 4
.B i
an integer is expected;
the next pointer must be a pointer to
.BR int .
The integer is read in base 16 if it begins with `0x' or `0X',
in base 8 if it begins with `0', and in base 10 otherwise.
Only characters that correspond to the base are used.
.TP 4
.B o
an octal integer is expected;
the next pointer must be a pointer to
.BR "unsigned int" .
.TP 4
.B O
equivalent to
.BR lo ;
this exists for backwards compatibility.
.TP 4
.B u
a signed or unsigned decimal integer is expected;
the next pointer must be a pointer to
.BR "unsigned int" .
.TP 4
.B x
a signed or unsigned hexadecimal integer is expected;
the next pointer must be a pointer to
.BR "unsigned int" .
.TP 4
.B X
equivalent to
.BR lx ;
this violates the ANSI C standard X3.159-1989,
but is backwards compatible with previous
.UX
systems.
.TP 4
.B f
a floating-point number is expected;
the next pointer must be a pointer to
.BR float .
.TP 4
.B e
equivalent to
.BR f .
.TP 4
.B g
equivalent to
.BR f .
.TP 4
.B E
equivalent to
.BR lf ;
this violates the ANSI C standard X3.159-1989,
but is backwards compatible with previous
.UX
systems.
.TP 4
.B F
equivalent to
.BR lf ;
this exists only for backwards compatibility.
.TP 4
.B s
a string is expected;
the next pointer must be a pointer to
.BR char ,
and there must be enough room for all the characters in the string,
plus a terminating `\e0'.
The input string stops at white space
or at the maximum field width, whichever occurs first.
.TP 4
.B c
.I width
characters (default 1) are expected;
the next pointer must be a pointer to
.BR char ,
and there must be enough room for all the characters
(no terminating `\e0' is added).
The usual skip of leading white space is suppressed.
To skip white space first, use an explicit space in the format.
.TP 4
.B [
a string is expected;
the next pointer must be a pointer to
.BR char ,
and there must be enough room for all the characters in the string,
plus a terminating `\e0'.
The usual skip of leading white space is suppressed.
The string is to be made up of characters in
(or not in)
a particular set;
the set is defined by the characters between the open bracket
.B [
character
and a close bracket
.B ]
character.
The set
.I excludes
those characters
if the first character after the open bracket is a circumflex
.BR ^ .
To include a close bracket in the set,
make it the first character after the open bracket
or the circumflex;
any other position will end the set.
The hyphen character
.B \-
is also special;
when placed between two other characters,
it adds all intervening characters to the set.
To include a hyphen,
make it the last character before the final close bracket.
For instance, `[^]0-9-]'
means the set `everything except close bracket, zero through nine,
and hyphen'.
The string ends at the first character not in
(or, with a circumflex, in)
the set, or when the field width runs out.
.TP 4
.B p
a pointer value (as printed by `%p' in
.IR printf (3))
is expected;
the next pointer must be a pointer to
.BR void .
.TP 4
.B n
nothing is expected;
instead, the number of characters consumed thus far from the input
is stored through the next pointer,
which must be a pointer to
.BR int .
This is
.I not
a conversion, although it can be suppressed with the
.B *
flag.
.PP
For backwards compatibility,
other conversion characters (except '\e0')
are taken as if they were `%d' or, if uppercase, `%ld',
and a `conversion' of `%\e0' causes an immediate return of
.SM
.BR EOF .
The
.B F
and
.B X
conversions will be changed in the future
to conform to the ANSI C standard,
after which they will act like
.B f
and
.B x
respectively.
.PP
The
.I scanf
functions return the number of successfully assigned conversions, or
.SM
.B EOF
if nothing was assigned
before the end of input (or an error during input) was encountered.
A return value of 0
indicates that, while there was input available,
no conversions were assigned;
typically this is due to an invalid input character,
such as an alphabetic character for a `%d' conversion.
.SH "SEE ALSO"
strtol(3),
strtoul(3),
getc(3),
printf(3)
.SH "RETURN VALUE"
The 
.I scanf
functions return
.SM
.B EOF
on end of input,
or a short count for missing or illegal data items.
.SH BUGS
The current situation with
.B %F
and
.B %X
conversions is unfortunate.
.br
All of the backwards compatibility formats will be removed in the future.
.br
There is no
.I vscanf
or
.IR vsscanf .
.\" Had to draw the line somewhere!
