.\" Copyright (c) 1980 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
.\"
.\"	@(#)ch4.n	4.1 (Berkeley) %G%
.\"
." @(#)ch4.n	34.1 1/29/81
.Lc	Special\ Functions 4
.Lf and "[g_arg1 ...]"
.Re
the value of the last argument if all arguments evaluate
to a non nil value, otherwise 
.i and 
returns nil.
It returns t if there are no arguments.
.No
the arguments are evaluated left to right and evaluation will cease
with the first nil encountered
.Lf apply "'u_func 'l_args"
.Re
the result of applying function u_func to the arguments in the list l_args.
.No
If u_func is a lambda, then the \fI(length\ l_args)\fP should equal the
number of formal parameters for the u_func.
If u_func is a nlambda or macro, then l_args is bound to the single
formal parameter.
.Eb
; \fIadd1\fP is a lambda of 1 argument
-> \fI(apply 'add1 '(3))\fP
4

; we will define \fIplus1\fP as a macro which will be equivalent to \fIadd1\fP
-> \fI(def plus1 (macro (arg) (list 'add1 (cadr arg))))\fP
plus1
-> \fI(plus1 3)\fP
4

; now if we \fIapply\fP a macro we obtain the form it changes to.
-> \fI(apply 'plus1 '(plus1 3))\fP
(add1 3)

; if we \fIfuncall\fP a macro however, the result of the macro is \fIeval\fPed
; before it is returned.
-> \fI(funcall 'plus1 '(plus1 3))\fP
4
.Ee
.Lf arg "['x_numb]"
.Re 
if x_numb is specified then the x_numb'\fIth\fP argument to 
the enclosing lexpr
If x_numb is not specified then this returns the number of arguments 
to the enclosing lexpr.
.No
it is an error to the interpreter if x_numb is given and out of range.
.Lf break "[g_message ['g_pred]]"
.Wh
if g_message is not given it is assumed to be the null string, and
if g_pred is not given it is assumed to be t.
.Re
the value of (*break 'g_pred 'g_message)
.Lf *break "'g_pred 'g_message"
.Re
nil immediately if g_pred is nil, else
the value of the next (return 'value) expression typed in at top level.
.Se
If the predicate, g_pred, evaluates to non nil,
the lisp system stops and prints out `Break '
followed by g_message. 
It then enters a break loop
which allows one to interactively debug a program.
To continue execution from a break you can use the
.i return 
function. 
to return to top level or another break level, you can use
.i retbrk 
or 
.i reset .
.Lf catch "g_exp [ls_tag]"
.Wh
if ls_tag is not given, it is assumed to be nil.
.Re
the result of (*catch 'ls_tag g_exp)
.No
catch is defined as a macro.
.Lf *catch "'ls_tag g_exp"
.Wh
ls_tag is either a symbol or a list of symbols.
.Re
the result of evaluating g_exp or the value thrown during the evaluation
of g_exp.
.Se
this first sets up a `catch frame' on the lisp runtime stack.
Then it begins to evaluate g_exp.
If g_exp evaluates normally, its value is returned.
If, however a 
.i throw
is done during the evaluation of g_exp we will catch the value thrown iff
one of these cases is true:
.nr $p 0
.np
the tag thrown to is ls_tag 
.np
ls_tag is a list and the tag thrown to is a member of this list
.np
ls_tag is nil.
.No
Errors are implemented as a special kind of throw.
A catch with no tag will not catch an error but a catch whose tag is
the error type will catch that type of error.
See \(sc10 for more information.
.Lf comment "[g_arg ...]"
.Re
the symbol comment.
.No
This does absolutely nothing.
.Lf cond "[l_clause1 ...]"
.Re
the last value evaluated in the first clause satisfied.
If no clauses are satisfied then nil is returned.
.No
This is the basic conditional `statement' in lisp.
The clauses are processed from left to right.
The first element of a clause is evaluated.
If it evaluated to a non nil value then that clause is satisfied and
all following elements of that clause are evaluated.
The last value computed is returned as the value of the cond.
If there is just one element in the clause then its value is returned.
If the first element of a clause evaluates to nil, then the other
elements of that clause are not evaluated and the system moves to
the next clause.
.Lf declare "[g_arg ...]"
.Re
nil
.No
this is a no-op to the evaluator.
It has special meaning to the compiler.
.Lf def "s_name (s_type l_argl g_exp1 ...)"
.Wh
s_type is one of lambda, nlambda, macro or lexpr.
.Re
s_name
.Se
This defines the function s_name to the lisp system.
If s_type is nlambda or macro then the argument list l_argl must contain
exactly one non-nil symbol.
.Lf defun "s_name [s_mtype] ls_argl g_exp1 ... "
.Wh
s_mtype is one of fexpr, expr, args or macro.
.Re
s_name
.Se
This defines the function s_name.
.No
this exists for \s-2MAC\s0lisp compatibility, it is just a macro which
changes the defun form to the def form.
An s_mtype of fexpr is converted to nlambda
and of expr to lambda. Macro remains the same.
If ls_arg1 is a non-nil symbol, then the type is assumed to be lexpr and
ls_arg1 is the symbol which is bound to the number of args when the
function is entered.
.Eb
; \fIdef\fP and \fIdefun\fP here are used to define identical functions
; you can decide for yourself which is easier to use.
-> \fI(def append1 (lambda (lis extra) (append lis (list extra))))\fP
append1

-> \fI(defun append1 (lis extra) (append lis (list extra)))\fP
append1
.Ee
.Lf do "l_vrbs l_test g_exp1 ..."
.Re
the last form in the cdr of l_test evaluated, or a value explicitly given by
a return evaluated within the do body.
.No
This is the basic iteration form for
.Fr .
l_vrbs is a list of zero or more var-init-repeat forms.
A var-init-repeat form looks like:
.br
.tl ''(s_name [g_init [g_repeat]])''
There are three cases depending on what is present in the form.
If just s_name is present, this means that when the do is entered,
s_name is lambda-bound to nil and is never modified by the system 
(though the program is certainly free to modify its value).
If the form is (s_name\ 'g_init) then the only difference is that
s_name is lambda-bound to the value of g_init instead of nil.
If g_repeat is also present then s_name is lambda-bound to g_init
when the loop is entered and after each pass through the do body
s_name is  bound to the value of g_repeat.
.br
l_test is either nil or has the form of a cond clause.
If it is nil then the do body will be evaluated only once and the
do will return nil.
Otherwise, before the do body is evaluated the car of l_test is 
evaluated and if the result is non nil this signals an end to
the looping.
Then the rest of the forms in l_test are evaluated
and the value of the last one is returned as the value of the do.
If the cdr of l_test is nil, then nil is returned -- thus this is not
exactly like a cond clause.
.br
g_exp1 and those forms which follow constitute the do body.
A do body is like a prog body and thus may have labels and one may
use the functions go and return.
.br
The sequence of evaluations is this:
.nr $p 0
.np
the init forms are evaluated left to right and  stored in temporary
locations.
.np
Simultaneously all do variables are lambda bound to the value of
their init forms or nil.
.np
If l_test is non nil then the car is evaluated and if it is non nil
the rest of the forms in l_test are evaluated and the last value is 
returned as the value
of the do.
.np
The forms in the do body are evaluated left to right.
.np
If l_test is nil the do function returns with the value nil.
.np
The repeat forms are evaluated and saved in temporary locations.
.np
The variables with repeat forms are simultaneously
bound to the values of those forms.
.np
Go to step 3.
.No
there is an alternate form of do which can be used when there is
only one do variable.
It is described next.
.\".pg
.Lf do "s_name g_init g_repeat g_test g_exp1 ..."
.nr $p 0
.No
this is another, less general,  form of do.
It is evaluated by:
.np
evaluating g_init
.np
lambda binding s_name to value of g_init
.np
g_test is evaluated and if it is not nil the do function returns with nil.
.np
the do body is evaluated beginning at g_exp1.
.np
the repeat form is evaluated and stored in s_name.
.np
go to step 3.
.Lf err "['s_value [nil]]"
.Re
nothing (it never returns).
.Se
This causes an error and if this error is caught by an 
.i errset
then that 
.i errset
will return s_value instead of nil.
If the second arg is given, then it must be nil (\s-2MAC\s0lisp 
compatibility).
.Lf error "['s_message1 ['s_message2]]"
.Re
nothing (it never returns).
.Se
s_message1 and s_message2 are \fIpatom\fPed if they are given and
then \fIerr\fP is called which causes an error.
.Lf errset "g_expr [s_flag]"
.Re
a list of one element, which is the value resulting from evaluating g_expr.
If an error occurs during the evaluation of g_expr, then the locus of control
will return to the 
.i errset
which will then return nil (unless the error was caused by a call to
.i err).
.Se
S_flag is evaluated before g_expr is evaluated. 
If s_flag is not given, then it is assumed to be t.
If an error occurs during the evaluation of g_expr, and s_flag evaluated to 
a non nil value, then the error message associated with the
error is printed before control returns to the errset.
.Lf eval "'g_val"
.Re
the result of evaluating g_val.
.No
The evaluator evaluates g_val in this way:
.br
If g_val is a symbol, then the evaluator returns its value.
If g_val had never been assigned a value, then this causes 
an 'Unbound Variable' error.
If g_val is of type value, then its value is returned.
If g_val is a list object then g_val is either a function call or
array reference.
Let g_car be the first element of g_val.
We continually evaluate g_car until we end up with a symbol with
a non nil function binding
or a non-symbol.
Call what we end up with: g_func.
g_func must be one of three types: list, binary or array.
If it is a list then the first element of the list, which 
we shall call g_functype, must be either
lambda, nlambda, macro or lexpr.
If g_func is a binary, then its discipline, which we shall call
g_functype, is either lambda, nlambda, macro or a string "subroutine",
"function", "integer-function" or "real-function".
If g_func is an array then this form is evaluated specially, see
\(sc9 on arrays.
If g_func is a list or binary, then g_functype will determine how
the arguments to this function, the cdr of g_val, are processed.
If g_functype is a string, then this is a foreign function call (see \(sc8.4
for more details).
If g_functype is lambda or lexpr, the arguments are  evaluated
(by calling 
.i eval
recursively) and stacked.
If g_functype is nlambda then the argument list is stacked.
If g_functype is macro then the entire form, g_val is stacked.
Next the formal variables are lambda bound.
The formal variables are the cadr of g_func - if g_functype is
nlambda, lexpr or macro, there should only be one formal variable.
The values on the stack are lambda bound to the formal variables
except in the case of a lexpr, where the number of actual arguments
is bound to the formal variable.
After the binding is done, the function is invoked, either by
jumping to the entry point in the case of a binary or 
by evaluating the list of forms beginning at cddr g_func.
The result of this function invocation is returned as the value 
of the call to eval.
.Lf eval-when "l_times g_exp1 ... g_expn"
.Wh
l_times is a list containing any combination of compile, eval and load.
.Re
nil
if the symbol eval is not  member of l_times, 
else returns the value of g_expn.
.Se
If eval is a member of l_times, then the forms g_exp\fIi\fP are
evaluated.
.No
this is used mainly to control when the compiler evaluates forms.
.Lf exec "s_arg1 ..."
.Re
the result of forking and executing the command named by concatenating
the s_arg\fIi\fP together with spaces in between.
.Lf exece "'s_fname ['l_args ['l_envir]]"
.Re
the error code from the system if it was unable to 
execute the command s_fname with arguments
l_args and with the environment set up as specified in l_envir.
If this function is successful, it will not return, instead the lisp
system will be overlaid by the new command.
.Lf funcall "'u_func ['g_arg1 ...]"
.Re
the value of applying function u_func to the arguments g_arg\fIi\fP
and then evaluating that result if u_func is a macro.
.No
If u_func is a macro or nlambda then there should be only one g_arg.
\fIfuncall\fP is the function which the evaluator uses to evaluate
lists.
If \fIfoo\fP is a lambda or lexpr or array, 
then \fI(funcall\ 'foo\ 'a\ 'b\ 'c)\fP
is equivalent to \fI(foo\ 'a\ 'b\ 'c)\fP.
If \fIfoo\fP is a nlambda
then \fI(funcall\ 'foo\ '(a\ b\ c))\fP is equivalent to
\fI(foo a b c)\fP.
Finally, if 
.i foo
is a macro then
.i (funcall\ 'foo\ '(foo\ a\ b\ c))
is equivalent to
.i (foo\ a\ b\ c) .
.Lf function "u_func"
.Re
the function binding of u_func if it is an symbol with a function binding
otherwise u_func is returned.
.Lf getdisc "'t_func"
.Re
the discipline of the machine coded function (either lambda, nlambda
or macro).
.Lf go "g_labexp"
.Wh
g_labexp is either a symbol or an expression.
.Se
If g_labexp is an expression, that expression is evaluated and 
should
result in a symbol.
The locus of control moves to just following the symbol g_labexp in the
current prog or do body.
.No
this is only valid in the context of a prog or do body.
The interpreter and compiler will allow non-local 
.i go 's 
although the compiler won't allow a \fIgo\fP to leave a function body.
The compiler will not allow g_labexp to be an expression.
.Lf map "'u_func 'l_arg1 ..."
.Re
l_arg1
.No
The function u_func is applied to successive sublists of the l_arg\fIi\fP.
All sublists should have the same length.  
.\".pg
.Lf mapc "'u_func 'l_arg1 ..."
.Re
l_arg1.
.No
The function u_func is applied to successive elements of the argument 
lists.
All of the lists should have the same length.
.Lf mapcan "'u_func 'l_arg1 ..."
.Re
nconc applied to the results of the functional evaluations.
.No
The function u_func is applied to successive elements of the 
argument lists.
All sublists should have the same length.
.Lf mapcar "'u_func 'l_arg1 ..."
.Re
a list of the values returned from the functional application.
.No
the function u_func is applied to successive elements of the
argument lists.
All sublists should have the same length.
.Lf mapcon "'u_func 'l_arg1 ..."
.Re
nconc applied to the results of the functional evaluation.
.No
the function u_func is applied to successive sublists of the
argument lists.
All sublists should have the same length.
.Lf maplist "'u_func 'l_arg1 ..."
.Re
a list of the results of the functional evaluations.
.No
the function u_func is applied to successive sublists of the arguments
lists.
All sublists should have the same length.
.Lf mfunction "entry 's_disc"
.Re
a lisp object of type binary composed of entry and s_disc.
.No
entry is a pointer to the machine code for a function, and s_disc is the
discipline (e.g. lambda).
.\".pg
.Lf oblist
.Re
a list of all symbols on the oblist.
.Lf or "[g_arg1 ... ]"
.Re
the value of the first non nil argument  or nil if all arguments 
evaluate to nil.
.No
Evaluation proceeds left to right and stops as soon as one of the arguments
evaluates to a non nil value.
.Lf prog "l_vrbls g_exp1 ..."
.Re
the value explicitly given in a return form
or else nil if no return is done by the time the last g_exp\fIi\fP is
evaluated.
.No
the local variables are lambda bound to nil then the g_exp\fI\fP
are evaluated from left to right.
This is a prog body (obviously) and this means than 
any symbols seen are not evaluated,
instead they are treated as labels.
This also means that returns and go's are allowed.
.Lf prog2 "g_exp1 g_exp2 [g_exp3 ...]"
.Re
the value of g_exp2.
.No
the forms are evaluated from left to right and the value of g_exp2 is
returned.
.Lf progn "g_exp1 [g_exp2 ...]"
.Re
the value of the last g_exp\fIi\fP.
.No
the forms are evaluated from left to right and the value of the last one
is returned.
.Lf progv "'l_locv 'l_initv g_exp1 ..."
.Wh
l_locv is a list of symbols and l_initv is a list of expressions.
.Re
the value of the last g_exp\fIi\fP evaluated.
.No
The expressions in l_initv are evaluated from left to right
and then lambda-bound to the symbols in _locv.
If there are too few expressions in l_initv then the missing values
are assumed to be nil.
If there are too many expressions in l_initv then the extra ones are
ignored (although they are evaluated).
Then the g_exp\fIi\fP are evaluated left to right.
The body of a progv is like the body of a progn, it is 
.i not
a prog body.
.Lf putd "'s_name 'u_func"
.Re
this sets the function binding of symbol s_name to u_func.
.Lf return "['g_val]"
.Re
g_val (or nil if g_val is not present) from the enclosing prog or do body.
.No
this form is only valid in the context of a prog or do body.
.Lf setarg "'x_argnum 'g_val"
.Wh
x_argnum is greater than zero and less than or equal to the number of
arguments to the lexpr.
.Re
g_val
.Se
the lexpr's x_argnum'th argument is set to g-val.
.No
this can only be used within the body of a lexpr.
.Lf throw "'g_val [s_tag]"
.Wh
if s_tag is not given, it is assumed to be nil.
.Re
the value of \fI(*throw 's_tag 'g_val)\fP.
.Lf *throw "'s_tag 'g_val"
.Re
g_val from the first enclosing catch with 
the tag s_tag or with no tag at all.
.No
this is used in conjunction with 
.i *catch
to cause a clean jump to an enclosing context.
