RANDOM(3)                   BSD Programmer's Manual                  RANDOM(3)

NNAAMMEE
     rraannddoomm, ssrraannddoomm, iinniittssttaattee, sseettssttaattee - better random number generator;
     routines for changing generators

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssttddlliibb..hh>>

     _l_o_n_g
     rraannddoomm(_v_o_i_d);

     _v_o_i_d
     ssrraannddoomm(_u_n_s_i_g_n_e_d _s_e_e_d);

     _c_h_a_r _*
     iinniittssttaattee(_u_n_s_i_g_n_e_d _s_e_e_d, _c_h_a_r _*_s_t_a_t_e, _i_n_t _n);

     _c_h_a_r _*
     sseettssttaattee(_c_h_a_r _*_s_t_a_t_e);

DDEESSCCRRIIPPTTIIOONN
     The rraannddoomm() function uses a non-linear additive feedback random number
     generator employing a default table of size 31 long integers to return
     successive pseudo-random numbers in the range from 0 to (2**31)-1.  The
     period of this random number generator is very large, approximately
     16*((2**31)-1).

     The rraannddoomm()/ ssrraannddoomm() have (almost) the same calling sequence and ini-
     tialization properties as rand(3)/ srand(3).   The difference is that
     rand produces a much less random sequence -- in fact, the low dozen bits
     generated by rand go through a cyclic pattern.  All the bits generated by
     rraannddoomm() are usable.  For example, `random()&01' will produce a random
     binary value.

     Unlike srand,  ssrraannddoomm() does not return the old seed; the reason for
     this is that the amount of state information used is much more than a
     single word.  (Two other routines are provided to deal with restart-
     ing/changing random number generators).  Like rand(3),  however, rraannddoomm()
     will by default produce a sequence of numbers that can be duplicated by
     calling ssrraannddoomm() with `1' as the seed.

     The iinniittssttaattee() routine allows a state array, passed in as an argument,
     to be initialized for future use.  The size of the state array (in bytes)
     is used by iinniittssttaattee() to decide how sophisticated a random number gener-
     ator it should use -- the more state, the better the random numbers will
     be.  (Current "optimal" values for the amount of state information are 8,
     32, 64, 128, and 256 bytes; other amounts will be rounded down to the
     nearest known amount.  Using less than 8 bytes will cause an error.)  The
     seed for the initialization (which specifies a starting point for the
     random number sequence, and provides for restarting at the same point) is
     also an argument.  The iinniittssttaattee() function returns a pointer to the pre-
     vious state information array.

     Once a state has been initialized, the sseettssttaattee() routine provides for
     rapid switching between states.  The sseettssttaattee() function returns a point-
     er to the previous state array; its argument state array is used for fur-
     ther random number generation until the next call to iinniittssttaattee() or
     sseettssttaattee().

     Once a state array has been initialized, it may be restarted at a differ-
     ent point either by calling iinniittssttaattee() (with the desired seed, the state
     array, and its size) or by calling both sseettssttaattee() (with the state array)
     and ssrraannddoomm() (with the desired seed).  The advantage of calling both
     sseettssttaattee() and ssrraannddoomm() is that the size of the state array does not
     have to be remembered after it is initialized.

     With 256 bytes of state information, the period of the random number gen-
     erator is greater than 2**69 which should be sufficient for most purpos-
     es.

AAUUTTHHOORR
     Earl T. Cohen

DDIIAAGGNNOOSSTTIICCSS
     If iinniittssttaattee() is called with less than 8 bytes of state information, or
     if sseettssttaattee() detects that the state information has been garbled, error
     messages are printed on the standard error output.

SSEEEE AALLSSOO
     rand(3)

HHIISSTTOORRYY
     These functions appeared in 4.2BSD.

BBUUGGSS
     About 2/3 the speed of rand(3).

4.2 Berkeley Distribution        June 4, 1993                                2
