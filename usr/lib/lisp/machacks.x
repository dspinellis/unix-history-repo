(File machacks.l)
(^ lambda expt)
(defsubst macro cond if car cdr nreverse null do append cons quote list cdddr caddr cadr)
(check-arg-type macro null cond if quote list cadddr caddr cadr)
(check-arg macro atom cond if quote list cadddr caddr cadr)
(defconst macro quote list if car cddr setq cond caddr cadddr cadr)
(local-declare macro nreverse cdr list car setq null liszt-internal-do mapcar append quote cons cddr cadr)
(let-globally macro list or append quote nreverse cdr gensym car cons setq null liszt-internal-do mapcar let cddr cadr)
(defunp macro car caar eq cond cdr nreconc reverse let append cons quote list cdddr caddr cadr)
(tailp lambda cdr return eq cond null do)
(pairp macro quote list cadr)
(every lambda cdr if every Internal-bcdcall getdisc quote eq bcdp setq cxr getd symbolp cond car funcall and null or)
(some lambda cdr some Internal-bcdcall getdisc quote eq bcdp setq cxr getd symbolp car funcall cond if null not and)
(del-if-not lambda cddr rplacd Internal-bcdcall getdisc quote eq bcdp setq cxr getd symbolp and cadr second funcall not cond if cdr null do cons let)
(del-if lambda cddr rplacd Internal-bcdcall getdisc quote eq bcdp setq cxr getd symbolp and cadr second funcall cond if cdr null do cons let)
(del lambda cddr rplacd |1-| bigp zerop not Internal-bcdcall getdisc quote eq bcdp cxr getd symbolp cadr second funcall and cond cdr null do cons let setq)
(rem-if-not lambda cdr rplacd list Internal-bcdcall getdisc eq bcdp setq cxr getd symbolp and car funcall cond null do quote let)
(rem-if lambda cdr rplacd list Internal-bcdcall getdisc eq bcdp setq cxr getd symbolp and car funcall not cond null do quote let)
(rem lambda |1-| rplacd list bigp not cdr zerop Internal-bcdcall getdisc eq bcdp cxr getd symbolp and car funcall or cond null do quote let setq)
(mem lambda cdr return Internal-bcdcall getdisc quote eq bcdp setq cxr getd symbolp and car funcall cond if null do)
(find-postion-in-list-equal lambda |1+| cdr setq return car equal cond if null do)
(find-position-in-list lambda |1+| cdr setq return car eq cond if null do)
(butlast lambda butlast car cons cdr null cond)
(circular-list lambda last rplacd append copylist setq)
(copytree macro quote list cadr)
(copylist macro quote cons cadr)
(rest4 macro quote list cadr)
(rest3 macro quote list cadr)
(rest2 macro quote list cadr)
(rest1 macro quote list cadr)
(seventh macro quote list cadr)
(sixth macro quote list cadr)
(fifth macro quote list cadr)
(fourth macro quote list cadr)
(third macro quote list cadr)
(second macro quote list cadr)
(first macro quote list cadr)
(gcd lambda remainder bigp not cdr null and zerop do minus setq plusp or)
(macro macro append cons quote list cdddr caddr cadr)
(symbolconc macro append quote cons cdr)
(dolist macro list quote cons cddr cadadr caadr)
(dotimes macro list quote cons symbolp fixp or cond if cddr cadadr caadr)
(psetq macro cons quote list cond cdddr caddr cadr)
(>= macro nreverse cond car quote list setf push cdr null do cons list* setq cdddr caddr cadr)
(<= macro nreverse cond car quote list setf push cdr null do cons list* setq cdddr caddr cadr)
(bit-clear macro quote list caddr cadr)
(bit-set macro quote list caddr cadr)
(bit-test macro cons quote list cdr)
(lognot macro quote cons cadr)
(logxor macro quote cons cdr)
(logior macro quote cons cdr)
(logand macro quote cons cdr)
(if-for-maclisp-else-lispm macro car cdr)
(unless macro cons quote list cddr cadr)
(when macro cons quote list cddr cadr)
(for macro append list quote cons cddddr cadddr caddr cadr)
(ttf macro quote cons cdr)
(construct-list* lambda cdr null car cadr quote list cddr do reverse setq)
(list* macro construct-list* car null cond cdr)
(fboundp macro quote list copy dtpr or cond cadr)
(displace lambda car list rplacd rplaca quote error atom cond)
(coutput lambda terpr print)
