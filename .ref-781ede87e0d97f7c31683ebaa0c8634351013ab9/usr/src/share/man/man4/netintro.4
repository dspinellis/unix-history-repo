.\" Copyright (c) 1983, 1990 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" %sccs.include.redist.man%
.\"
.\"	@(#)netintro.4	6.9 (Berkeley) %G%
.\"
.TH NETINTRO 4 ""
.UC 5
.SH NAME
networking \- introduction to networking facilities
.SH SYNOPSIS
.nf
.ft B
#include <sys/socket.h>
#include <net/route.h>
#include <net/if.h>
.fi R
.fi
.SH DESCRIPTION
.de _d
.if t .ta .6i 2.1i 2.6i
.\" 2.94 went to 2.6, 3.64 to 3.30
.if n .ta .84i 2.6i 3.30i
..
.de _f
.if t .ta .5i 1.25i 2.5i
.\" 3.5i went to 3.8i
.if n .ta .7i 1.75i 3.8i
..
This section is a general introduction to the networking facilities
available in the system.
Documentation in this part of section
4 is broken up into three areas:
.I "protocol families
(domains),
.IR protocols ,
and
.IR "network interfaces" .
.\" Entries describing a protocol family are marked ``4F,''
.\" while entries describing protocol use are marked ``4P.''
.\" Hardware support for network interfaces are found
.\" among the standard ``4'' entries.
.PP
All network protocols are associated with a specific
.IR "protocol family" .
A protocol family provides basic services to the protocol
implementation to allow it to function within a specific
network environment.  These services may include 
packet fragmentation and reassembly, routing, addressing, and 
basic transport.  A protocol family may support multiple
methods of addressing, though the current protocol implementations
do not.  A protocol family is normally comprised of a number
of protocols, one per
.IR socket (2)
type.  It is not required that a protocol family support
all socket types.  A protocol family may contain multiple
protocols supporting the same socket abstraction. 
.PP
A protocol supports one of the socket abstractions detailed
in
.IR socket (2).
A specific protocol may be accessed either by creating a
socket of the appropriate type and protocol family, or
by requesting the protocol explicitly when creating a socket.
Protocols normally accept only one type of address format,
usually determined by the addressing structure inherent in
the design of the protocol family/network architecture.
Certain semantics of the basic socket abstractions are
protocol specific.  All protocols are expected to support
the basic model for their particular socket type, but may,
in addition, provide non-standard facilities or extensions
to a mechanism.  For example, a protocol supporting the
SOCK_STREAM
abstraction may allow more than one byte of out-of-band
data to be transmitted per out-of-band message.
.PP
A network interface is similar to a device interface.
Network interfaces comprise the lowest layer of the
networking subsystem, interacting with the actual transport
hardware.  An interface may support one or more protocol
families and/or address formats.
The SYNOPSIS section of each network interface
entry gives a sample specification
of the related drivers for use in providing
a system description to the
.IR config (8)
program.
The DIAGNOSTICS section lists messages which may appear on the console
and/or in the system error log,
.I /var/log/messages
(see
.IR syslogd (8)),
due to errors in device operation.
.SH PROTOCOLS
The system currently supports the DARPA Internet
protocols, the Xerox Network Systems(tm) protocols,
and some of the ISO OSI protocols.
Raw socket interfaces are provided to the IP protocol
layer of the DARPA Internet, to the IMP link layer (1822), and to
the IDP protocol of Xerox NS.
Consult the appropriate manual pages in this section for more
information regarding the support for each protocol family.
.SH ADDRESSING
Associated with each protocol family is an address
format.  All network address adhere to a general structure,
called a sockaddr, described below. However, each protocol
imposes finer and more specific structure, generally renaming
the variant, which is discussed in the protocol family manual
page alluded to above.
.nf
._f
struct sockaddr {
	u_char	sa_len;
	u_char	sa_family;
	char	sa_data[14];
};
.sp 1
.fi
The field sa_len contains the total length of the of the structure,
which may exceed 16 bytes.
The following address values for
.I sa_family
are known to the system
(and additional formats are defined for possible future implementation):
.sp 1
.nf
._d
#define	AF_UNIX	1	/* local to host (pipes, portals) */
#define	AF_INET	2	/* internetwork: UDP, TCP, etc. */
#define	AF_IMPLINK	3	/* arpanet imp addresses */
#define	AF_NS	6	/* Xerox NS protocols */
#define	AF_CCITT	10	/* CCITT protocols, X.25 etc */
#define	AF_HYLINK	15	/* NSC Hyperchannel */
#define	AF_ISO	18	/* ISO protocols */
.fi
.SH ROUTING
.PP
.UX
provides some packet routing facilities.
The kernel maintains a routing information database, which
is used in selecting the appropriate network interface when
transmitting packets.
.PP
A user process (or possibly multiple co-operating processes)
maintains this database by sending messages over a special kind
of socket.
This supplants fixed size
.IR ioctl 's
used in earlier releases.
.PP
This facility is described in
.IR route (4).
.SH INTERFACES
Each network interface in a system corresponds to a
path through which messages may be sent and received.  A network
interface usually has a hardware device associated with it, though
certain interfaces such as the loopback interface,
.IR lo (4),
do not.
.PP
The following 
.I ioctl
calls may be used to manipulate network interfaces.
The
.I ioctl
is made on a socket (typically of type SOCK_DGRAM)
in the desired domain.
Most of the requests supported in earlier releases 
take an
.I ifreq
structure as its parameter.  This structure has the form
.PP
.nf
._d
.DT
struct	ifreq {
#define	IFNAMSIZ	16
	char	ifr_name[IFNAMSIZE];		/* if name, e.g. "en0" */
	union {
		struct	sockaddr ifru_addr;
		struct	sockaddr ifru_dstaddr;
		struct	sockaddr ifru_broadaddr;
		short	ifru_flags;
		int	ifru_metric;
		caddr_t	ifru_data;
	} ifr_ifru;
#define	ifr_addr	ifr_ifru.ifru_addr	/* address */
#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */
#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
#define	ifr_flags	ifr_ifru.ifru_flags	/* flags */
#define	ifr_metric	ifr_ifru.ifru_metric	/* metric */
#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface */
};
.fi
Calls which are now deprecated are:
.TP
SIOCSIFADDR
Set interface address for protocol family.  Following the address
assignment, the ``initialization'' routine for
the interface is called.
.TP
SIOCSIFDSTADDR
Set point to point address for protocol family and interface.
.TP
SIOCSIFBRDADDR
Set broadcast address for protocol family and interface.
.LP
.I Ioctls
requests to obtain addresses and requests both to set and
retreive other data are still fully supported
and use the
.I ifreq
structure:
.TP
SIOCGIFADDR
Get interface address for protocol family.
.TP
SIOCGIFDSTADDR
Get point to point address for protocol family and interface.
.TP
SIOCGIFBRDADDR
Get broadcast address for protocol family and interface.
.TP
SIOCSIFFLAGS
Set interface flags field.  If the interface is marked down,
any processes currently routing packets through the interface
are notified;
some interfaces may be reset so that incoming packets are no longer received.
When marked up again, the interface is reinitialized.
.TP
SIOCGIFFLAGS
Get interface flags.
.TP
SIOCSIFMETRIC
Set interface routing metric.
The metric is used only by user-level routers.
.TP
SIOCGIFMETRIC
Get interface metric.
.LP
There are two requests that make use of a new structure:
.TP
SIOCAIFADDR
An interface may have more than one address associated with it
in some protocols.  This request provides a means to
add additional addresses (or modify characteristics of the
primary address if the default address for the address family
is specified).  Rather than making separate calls to
set destination or broadcast addresses, or network masks
(now an integral feature of multiple protocols)
a separate structure is used to specify all three facets simultaneously:
.nf

.ta \w'struct  'u +\w'struct  'u +\w'sockaddr  'u +\w'ifra_broaddadr   'u
struct ifaliasreq {
	char	ifra_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	struct	sockaddr	ifra_addr;
	struct	sockaddr	ifra_broadaddr;
	struct	sockaddr	ifra_mask;
};
.fi
One would use a slightly tailored version of this struct specific
to each family (replacing each sockaddr by one
of the family-specific type).
Where the sockaddr itself is larger than the
default size, one needs to modify the
.I ioctl
identifier itself to include the total size, as described in
.IR ioctl (2).
.TP
SIOCDIFADDR
This requests deletes the specified address from the list
associated with an interface.  It also uses the if_aliasreq
structure to allow for the possibility of protocols allowing
multiple masks or destination addresses, and also adopts the
convention that specification of the default address means
to delete the first address for the interface belonging to
the address family in which the original socket was opened.
.TP
SIOCGIFCONF
Get interface configuration list.  This request takes an
.I ifconf
structure (see below) as a value-result parameter.  The 
.I ifc_len
field should be initially set to the size of the buffer
pointed to by 
.IR ifc_buf .
On return it will contain the length, in bytes, of the
configuration list.
.PP
._d
.nf
.DT
/*
 * Structure used in SIOCGIFCONF request.
 * Used to retrieve interface configuration
 * for machine (useful for programs which
 * must know all networks accessible).
 */
struct	ifconf {
	int	ifc_len;		/* size of associated buffer */
	union {
		caddr_t	ifcu_buf;
		struct	ifreq *ifcu_req;
	} ifc_ifcu;
#define	ifc_buf	ifc_ifcu.ifcu_buf	/* buffer address */
#define	ifc_req	ifc_ifcu.ifcu_req	/* array of structures returned */
};
.fi
.SH SEE ALSO
socket(2), ioctl(2), intro(4), config(8), routed(8C)
