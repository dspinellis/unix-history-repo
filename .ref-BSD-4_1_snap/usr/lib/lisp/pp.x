(File pp.l)
(printaccross lambda go cdr setq nwritn car $prdf atom null cond quote princ prog)
(printmacrochar lambda add1 cadr $prdf princ cddr cdr null or cond)
(printdef lambda $prdf car cddaddr setq liszt-internal-do mapc cadaddr terpri quote princ last caaddr memq cdddr caddr dtpr atom cadr bigp not cdr null zerop and cond)
(print-lambda lambda tab terpr + $prdf null cddr liszt-internal-do mapc eq let cadr print car quote princ add1 setq return last cdr cond prog)
(printprog lambda + $prdf tab atom null cddr liszt-internal-do mapc cadr print car quote princ add1 setq return last cdr cond prog)
($prd1 lambda print progn printret return quote $patom1 pntlen plus atom |1+| cdr setq null cond car $prdf prog)
($prdf lambda go terpr $prd1 nwritn $patom1 printaccross charcnt + <& print progn printret not printmacrochar Internal-bcdcall getdisc eq bcdp setq cxr getd symbolp funcall quote get or car atom dtpr tab return $prdf patom terpri |1+| flatc cdr >& and cond prog)
($prpr lambda pp-form)
(pp-form lexpr $prdf terpr error arg setq eq =& = cond)
(condclosefile lambda setq close terpr cond)
(pp-prop lambda quote list pp-form)
(pp-function lambda list pp-form drain or patom terpr progn msg quote get bcdp caadr memq cadr dtpr and cond)
(pp-value lambda quote list pp-form)
(pp nlambda get terpri drain or patom progn msg bcdp not cxr getd list apply boundp and eq cdr liszt-internal-do mapc go pp-form outfile cadr eval quote equal dtpr return terpr condclosefile car null cond setq prog)
(printret macro cadr cdr append cons quote list)
